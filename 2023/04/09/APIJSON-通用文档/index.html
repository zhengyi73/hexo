
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>APIJSON 通用文档 - 机器智能</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="TriDiamond Obsidian,"> 
    <meta name="description" content="

APIJSON 通用文档本文是通用文档，只和 APIJSON 协议有关，和 C#, Go, Java, JavaScript, PHP, Python, TypeScript 等开发语言无关。 ,"> 
    <meta name="author" content="Pebble"> 
    <link rel="alternative" href="atom.xml" title="机器智能" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1429596_nzgqgvnmkjb.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.7.2/animate.min.css">

    
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/codemirror.min.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/theme/dracula.css">

    
<link rel="stylesheet" href="/css/obsidian.css">

    
<link rel="stylesheet" href="/css/ball-atom.min.css">

    
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">

<meta name="generator" content="Hexo 6.3.0"></head>


<body class="loading">
    <div class="loader">
        <div class="la-ball-atom la-2x">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>
    <span id="config-title" style="display:none">机器智能</span>
    <div id="loader"></div>
    <div id="single">
    <div class="scrollbar gradient-bg-rev"></div>
<div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <div class="navigation animated fadeIn fast delay-1s">
        <img id="home-icon" class="icon-home" src="/img/favicon.png" alt="" data-url="http://intelnexus.cn">
        <div id="play-icon" title="Play/Pause" class="iconfont icon-play"></div>
        <h3 class="subtitle">APIJSON 通用文档</h3>
        <div class="social">
            <!--        <div class="like-icon">-->
            <!--            <a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
            <!--        </div>-->
            <div>
                <div class="share">
                    
                        <a href="javascript:;" class="iconfont icon-share1"></a>
                        <div class="share-component-cc" data-disabled="facebook,douban,linkedin,diandian,tencent,google"></div>
                    
                </div>
            </div>
        </div>
    </div>
</div>

    <div class="section">
        <div class=article-header-wrapper>
    <div class="article-header">
        <div class="article-cover animated fadeIn" style="
            animation-delay: 600ms;
            animation-duration: 1.2s;
            background-image: 
                radial-gradient(ellipse closest-side, rgba(0, 0, 0, 0.65), #100e17),
                url(/img/cover.jpg) ">
        </div>
        <div class="else">
            <p class="animated fadeInDown">
                
                <a href="javascript:;"><b>「 </b>文章<b> 」</b></a>
                
                四月 09, 2023
            </p>
            <h3 class="post-title animated fadeInDown"><a href="/2023/04/09/APIJSON-%E9%80%9A%E7%94%A8%E6%96%87%E6%A1%A3/" title="APIJSON 通用文档" class="">APIJSON 通用文档</a>
            </h3>
            
            <p class="post-count animated fadeInDown">
                
                <span>
                    <b class="iconfont icon-text2"></b> <i>文章字数</i>
                    51k
                </span>
                
                
                <span>
                    <b class="iconfont icon-timer__s"></b> <i>阅读约需</i>
                    46 mins.
                </span>
                
                
                
                <span id="busuanzi_container_page_pv">
                    <b class="iconfont icon-read"></b> <i>阅读次数</i>
                    <span id="busuanzi_value_page_pv">0</span>
                </span>
                
            </p>
            
            
        </div>
    </div>
</div>

<div class="screen-gradient-after">
    <div class="screen-gradient-content">
        <div class="screen-gradient-content-inside">
            <div class="bold-underline-links screen-gradient-sponsor">
                <p>
                    <span class="animated fadeIn delay-1s"></span>
                </p>
            </div>
        </div>
    </div>
</div>

<div class="article">
    <div class='main'>
        <div class="content markdown animated fadeIn">
            <br />

<h1 id="APIJSON-通用文档"><a href="#APIJSON-通用文档" class="headerlink" title="APIJSON 通用文档"></a>APIJSON 通用文档</h1><p>本文是通用文档，只和 APIJSON 协议有关，和 C#, Go, Java, JavaScript, PHP, Python, TypeScript 等开发语言无关。 <br /><br>具体开发语言相关的 配置、运行、部署 等文档见各个相关项目的文档，可以在首页点击对应语言的入口来查看。<br /><br><img src="https://user-images.githubusercontent.com/5738175/134520081-a63d3817-321c-4e7b-9e03-73c6827a19c1.png" alt="image"></p>
<p>后端开发者可以先看 <a target="_blank" rel="noopener" href="http://apijson.cn/doc/zh/">图文入门教程1</a> 或 <a target="_blank" rel="noopener" href="https://hanxu2018.github.io/APIJSON-DOC/">图文入门教程2</a> （和本文档有出入的点以本文档为准。例如正则匹配 key? 已废弃，用 key~ 替代；例如 “@column”:”store_id,sum(amt):totAmt” 中逗号 , 有误，应该用分号 ; 隔开 SQL 函数，改为 “@column”:”store_id;sum(amt):totAmt”）</p>
<ul>
<li><h3 id="1-示例"><a href="#1-示例" class="headerlink" title="1.示例"></a><a href="#1">1.示例</a></h3></li>
<li><h3 id="2-对比传统方式"><a href="#2-对比传统方式" class="headerlink" title="2.对比传统方式"></a><a href="#2">2.对比传统方式</a></h3></li>
<li><a href="#2.1">2.1 开发流程</a></li>
<li><a href="#2.2">2.2 前端请求</a></li>
<li><a href="#2.3">2.3 后端操作</a></li>
<li><a href="#2.4">2.4 前端解析</a></li>
<li><a href="#2.5">2.5 对应不同需求的请求</a></li>
<li><a href="#2.6">2.6 对应不同请求的结果</a></li>
<li><h3 id="3-设计规范"><a href="#3-设计规范" class="headerlink" title="3.设计规范"></a><a href="#3">3.设计规范</a></h3></li>
<li><a href="#3.1">3.1 操作方法</a></li>
<li><a href="#3.2">3.2 功能符</a></li>
</ul>
<h2 id="1-示例-1"><a href="#1-示例-1" class="headerlink" title="1.示例"></a><h2 id="1">1.示例<h2/></h2><h4 id="获取用户"><a href="#获取用户" class="headerlink" title="获取用户"></a>获取用户</h4><p>请求：</p>
<pre><code class="language-json">&#123;
  "User":&#123;
    "id":38710
  &#125;
&#125;
</code></pre>

<p><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22User%22:%7B%22id%22:38710%7D%7D">点击这里测试</a></p>
<p>返回：</p>
<pre><code class="language-json">&#123;
  "User":&#123;
    "id":38710,
    "sex":0,
    "name":"TommyLemon",
    "tag":"Android&Java",
    "head":"http://static.oschina.net/uploads/user/1218/2437072_100.jpg?t=1461076033000",
    "date":1485948110000,
    "pictureList":[
      "http://static.oschina.net/uploads/user/1218/2437072_100.jpg?t=1461076033000",
      "http://common.cnblogs.com/images/icon_weibo_24.png"
    ]
  &#125;,
  "code":200,
  "msg":"success"
&#125;
</code></pre>

<p align="center" >
  <a >[GIF] APIJSON 各种单表对象查询：简单查询、统计、分组、排序、聚合、比较、筛选字段、字段别名 等</a>
</p> 
  
<p><img src="https://raw.githubusercontent.com/TommyLemon/StaticResources/master/APIJSON/APIJSON_query_single.gif"></p>
<br />

<h4 id="获取用户列表"><a href="#获取用户列表" class="headerlink" title="获取用户列表"></a>获取用户列表</h4><p>请求：</p>
<pre><code class="language-json">&#123;
  "[]":&#123;
    "count":3,             //只要3个
    "User":&#123;
      "@column":"id,name"  //只要id,name这两个字段
    &#125;
  &#125;
&#125;
</code></pre>

<p><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22[]%22:%7B%22count%22:3,%22User%22:%7B%22@column%22:%22id,name%22%7D%7D%7D">点击这里测试</a></p>
<p>返回：</p>
<pre><code class="language-json">&#123;
  "[]":[
    &#123;
      "User":&#123;
        "id":38710,
        "name":"TommyLemon"
      &#125;
    &#125;,
    &#123;
      "User":&#123;
        "id":70793,
        "name":"Strong"
      &#125;
    &#125;,
    &#123;
      "User":&#123;
        "id":82001,
        "name":"Android"
      &#125;
    &#125;
  ],
  "code":200,
  "msg":"success"
&#125;
</code></pre>

<p align="center" >
  <a >[GIF] APIJSON 各种单表数组查询：简单查询、统计、分组、排序、聚合、分页、比较、搜索、正则、条件组合 等</a>
</p> 

<p><img src="https://raw.githubusercontent.com/TommyLemon/StaticResources/master/APIJSON/APIJSON_query_array.gif"></p>
<br />

<h4 id="获取动态及发布者用户"><a href="#获取动态及发布者用户" class="headerlink" title="获取动态及发布者用户"></a>获取动态及发布者用户</h4><p>请求：</p>
<pre><code class="language-json">&#123;
  "Moment":&#123;
  &#125;,
  "User":&#123;
    "id@":"Moment/userId"  //User.id = Moment.userId
  &#125;
&#125;
</code></pre>

<p><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22Moment%22:%7B%7D,%22User%22:%7B%22id@%22:%22Moment%252FuserId%22%7D%7D">点击这里测试</a></p>
<p>返回：</p>
<pre><code class="language-json">&#123;
  "Moment":&#123;
    "id":12,
    "userId":70793,
    "date":"2017-02-08 16:06:11.0",
    "content":"1111534034"
  &#125;,
  "User":&#123;
    "id":70793,
    "sex":0,
    "name":"Strong",
    "tag":"djdj",
    "head":"http://static.oschina.net/uploads/user/585/1170143_50.jpg?t=1390226446000",
    "contactIdList":[
      38710,
      82002
    ],
    "date":"2017-02-01 19:21:50.0"
  &#125;,
  "code":200,
  "msg":"success"
&#125;
</code></pre>
<br />

<h4 id="获取类似微信朋友圈的动态列表"><a href="#获取类似微信朋友圈的动态列表" class="headerlink" title="获取类似微信朋友圈的动态列表"></a>获取类似微信朋友圈的动态列表</h4><p>请求：</p>
<pre><code class="language-json">&#123;
  "[]":&#123;                             //请求一个数组
    "page":0,                        //数组条件
    "count":2,
    "Moment":&#123;                       //请求一个名为Moment的对象
      "content$":"%a%"               //对象条件，搜索content中包含a的动态
    &#125;,
    "User":&#123;
      "id@":"/Moment/userId",        //User.id = Moment.userId  缺省引用赋值路径，从所处容器的父容器路径开始
      "@column":"id,name,head"       //指定返回字段
    &#125;,
    "Comment[]":&#123;                    //请求一个名为Comment的数组，并去除Comment包装
      "count":2,
      "Comment":&#123;
        "momentId@":"[]/Moment/id"   //Comment.momentId = Moment.id  完整引用赋值路径
      &#125;
    &#125;
  &#125;
&#125;
</code></pre>

<p><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22[]%22:%7B%22page%22:0,%22count%22:2,%22Moment%22:%7B%22content$%22:%22%2525a%2525%22%7D,%22User%22:%7B%22id@%22:%22%252FMoment%252FuserId%22,%22@column%22:%22id,name,head%22%7D,%22Comment[]%22:%7B%22count%22:2,%22Comment%22:%7B%22momentId@%22:%22[]%252FMoment%252Fid%22%7D%7D%7D%7D">点击这里测试</a></p>
<p>返回：</p>
<pre><code class="language-json">&#123;
  "[]":[
    &#123;
      "Moment":&#123;
        "id":15,
        "userId":70793,
        "date":1486541171000,
        "content":"APIJSON is a JSON Transmission Structure Protocol…",
        "praiseUserIdList":[
          82055,
          82002,
          82001
        ],
        "pictureList":[
          "http://static.oschina.net/uploads/user/1218/2437072_100.jpg?t=1461076033000",
          "http://common.cnblogs.com/images/icon_weibo_24.png"
        ]
      &#125;,
      "User":&#123;
        "id":70793,
        "name":"Strong",
        "head":"http://static.oschina.net/uploads/user/585/1170143_50.jpg?t=1390226446000"
      &#125;,
      "Comment[]":[
        &#123;
          "id":176,
          "toId":166,
          "userId":38710,
          "momentId":15,
          "date":1490444883000,
          "content":"thank you"
        &#125;,
        &#123;
          "id":1490863469638,
          "toId":0,
          "userId":82002,
          "momentId":15,
          "date":1490863469000,
          "content":"Just do it"
        &#125;
      ]
    &#125;,
    &#123;
      "Moment":&#123;
        "id":58,
        "userId":90814,
        "date":1485947671000,
        "content":"This is a Content...-435",
        "praiseUserIdList":[
          38710,
          82003,
          82005,
          93793,
          82006,
          82044,
          82001
        ],
        "pictureList":[
          "http://static.oschina.net/uploads/img/201604/22172507_aMmH.jpg"
        ]
      &#125;,
      "User":&#123;
        "id":90814,
        "name":7,
        "head":"http://static.oschina.net/uploads/user/51/102723_50.jpg?t=1449212504000"
      &#125;,
      "Comment[]":[
        &#123;
          "id":13,
          "toId":0,
          "userId":82005,
          "momentId":58,
          "date":1485948050000,
          "content":"This is a Content...-13"
        &#125;,
        &#123;
          "id":77,
          "toId":13,
          "userId":93793,
          "momentId":58,
          "date":1485948050000,
          "content":"This is a Content...-77"
        &#125;
      ]
    &#125;
  ],
  "code":200,
  "msg":"success"
&#125;
</code></pre>

<p align="center" >
  <a >[GIF] APIJSON 各种多表关联查询：一对一、一对多、多对一、各种条件 等</a>
</p> 

<p><img src="https://raw.githubusercontent.com/TommyLemon/StaticResources/master/APIJSON/APIJSON_query_associate.gif"></p>
<br />
  
<p align="center" >
  <a >[GIF] APIJSON 各种 JOIN：< LEFT JOIN, & INNER JOIN 等</a>
</p> 

<p><img src="https://raw.githubusercontent.com/TommyLemon/StaticResources/master/APIJSON/APIJSON_query_join.gif"></p>
<br />
  
<p align="center" >
  <a >[GIF] APIJSON 各种子查询：@from@ FROM, key@ =, key>@ >, key{}@ IN, key}{@ EXISTS 等 </a>
</p> 

<p><img src="https://raw.githubusercontent.com/TommyLemon/StaticResources/master/APIJSON/APIJSON_query_subquery.gif"></p>
<br />
    
<p align="center" >
  <a >[GIF] APIJSON 部分功能演示集合，由浅入深、由简单到复杂 </a>
</p> 

<p><img src="https://raw.githubusercontent.com/TommyLemon/StaticResources/master/APIJSON/APIJSON_query_summary.gif"></p>
<br />

<p><a target="_blank" rel="noopener" href="http://apijson.cn/api">在线测试</a></p>
<br />
<br />
 
<h2 id="2-对比传统RESTful方式"><a href="#2-对比传统RESTful方式" class="headerlink" title="2.对比传统RESTful方式"></a><h2 id="2">2.对比传统RESTful方式<h2/></h2><h3 id="2-1-开发流程"><a href="#2-1-开发流程" class="headerlink" title="2.1 开发流程"></a><h3 id="2.1">2.1 开发流程<h3/></h3><table>
<thead>
<tr>
<th>开发流程</th>
<th>传统方式</th>
<th>APIJSON</th>
</tr>
</thead>
<tbody><tr>
<td>接口传输</td>
<td>等后端编辑接口，然后更新文档，前端再按照文档编辑请求和解析代码</td>
<td>前端按照自己的需求编辑请求和解析代码。<br />没有接口，更不需要文档！前端再也不用和后端沟通接口或文档问题了！</td>
</tr>
<tr>
<td>兼容旧版</td>
<td>后端增加新接口，用v2表示第2版接口，然后更新文档</td>
<td>什么都不用做！</td>
</tr>
</tbody></table>
 <br />
 
<h3 id="2-2-前端请求"><a href="#2-2-前端请求" class="headerlink" title="2.2 前端请求"></a><h3 id="2.2">2.2 前端请求<h3/></h3><table>
<thead>
<tr>
<th>前端请求</th>
<th>传统方式</th>
<th>APIJSON</th>
</tr>
</thead>
<tbody><tr>
<td>要求</td>
<td>前端按照文档在对应URL后面拼接键值对</td>
<td>前端按照自己的需求在固定URL后拼接JSON</td>
</tr>
<tr>
<td>URL</td>
<td>不同的请求对应不同的URL，基本上有多少个不同的请求就得有多少个接口URL</td>
<td>相同的操作方法(增删改查)都用同一个URL，<br />大部分请求都用7个通用接口URL的其中一个</td>
</tr>
<tr>
<td>键值对</td>
<td>key&#x3D;value</td>
<td>key:value</td>
</tr>
<tr>
<td>结构</td>
<td>同一个URL内table_name只能有一个 <br /><br /> base_url&#x2F;get&#x2F;table_name?<br />key0&#x3D;value0&amp;key1&#x3D;value1…</td>
<td>同一个URL后TableName可传任意数量个 <br /><br /> base_url&#x2F;get&#x2F;<br />{<br >    TableName0:{<br >      key0:value0,<br >      key1:value1,<br >      …<br >    },<br >    TableName1:{<br >      …<br >    }<br >    …<br > }</td>
</tr>
</tbody></table>
 <br />
 
<h3 id="2-3-后端操作"><a href="#2-3-后端操作" class="headerlink" title="2.3 后端操作"></a><h3 id="2.3">2.3 后端操作<h3/></h3><table>
<thead>
<tr>
<th>后端操作</th>
<th>传统方式</th>
<th>APIJSON</th>
</tr>
</thead>
<tbody><tr>
<td>解析和返回</td>
<td>取出键值对，把键值对作为条件用预设的的方式去查询数据库，最后封装JSON并返回给前端</td>
<td>把Parser#parse方法的返回值返回给前端就行</td>
</tr>
<tr>
<td>返回JSON结构的设定方式</td>
<td>由后端设定，前端不能修改</td>
<td>由前端设定，后端不能修改</td>
</tr>
</tbody></table>
 <br />
 
<h3 id="2-4-前端解析"><a href="#2-4-前端解析" class="headerlink" title="2.4 前端解析"></a><h3 id="2.4">2.4 前端解析<h3/></h3><table>
<thead>
<tr>
<th>前端解析</th>
<th>传统方式</th>
<th>APIJSON</th>
</tr>
</thead>
<tbody><tr>
<td>查看方式</td>
<td>查文档或问后端，或等请求成功后看日志</td>
<td>看请求就行，所求即所得，不用查、不用问、不用等。也可以等请求成功后看日志</td>
</tr>
<tr>
<td>解析方法</td>
<td>用JSON解析器来解析JSONObject</td>
<td>可以用JSONResponse解析JSONObject，或使用传统方式</td>
</tr>
</tbody></table>
 <br />
 
<h3 id="2-5-前端对应不同需求的请求"><a href="#2-5-前端对应不同需求的请求" class="headerlink" title="2.5 前端对应不同需求的请求"></a><h3 id="2.5">2.5 前端对应不同需求的请求<h3/></h3><table>
<thead>
<tr>
<th>前端的请求</th>
<th>传统方式</th>
<th>APIJSON</th>
</tr>
</thead>
<tbody><tr>
<td>User</td>
<td>base_url&#x2F;get&#x2F;user?id&#x3D;38710</td>
<td><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22User%22:%7B%22id%22:38710%7D%7D">base_url&#x2F;get&#x2F;<br >{<br >    “User”:{<br >      “id”:38710<br >    }<br >}</a></td>
</tr>
<tr>
<td>Moment和对应的User</td>
<td>分两次请求<br />Moment: <br /> base_url&#x2F;get&#x2F;moment?userId&#x3D;38710<br /><br />User: <br /> base_url&#x2F;get&#x2F;user?id&#x3D;38710</td>
<td><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22Moment%22:%7B%22userId%22:38710%7D,%22User%22:%7B%22id%22:38710%7D%7D">base_url&#x2F;get&#x2F;<br >{<br >    “Moment”:{<br >      “userId”:38710<br >    }, <br >    “User”:{<br >      “id”:38710<br >    }<br >}</a></td>
</tr>
<tr>
<td>User列表</td>
<td>base_url&#x2F;get&#x2F;user&#x2F;list?<br />page&#x3D;0&amp;count&#x3D;3&amp;sex&#x3D;0</td>
<td><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22User[]%22:%7B%22page%22:0,%22count%22:3,%22User%22:%7B%22sex%22:0%7D%7D%7D">base_url&#x2F;get&#x2F;<br >{<br >    “User[]”:{<br >      “page”:0,<br >       “count”:3, <br >      “User”:{<br >        “sex”:0<br >      }<br >    }<br >}</a></td>
</tr>
<tr>
<td>Moment列表，<br />每个Moment包括<br />1.发布者User<br />2.前3条Comment</td>
<td>Moment里必须有<br />1.User对象<br >2.Comment数组<br /><br /> base_url&#x2F;get&#x2F;moment&#x2F;list?<br />page&#x3D;0&amp;count&#x3D;3&amp;commentCount&#x3D;3</td>
<td><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22[]%22:%7B%22page%22:0,%22count%22:3,%22Moment%22:%7B%7D,%22User%22:%7B%22id@%22:%22%252FMoment%252FuserId%22%7D,%22Comment[]%22:%7B%22count%22:3,%22Comment%22:%7B%22momentId@%22:%22[]%252FMoment%252Fid%22%7D%7D%7D%7D">base_url&#x2F;get&#x2F;<br >{<br >    “[]”:{<br >      “page”:0, <br >      “count”:3, <br >      “Moment”:{}, <br >      “User”:{<br >        “id@”:”&#x2F;Moment&#x2F;userId”<br >      },<br >      “Comment[]”:{<br >        “count”:3,<br >        “Comment”:{<br >          “momentId@”:”[]&#x2F;Moment&#x2F;id”<br >        }<br >      }<br >    }<br >}</a></td>
</tr>
<tr>
<td>User发布的Moment列表，<br /> 每个Moment包括<br /> 1.发布者User<br /> 2.前3条Comment</td>
<td>1.Moment里必须有User对象和Comment数组<br > 2.字段名必须查接口文档，例如评论数量字段名可能是<br /> commentCount,comment_count或者简写cmt_count等各种奇葩写法… <br /><br /> base_url&#x2F;get&#x2F;moment&#x2F;list?<br />page&#x3D;0&amp;count&#x3D;3<br />&amp;commentCount&#x3D;3&amp;userId&#x3D;38710</td>
<td>有以下几种方式:<br /><br /> ① 把以上请求里的<br >“Moment”:{}, “User”:{“id@”:”&#x2F;Moment&#x2F;userId”}<br >改为<br ><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22[]%22:%7B%22page%22:0,%22count%22:3,%22Moment%22:%7B%22userId%22:38710%7D,%22User%22:%7B%22id%22:38710%7D,%22Comment[]%22:%7B%22count%22:3,%22Comment%22:%7B%22momentId@%22:%22[]%252FMoment%252Fid%22%7D%7D%7D%7D">“Moment”:{“userId”:38710}, “User”:{“id”:38710}</a> <br /><br /> ② 或把User放在上面的最外层省去重复的User<br /><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22User%22:%7B%22id%22:38710%7D,%22[]%22:%7B%22page%22:0,%22count%22:3,%22Moment%22:%7B%22userId%22:38710%7D,%22Comment[]%22:%7B%22count%22:3,%22Comment%22:%7B%22momentId@%22:%22[]%252FMoment%252Fid%22%7D%7D%7D%7D">base_url&#x2F;get&#x2F;<br >{<br >    “User”:{<br >      “id”:38710<br >    },<br >    “[]”:{<br >      “page”:0,<br >      “count”:3, <br >      “Moment”:{<br >        “userId”:38710<br >      }, <br >      “Comment[]”:{<br >        “count”:3,<br >        “Comment”:{<br >          “momentId@”:”[]&#x2F;Moment&#x2F;id”<br >        }<br >      }<br >    }<br >}</a><br /><br /> ③ 如果User之前已经获取到了，还可以不传User来节省请求和返回数据的流量并提升速度<br /><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22[]%22:%7B%22page%22:0,%22count%22:3,%22Moment%22:%7B%22userId%22:38710%7D,%22Comment[]%22:%7B%22count%22:3,%22Comment%22:%7B%22momentId@%22:%22[]%252FMoment%252Fid%22%7D%7D%7D%7D">base_url&#x2F;get&#x2F;<br >{<br >    “[]”:{<br >      “page”:0,<br >      “count”:3, <br >      “Moment”:{<br >        “userId”:38710<br >      },<br >      “Comment[]”:{<br >        “count”:3,<br >        “Comment”:{<br >          “momentId@”:”[]&#x2F;Moment&#x2F;id”<br >        }<br >      }<br >    }<br >}</a></td>
</tr>
</tbody></table>
 <br />
 
<h3 id="2-6-后端对应不同请求的返回结果"><a href="#2-6-后端对应不同请求的返回结果" class="headerlink" title="2.6 后端对应不同请求的返回结果"></a><h3 id="2.6">2.6 后端对应不同请求的返回结果<h3/></h3><table>
<thead>
<tr>
<th>后端的返回结果</th>
<th>传统方式</th>
<th>APIJSON</th>
</tr>
</thead>
<tbody><tr>
<td>User</td>
<td>{<br >    “data”:{<br >      “id”:38710,<br >      “name”:”xxx”,<br >      …<br >    },<br >    “code”:200,<br >    “msg”:”success”<br >}</td>
<td>{<br >    “User”:{<br >      “id”:38710,<br >      “name”:”xxx”,<br >      …<br >    },<br >    “code”:200,<br >    “msg”:”success”<br >}</td>
</tr>
<tr>
<td>Moment和对应的User</td>
<td>分别返回两次请求的结果，获取到Moment后取出userId作为User的id条件去查询User <br /><br /> Moment: <br > {<br >    “data”:{<br >      “id”:235,<br >      “content”:”xxx”,<br >      …<br >    },<br >    “code”:200,<br >    “msg”:”success”<br >} <br /><br /> User: <br > {<br >    “data”:{<br >      “id”:38710,<br >      “name”:”xxx”,<br >      …<br >    },<br >    “code”:200,<br >    “msg”:”success”<br >}</td>
<td>一次性返回，没有传统方式导致的 长时间等待结果、两次结果间关联、线程多次切换 等问题 <br /><br /> {<br >    “Moment”:{<br >      “id”:235,<br >      “content”:”xxx”,<br >      …<br >    },<br >    “User”:{<br >      “id”:38710,<br >      “name”:”xxx”,<br >      …<br >    },<br >    “code”:200,<br >    “msg”:”success”<br >}</td>
</tr>
<tr>
<td>User列表</td>
<td>{<br >    “data”:[<br >      {<br >        “id”:38710,<br >        “name”:”xxx”,<br >        …<br >      },<br >      {<br >        “id”:82001,<br >        …<br >      },<br >      …<br >    ],<br >    “code”:200,<br >    “msg”:”success”<br >}</td>
<td>{<br >    “User[]”:[<br >      {<br >        “id”:38710,<br >        “name”:”xxx”,<br >        …<br >      },<br >      {<br >        “id”:82001,<br >        …<br >      },<br >      …<br >    ],<br >    “code”:200,<br >    “msg”:”success”<br >}</td>
</tr>
<tr>
<td>Moment列表，每个Moment包括发布者User和前3条Comment</td>
<td>Moment里必须有<br />1.User对象<br />2.Comment数组 <br /><br /> {<br >    “data”:[<br >      {<br >        “id”:235,<br >        “content”:”xxx”,<br >        …,<br >        “User”:{<br >          …<br >        },<br >        “Comment”:[<br >          …<br >        ]<br >      },<br >      {<br >        “id”:301,<br >        “content”:”xxx”,<br >        …,<br >        “User”:{<br >          …<br >        },<br >        …<br >      },<br >      …<br >    ],<br >    “code”:200,<br >    “msg”:”success”<br >}</td>
<td>1.高灵活，可任意组合<br />2.低耦合，逻辑很清晰<br /><br />{<br >    “[]”:[<br >      {<br >        “Moment”:{<br >          “id”:235,<br >          “content”:”xxx”,<br >          …<br >        },<br >        “User”:{<br >          …<br >        },<br >        “Comment[]”:[<br >          …<br >        ]<br >      },<br >      {<br >        “Moment”:{<br >          “id”:301,<br >          “content”:”xxx”,<br >          …<br >        },<br >        “User”:{<br >          …<br >        },<br >        …<br >      },<br >      …<br >    ],<br >    “code”:200,<br >    “msg”:”success”<br >}</td>
</tr>
<tr>
<td>User发布的Moment列表，每个Moment包括发布者User和前3条Comment</td>
<td>1.大量重复User，浪费流量和服务器性能<br />2.优化很繁琐，需要后端扩展接口、写好文档，前端&#x2F;前端再配合优化<br /><br />{<br >    “data”:[<br >      {<br >        “id”:235,<br >        “content”:”xxx”,<br >        …,<br >        “User”:{<br >          “id”:38710,<br >          “name”:”Tommy”<br >          …<br >        },<br >        “Comment”:[<br >          …<br >        ]<br >        …<br >      },<br >      {<br >        “id”:470,<br >        “content”:”xxx”,<br >        …,<br >        “User”:{<br >          “id”:38710,<br >          “name”:”Tommy”<br >          …<br >        },<br >        “Comment”:[<br >          …<br >        ]<br >        …<br >      },<br >      {<br >        “id”:511,<br >        “content”:”xxx”,<br >        …,<br >        “User”:{<br >          “id”:38710,<br >          “name”:”Tommy”<br >          …<br >        },<br >        “Comment”:[<br >          …<br >        ]<br >        …<br >      },<br >      {<br >        “id”:595,<br >        “content”:”xxx”,<br >        …,<br >        “User”:{<br >          “id”:38710,<br >          “name”:”Tommy”<br >          …<br >        },<br >        “Comment”:[<br >          …<br >        ]<br >        …<br >      },<br >      …<br >    ],<br >    “code”:200,<br >    “msg”:”success”<br >}</td>
<td>以上不同请求方式的结果:<br /><br /> ① 常规请求 <br > {<br >    “[]”:[<br >      {<br >        “Moment”:{<br >          “id”:235,<br >          “content”:”xxx”,<br >          …<br >        },<br >        “User”:{<br >          “id”:38710,<br >          “name”:”Tommy”<br >          …<br >        },<br >        “Comment[]”:[<br >          …<br >        ]<br >      },<br >      …<br >    ],<br >    “code”:200,<br >    “msg”:”success”<br >}<br /><br /> ② 省去重复的User <br > {<br >    “User”:{<br >      “id”:38710,<br >      “name”:”Tommy”,<br >      …<br >    },<br >    “[]”:[<br >      {<br >        “Moment”:{<br >          “id”:235,<br >          “content”:”xxx”,<br >          …<br >        },<br >        “Comment[]”:[<br >          …<br >        ]<br >      },<br >      …<br >    ],<br >    “code”:200,<br >    “msg”:”success”<br >}<br /><br /> ③ 不查询已获取到的User <br > {<br >    “[]”:[<br >      {<br >        “Moment”:{<br >          “id”:235,<br >          “content”:”xxx”,<br >          …<br >        },<br >        “Comment[]”:[<br >          …<br >        ]<br >      },<br >      …<br >    ],<br >    “code”:200,<br >    “msg”:”success”<br >}</td>
</tr>
</tbody></table>
<p>1.base_url指基地址，一般是顶级域名，其它分支url都是在base_url后扩展。如base_url:<a target="_blank" rel="noopener" href="http://apijson.cn:8080/">http://apijson.cn:8080/</a> ，对应的GET分支url:<a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/">http://apijson.cn:8080/get/</a> 。下同。<br ><br>2.请求中的key或value任意一个为null值时，这个 key:value键值对 被视为无效。下同。<br ><br>3.请求中的 &#x2F; 需要转义。JSONRequest.java已经用URLEncoder.encode转义，不需要再写；但如果是浏览器或Postman等直接输入url&#x2F;request，需要把request中的所有 &#x2F; 都改成 %252F 。下同。<br ><br>4.code，指返回结果中的状态码，200表示成功，其它都是错误码，值全部都是HTTP标准状态码。下同。<br ><br>5.msg，指返回结果中的状态信息，对成功结果或错误原因的详细说明。下同。<br ><br>6.code和msg总是在返回结果的同一层级成对出现。对所有请求的返回结果都会在最外层有一对总结式code和msg。下同。<br ><br>7.id等字段对应的值仅供说明，不一定是数据库里存在的，请求里用的是真实存在的值。下同。</p>
<br />
<br />

<h2 id="3-设计规范-1"><a href="#3-设计规范-1" class="headerlink" title="3.设计规范"></a><h2 id="3">3.设计规范<h2/></h2><h3 id="3-1-操作方法"><a href="#3-1-操作方法" class="headerlink" title="3.1 操作方法"></a><h3 id="3.1">3.1 操作方法<h3/></h3><table>
<thead>
<tr>
<th>方法及说明</th>
<th>URL</th>
<th>Request</th>
<th>Response</th>
</tr>
</thead>
<tbody><tr>
<td>GET: <br > 普通获取数据，<br > 可用浏览器调试</td>
<td>base_url&#x2F;get&#x2F;</td>
<td>{<br >    TableName:{<br >      … <br >    }<br >} <br > {…}内为限制条件<br ><br > 例如获取一个 id &#x3D; 235 的 Moment：<br > <a target="_blank" rel="noopener" href="http://apijson.cn/api/?url=http://apijson.cn:8080/get&type=JSON&json=%7B%22Moment%22:%7B%22id%22:235%7D%7D">{<br >    “Moment”:{<br >      “id”:235<br >    }<br >}</a> <br > 后端校验通过后自动解析为 SQL 并执行：<br ><code>SELECT * FROM Moment WHERE id=235 LIMIT 1</code></td>
<td>{<br >    TableName:{<br >      …<br >    },<br >    “code”:200,<br >    “msg”:”success”<br >}<br >例如<br >{<br >    “Moment”:{<br >      “id”:235,<br >      “userId”:38710,<br >      “content”:”APIJSON,let interfaces and documents go to hell !”<br >    },<br >    “code”:200,<br >    “msg”:”success”<br > }</td>
</tr>
<tr>
<td>HEAD: <br > 普通获取数量，<br > 可用浏览器调试</td>
<td>base_url&#x2F;head&#x2F;</td>
<td>{<br >    TableName:{<br >      …<br >    }<br > } <br > {…}内为限制条件 <br ><br > 例如获取一个 id &#x3D; 38710 的 User 所发布的 Moment 总数：<br > <a target="_blank" rel="noopener" href="http://apijson.cn/api/?url=http://apijson.cn:8080/head&type=JSON&json=%7B%22Moment%22:%7B%22userId%22:38710%7D%7D">{<br >    “Moment”:{<br >      “userId”:38710<br >    }<br >}</a> <br > 后端校验通过后自动解析为 SQL 并执行：<br ><code>SELECT count(*) FROM Moment WHERE userId=38710 LIMIT 1</code></td>
<td>{<br >    TableName:{<br >      “code”:200,<br >      “msg”:”success”,<br >      “count”:10<br >    },<br >    “code”:200,<br >    “msg”:”success”<br >} <br > 例如<br >{<br >    “Moment”:{<br >      “code”:200,<br >      “msg”:”success”,<br >      “count”:10<br >    },<br >    “code”:200,<br >     “msg”:”success”<br >}</td>
</tr>
<tr>
<td>GETS: <br > 安全&#x2F;私密获取数据，<br > 用于获取钱包等<br >对安全性要求高的数据</td>
<td>base_url&#x2F;gets&#x2F;</td>
<td>最外层加一个 “tag”:tag，例如 <a target="_blank" rel="noopener" href="http://apijson.cn/api/?url=http://apijson.cn:8080/gets&type=JSON&json=%7B%22tag%22:%22Privacy%22,%22Privacy%22:%7B%22id%22:82001%7D%7D">“tag”:”Privacy”</a>，其它同GET</td>
<td>同GET</td>
</tr>
<tr>
<td>HEADS: <br > 安全&#x2F;私密获取数量，<br > 用于获取银行卡数量等<br >对安全性要求高的数据总数</td>
<td>base_url&#x2F;heads&#x2F;</td>
<td>最外层加一个 “tag”:tag，例如 <a target="_blank" rel="noopener" href="http://apijson.cn/api/?url=http://apijson.cn:8080/heads&type=JSON&json=%7B%22tag%22:%22Verify%22,%22Verify%22:%7B%22phone%22:13000082001%7D%7D">“tag”:”Verify”</a>，其它同HEAD</td>
<td>同HEAD</td>
</tr>
<tr>
<td>POST: <br > 新增数据</td>
<td>base_url&#x2F;post&#x2F;</td>
<td>单个： <br > {<br >    TableName:{<br >      …<br >    },<br >    “tag”:tag<br >} <br > {…}中id由后端生成，不能传 <br ><br >例如当前登录用户 38710 发布一个新 Comment：<br ><a target="_blank" rel="noopener" href="http://apijson.cn/api?url=http://apijson.cn:8080/post&type=JSON&json=%7B%22Comment%22:%7B%22momentId%22:12,%22content%22:%22APIJSON,let%20interfaces%20and%20documents%20go%20to%20hell%20!%22%7D,%22tag%22:%22Comment%22%7D">{<br >    “Comment”:{<br >      “momentId”:12,<br >      “content”:”APIJSON,let interfaces and documents go to hell !” <br >    },<br >    “tag”:”Comment”<br >}</a> <br > 后端校验通过后自动解析为 SQL 并执行：<br ><code>INSERT INTO Comment(userId,momentId,content) VALUES(38710,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;)</code> <br >  <br > 批量： <br > {<br >    TableName[]:[{<br >        …<br >      }, {<br >        …<br >      }<br >      …<br >    ],<br >    “tag”:tag<br >} <br > {…}中id由后端生成，不能传 <br ><br >例如当前登录用户 82001 发布 2 个 Comment：<br ><a target="_blank" rel="noopener" href="http://apijson.cn/api?url=http://apijson.cn:8080/post&type=JSON&json=%7B%22Comment%5B%5D%22:%5B%7B%22momentId%22:12,%22content%22:%22APIJSON,let%20interfaces%20and%20documents%20go%20to%20hell%20!%22%7D,%7B%22momentId%22:15,%22content%22:%22APIJSON%20is%20a%20JSON%20transmision%20protocol.%22%7D%5D,%22tag%22:%22Comment:%5B%5D%22%7D">{<br >    “Comment[]”:[{<br >      “momentId”:12,<br >      “content”:”APIJSON,let interfaces and documents go to hell !”<br >      }, {<br >      “momentId”:15,<br >      “content”:”APIJSON is a JSON transmision protocol.”<br >    }],<br >    “tag”:”Comment:[]”<br >}</a><br >  后端校验通过后自动解析为 SQL 并执行：<br ><code>INSERT INTO Comment(userId,momentId,content) VALUES(82001,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;);</code><br ><br ><code>INSERT INTO Comment(userId,momentId,content) VALUES(82001,15,&#39;APIJSON is a JSON transmision protocol.&#39;);</code></td>
<td>单个： <br > {<br >    TableName:{<br >      “code”:200,<br >      “msg”:”success”,<br >      “id”:38710<br >    },<br >    “code”:200,<br >    “msg”:”success”<br >}<br >例如<br >{<br >    “Comment”:{<br >      “code”:200,<br >      “msg”:”success”,<br >      “id”:120<br >    },<br >    “code”:200,<br >    “msg”:”success”<br >} <br > <br > 批量： <br > {<br >    TableName:{<br >      “code”:200,<br >      “msg”:”success”,<br >      “count”:5,<br >      “id[]”:[1, 2, 3, 4, 5]<br >    },<br >    “code”:200,<br >    “msg”:”success”<br >}<br >例如<br >{<br >    “Comment”:{<br >      “code”:200,<br >      “msg”:”success”,<br >      “count”:2,<br >      “id[]”:[1, 2]<br >    },<br >    “code”:200,<br >    “msg”:”success”<br >}</td>
</tr>
<tr>
<td>PUT: <br > 修改数据，<br > 只修改所传的字段</td>
<td>base_url&#x2F;put&#x2F;</td>
<td>{<br >    TableName:{<br >      “id”:id,<br >      …<br >    },<br >    “tag”:tag<br >} <br > {…} 中 id 或 id{} 至少传一个 <br ><br >例如当前登录用户 82001 修改 id &#x3D; 235 的 Moment 的 content：<br ><a target="_blank" rel="noopener" href="http://apijson.cn/api?url=http://apijson.cn:8080/put&type=JSON&json=%7B%22Moment%22:%7B%22id%22:235,%22content%22:%22APIJSON,let%20interfaces%20and%20documents%20go%20to%20hell%20!%22%7D,%22tag%22:%22Moment%22%7D">{<br >    “Moment”:{<br >      “id”:235,<br >      “content”:”APIJSON,let interfaces and documents go to hell !”<br >    },<br >    “tag”:”Moment”<br >}</a> <br > 后端校验通过后自动解析为 SQL 并执行：<br ><code>UPDATE Moment SET content=&#39;APIJSON,let interfaces and documents go to hell !&#39; WHERE id=235 AND userId=82001 LIMIT 1</code> <br ><br > 批量除了 id{}:[] 也可类似批量 POST，只是每个 {…} 里面都必须有 id。<br >“tag”:”Comment[]” 对应对象 “Comment”:{“id{}”:[1,2,3]}，表示指定记录全部统一设置；<br >“tag”:”Comment:[]” 多了冒号，对应数组 “Comment[]”:[{“id”:1},{“id”:2},{“id”:3}]，表示每项单独设置</td>
<td>同POST</td>
</tr>
<tr>
<td>DELETE: <br > 删除数据</td>
<td>base_url&#x2F;delete&#x2F;</td>
<td>{<br >    TableName:{<br >      “id”:id<br >    },<br >    “tag”:tag<br >} <br > {…} 中 id 或 id{} 至少传一个，一般只传 id 或 id{} <br ><br >例如当前登录用户 82001 批量删除 id &#x3D; 100,110,120 的 Comment：<br ><a target="_blank" rel="noopener" href="http://apijson.cn/api?url=http://apijson.cn:8080/delete&type=JSON&json=%7B%22Comment%22:%7B%22id%7B%7D%22:%5B100,110,120%5D%7D,%22tag%22:%22Comment%5B%5D%22%7D">{<br >    “Comment”:{<br >      “id{}”:[100,110,120]<br >    },<br >    “tag”:”Comment[]”<br >}</a> <br > 后端校验通过后自动解析为 SQL 并执行：<br ><code>DELETE FROM Comment WHERE id IN(100,110,120) AND userId=82001 LIMIT 3</code></td>
<td>{<br >    TableName:{<br >      “code”:200,<br >      “msg”:”success”,<br >      “id[]”:[100,110,120]<br >      “count”:3<br >    },<br >    “code”:200,<br >    “msg”:”success”<br >}<br >例如<br >{<br >   “Comment”:{<br >      “code”:200,<br >      “msg”:”success”,<br >      “id[]”:[100,110,120],<br >      “count”:3<br >   },<br >   “code”:200,<br >   “msg”:”success”<br >}</td>
</tr>
<tr>
<td>以上接口的简单形式: <br > base_url&#x2F;{method}&#x2F;{tag}</td>
<td>GET: 普通获取数据 <br > base_url&#x2F;get&#x2F;{tag} <br ><br > HEAD: 普通获取数量 <br > base_url&#x2F;head&#x2F;{tag} <br ><br > GETS: 安全&#x2F;私密获取数据 <br >  base_url&#x2F;gets&#x2F;{tag} <br ><br > HEADS: 安全&#x2F;私密获取数量 <br > base_url&#x2F;heads&#x2F;{tag} <br ><br > POST: 新增数据 <br >  base_url&#x2F;post&#x2F;{tag} <br ><br > PUT: 修改数据  base_url&#x2F;put&#x2F;{tag} <br ><br > DELETE: 删除数据 <br > base_url&#x2F;delete&#x2F;{tag}</td>
<td>例如安全&#x2F;私密获取一个 id &#x3D; 82001 的 Privacy：<br > <a target="_blank" rel="noopener" href="http://apijson.cn/api/?url=http://apijson.cn:8080/gets/Privacy&type=JSON&json=%7B%22id%22:82001%7D">base_url&#x2F;gets&#x2F;Privacy&#x2F; <br > {“id”:82001}</a> <br > 相当于 <br > <a target="_blank" rel="noopener" href="http://apijson.cn/api/?url=http://apijson.cn:8080/gets&type=JSON&json=%7B%22tag%22:%22Privacy%22,%22Privacy%22:%7B%22id%22:82001%7D%7D">base_url&#x2F;gets&#x2F; <br >{“tag”:”Privacy”, “Privacy”:{“id”:82001}}</a> <br > <br > 例如批量修改 id &#x3D; 114, 124 的 Comment 的 content：<br ><a target="_blank" rel="noopener" href="http://apijson.cn/api?url=http://apijson.cn:8080/put/Comment%5B%5D&type=JSON&json=%7B%22id%7B%7D%22:%5B114,124%5D,%22content%22:%22test%20multi%20put%22%7D">base_url&#x2F;put&#x2F;Comemnt[]&#x2F; <br > {<br >    “id{}”:[114,124],<br >    “content”:”test multi put”<br >}</a> <br > 相当于 <br > <a target="_blank" rel="noopener" href="http://apijson.cn/api?url=http://apijson.cn:8080/put&type=JSON&json=%7B%22tag%22:%22Comment%5B%5D%22,%22Comment%22:%7B%22id%7B%7D%22:%5B114,124%5D,%22content%22:%22test%20multi%20put%22%7D%7D">base_url&#x2F;put&#x2F; <br > {<br >    “tag”:”Comment[]”, <br >    “Comment”:{<br >      “id{}”:[114,124],<br >      “content”:”test multi put”<br >    }<br >}</a></td>
<td>同以上对应的方法</td>
</tr>
</tbody></table>
<p>1.TableName指要查询的数据库表Table的名称字符串。第一个字符为大写字母，剩下的字符要符合英语字母、数字、下划线中的任何一种。对应的值的类型为JSONObject，结构是 {…}，里面放的是Table的字段(列名)。下同。<br ><br>2.”tag”:tag 后面的tag是非GET、HEAD请求中匹配请求的JSON结构的标识，一般是要查询的Table的名称，由后端Request表中指定。下同。<br ><br>3.GET、HEAD请求是开放请求，可任意组合任意嵌套。其它请求为受限制的安全&#x2F;私密请求，对应的 方法（method）, 标识（tag）, 版本（version）, 结构（structure） 都必须和 后端Request表中所指定的 一一对应，否则请求将不被通过。version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本。下同。<br ><br>4.GETS与GET、HEADS与HEAD分别为同一类型的操作方法，请求稍有不同但返回结果相同。下同。<br ><br>5.在HTTP通信中，自动化接口(get,gets,head,heads,post,put,delete) 全用HTTP POST请求。下同。<br ><br>6.所有JSONObject都视为容器(或者文件夹)，结构为 {…} ，里面可以放普通对象或子容器。下同。<br ><br>7.每个对象都有一个唯一的路径(或者叫地址)，假设对象名为refKey，则用 key0&#x2F;key1&#x2F;…&#x2F;refKey 表示。下同。</p>
<br >

<h3 id="3-2-功能符"><a href="#3-2-功能符" class="headerlink" title="3.2 功能符"></a><h3 id="3.2">3.2 功能符<h3/></h3><table>
<thead>
<tr>
<th>功能</th>
<th>键值对格式</th>
<th>使用示例</th>
</tr>
</thead>
<tbody><tr>
<td>查询数组</td>
<td>“key[]”:{}，后面是JSONObject，key可省略。当key和里面的Table名相同时，Table会被提取出来，即 {Table:{Content}} 会被转化为 {Content}</td>
<td><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22User[]%22:%7B%22count%22:3,%22User%22:%7B%7D%7D%7D">{“User[]”:{“User”:{}}}</a>，查询一个User数组。这里key和Table名都是User，User会被提取出来，即 {“User”:{“id”, …}} 会被转化为 {“id”, …}，如果要进一步提取User中的id，可以把User[]改为User-id[]</td>
</tr>
<tr>
<td>匹配选项范围</td>
<td>“key{}”:[]，后面是JSONArray，作为key可取的值的选项</td>
<td><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22User[]%22:%7B%22count%22:3,%22User%22:%7B%22id%7B%7D%22:[38710,82001,70793]%7D%7D%7D">“id{}”:[38710,82001,70793]</a>，对应SQL是<code>id IN(38710,82001,70793)</code>，查询id符合38710,82001,70793中任意一个的一个User数组</td>
</tr>
<tr>
<td>匹配条件范围</td>
<td>“key{}”:”条件0,条件1…”，条件为SQL表达式字符串，可进行数字比较运算等</td>
<td><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22User[]%22:%7B%22count%22:3,%22User%22:%7B%22id%7B%7D%22:%22%3C=80000,%3E90000%22%7D%7D%7D">“id{}”:”&lt;&#x3D;80000,&gt;90000”</a>，对应SQL是<code>id&lt;=80000 OR id&gt;90000</code>，查询id符合id&lt;&#x3D;80000 | id&gt;90000的一个User数组</td>
</tr>
<tr>
<td>包含选项范围</td>
<td>“key&lt;&gt;“:Object  &#x3D;&gt;  “key&lt;&gt;“:[Object]，key对应值的类型必须为JSONArray，Object类型不能为JSON</td>
<td><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22User[]%22:%7B%22count%22:3,%22User%22:%7B%22contactIdList%3C%3E%22:38710%7D%7D%7D">“contactIdList&lt;&gt;“:38710</a>，对应SQL是<code>json_contains(contactIdList,38710)</code>，查询contactIdList包含38710的一个User数组</td>
</tr>
<tr>
<td>判断是否存在</td>
<td>“key}{@”:{<br />    “from”:”Table”,<br />    “Table”:{ … }<br />}<br />其中：<br />}{ 表示 EXISTS；<br /> key 用来标识是哪个判断；<br /> @ 后面是 子查询 对象，具体见下方 子查询 的说明。</td>
<td><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22User%22:%7B%22id%7D%7B@%22:%7B%22from%22:%22Comment%22,%22Comment%22:%7B%22momentId%22:15%7D%7D%7D%7D">“id}{@”:{<br />    “from”:”Comment”,<br />    “Comment”:{<br />        “momentId”:15 <br />    }<br />}</a><br /> WHERE EXISTS(SELECT * FROM Comment WHERE momentId&#x3D;15)</td>
</tr>
<tr>
<td>远程调用函数</td>
<td>“key()”:”函数表达式”，函数表达式为 function(key0,key1…)，会调用后端对应的函数 function(JSONObject request, String key0, String key1…)，实现 参数校验、数值计算、数据同步、消息推送、字段拼接、结构变换 等特定的业务逻辑处理，<br>可使用 - 和 + 表示优先级，解析 key-() &gt; 解析当前对象 &gt; 解析 key() &gt; 解析子对象 &gt; 解析 key+()</td>
<td><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22Moment%22:%7B%22id%22:301,%22isPraised()%22:%22isContain(praiseUserIdList,userId)%22%7D%7D">“isPraised()”:”isContain(praiseUserIdList,userId)”</a>，会调用远程函数 <a target="_blank" rel="noopener" href="https://github.com/APIJSON/apijson-framework/blob/master/src/main/java/apijson/framework/APIJSONFunctionParser.java#L361-L374">boolean isContain(JSONObject request, String array, String value)</a> ，然后变为 “isPraised”:true 这种（假设点赞用户id列表包含了userId，即这个User点了赞）</td>
</tr>
<tr>
<td>存储过程</td>
<td>“@key()”:”SQL函数表达式”，函数表达式为 <br />  function(key0,key1…) <br /> 会调用后端数据库对应的存储过程 SQL函数 <br /> function(String key0, String key1…) <br /> 除了参数会提前赋值，其它和 远程函数 一致</td>
<td><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22User%22:%7B%22@limit%22:10,%22@offset%22:0,%22@procedure()%22:%22getCommentByUserId(id,@limit,@offset)%22%7D%7D">“@limit”:10, <br /> “@offset”:0, <br /> “@procedure()”:”getCommentByUserId(id,@limit,@offset)”</a> <br /> 会转为 <br /> <code>getCommentByUserId(38710,10,0)</code> <br /> 来调用存储过程 SQL 函数 <br /> <code>getCommentByUserId(IN id bigint, IN limit int, IN offset int)</code> <br /> 然后变为 <br />“procedure”:{<br />    “count”:-1, <br />    “update”:false, <br />    “list”:[] <br /> } <br /> 其中 count 是指写操作影响记录行数，-1 表示不是写操作；update 是指是否为写操作（增删改）；list 为返回结果集</td>
</tr>
<tr>
<td>引用赋值</td>
<td>“key@”:”key0&#x2F;key1&#x2F;…&#x2F;refKey”，引用路径为用&#x2F;分隔的字符串。以&#x2F;开头的是缺省引用路径，从声明key所处容器的父容器路径开始；其它是完整引用路径，从最外层开始。<br /> 被引用的refKey必须在声明key的上面。如果对refKey的容器指定了返回字段，则被引用的refKey必须写在@column对应的值内，例如 “@column”:”refKey,key1,…”</td>
<td><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22Moment%22:%7B%22userId%22:38710%7D,%22User%22:%7B%22id@%22:%22%252FMoment%252FuserId%22%7D%7D">“Moment”:{<br />    “userId”:38710<br />},<br />“User”:{<br />    “id@”:”&#x2F;Moment&#x2F;userId”<br />}</a><br /> User内的id引用了与User同级的Moment内的userId，<br />即User.id &#x3D; Moment.userId，请求完成后<br > “id@”:”&#x2F;Moment&#x2F;userId” 会变成 “id”:38710</td>
</tr>
<tr>
<td>子查询</td>
<td>“key@”:{<br />    “range”:”ALL”, <br />    “from”:”Table”,<br />    “Table”:{ … }<br />}<br />其中：<br />range 可为 ALL,ANY；<br />from 为目标表 Table 的名称；<br />@ 后面的对象类似数组对象，可使用 count 和 join 等功能。</td>
<td><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22User%22:%7B%22id@%22:%7B%22from%22:%22Comment%22,%22Comment%22:%7B%22@column%22:%22min(userId)%22%7D%7D%7D%7D">“id@”:{<br />    “from”:”Comment”,<br />    “Comment”:{<br />        “@column”:”min(userId)” <br />    }<br />}</a><br /> WHERE id&#x3D;(SELECT min(userId) FROM Comment)</td>
</tr>
<tr>
<td>模糊搜索</td>
<td><code>&quot;key$&quot;:&quot;SQL搜索表达式&quot;</code>  &#x3D;&gt;  <code>&quot;key$&quot;:[&quot;SQL搜索表达式&quot;]</code>，任意SQL搜索表达式字符串，如 %key%(包含key), key%(以key开始), %k%e%y%(包含字母k,e,y) 等，%表示任意字符</td>
<td><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22User[]%22:%7B%22count%22:3,%22User%22:%7B%22name$%22:%22%2525m%2525%22%7D%7D%7D">“name$”:”%m%”</a>，对应SQL是<code>name LIKE &#39;%m%&#39;</code>，查询name包含”m”的一个User数组</td>
</tr>
<tr>
<td>正则匹配</td>
<td>“key<del>“:”正则表达式”  &#x3D;&gt;  “key</del>“:[“正则表达式”]，任意正则表达式字符串，如 ^[0-9]+$ ，*~ 忽略大小写，可用于高级搜索</td>
<td><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22User[]%22:%7B%22count%22:3,%22User%22:%7B%22name~%22:%22^[0-9]%252B$%22%7D%7D%7D">“name~”:”^[0-9]+$”</a>，对应SQL是<code>name REGEXP &#39;^[0-9]+$&#39;</code>，查询name中字符全为数字的一个User数组</td>
</tr>
<tr>
<td>连续范围</td>
<td>“key%”:”start,end”  &#x3D;&gt;  “key%”:[“start,end”]，其中 start 和 end 都只能为 Boolean, Number, String 中的一种，如 “2017-01-01,2019-01-01” ，[“1,90000”, “82001,100000”] ，可用于连续范围内的筛选</td>
<td><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22User[]%22:%7B%22count%22:3,%22User%22:%7B%22date%2525%22:%222017-10-01,2018-10-01%22%7D%7D%7D">“date%”:”2017-10-01,2018-10-01”</a>，对应SQL是<code>date BETWEEN &#39;2017-10-01&#39; AND &#39;2018-10-01&#39;</code>，查询在2017-10-01和2018-10-01期间注册的用户的一个User数组</td>
</tr>
<tr>
<td>新建别名</td>
<td>“name:alias”，name映射为alias，用alias替代name。可用于 column,Table,SQL函数 等。只用于GET类型、HEAD类型的请求</td>
<td><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22Comment%22:%7B%22@column%22:%22id,toId:parentId%22,%22id%22:51%7D%7D">“@column”:”toId:parentId”</a>，对应SQL是<code>toId AS parentId</code>，将查询的字段toId变为parentId返回</td>
</tr>
<tr>
<td>增加 或 扩展</td>
<td>“key+”:Object，Object的类型由key指定，且类型为Number,String,JSONArray中的一种。如 82001,”apijson”,[“url0”,”url1”] 等。只用于PUT请求</td>
<td>“praiseUserIdList+”:[82001]，对应SQL是<code>json_insert(praiseUserIdList,82001)</code>，添加一个点赞用户id，即这个用户点了赞</td>
</tr>
<tr>
<td>减少 或 去除</td>
<td>“key-“:Object，与”key+”相反</td>
<td>“balance-“:100.00，对应SQL是<code>balance = balance - 100.00</code>，余额减少100.00，即花费了100元</td>
</tr>
<tr>
<td>比较运算</td>
<td>&gt;, &lt;, &gt;&#x3D;, &lt;&#x3D; 比较运算符，用于 <br />① 提供 “id{}”:”&lt;&#x3D;90000” 这种条件范围的简化写法 <br /><br />② 实现子查询相关比较运算<br /><br />不支持 “key&#x3D;”:Object 和 “key!&#x3D;”:Object 这两种写法，直接用更简单的 “key”:Object 和 “key!”:Object 替代。</td>
<td>① <a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22[]%22:%7B%22User%22:%7B%22id%3C=%22:90000%7D%7D%7D">“id&lt;&#x3D;”:90000</a>，对应SQL是<code>id&lt;=90000</code>，查询符合id&lt;&#x3D;90000的一个User数组<br /><br /> ② <a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22User%22:%7B%22id%3E@%22:%7B%22from%22:%22Comment%22,%22Comment%22:%7B%22@column%22:%22min(userId)%22%7D%7D%7D%7D">“id&gt;@”:{<br />    “from”:”Comment”,<br />    “Comment”:{<br />        “@column”:”min(userId)” <br />    }<br />}</a><br /> WHERE id&gt;(SELECT min(userId) FROM Comment)</td>
</tr>
<tr>
<td>逻辑运算</td>
<td>&amp;, |, ! 逻辑运算符，对应数据库 SQL 中的 AND, OR, NOT。 <br />横或纵与：同一键值对的值内条件默认 | 或连接，可以在 key 后加逻辑运算符来具体指定；不同键值对的条件默认 &amp; 与连接，可以用下面说明的对象关键词 @combine 来具体指定。 <br /><br />① &amp; 可用于”key&amp;{}”:”条件”等<br /><br />② | 可用于”key|{}”:”条件”, “key|{}”:[]等，一般可省略<br /><br />③ ! 可单独使用，如”key!”:Object，也可像&amp;,|一样配合其他功能符使用 <br /> “key!”:null 无效，null 值会导致整个键值对被忽略解析，可以用 “key{}”:”!&#x3D;null” 替代，<br />“key”:null 同理，用 “key{}”:”&#x3D;null” 替代。</td>
<td>① <a target="_blank" rel="noopener" href="http://apijson.cn:8080/head/%7B%22User%22:%7B%22id&%7B%7D%22:%22%3E80000,%3C=90000%22%7D%7D">“id&amp;{}”:”&gt;80000,&lt;&#x3D;90000”</a>，对应SQL是<code>id&gt;80000 AND id&lt;=90000</code>，即id满足id&gt;80000 &amp; id&lt;&#x3D;90000<br /><br /> ② <a target="_blank" rel="noopener" href="http://apijson.cn:8080/head/%7B%22User%22:%7B%22id|%7B%7D%22:%22%3E90000,%3C=80000%22%7D%7D">“id|{}”:”&gt;90000,&lt;&#x3D;80000”</a>，同”id{}”:”&gt;90000,&lt;&#x3D;80000”，对应SQL是<code>id&gt;80000 OR id&lt;=90000</code>，即id满足id&gt;90000 | id&lt;&#x3D;80000<br /><br /> ③ <a target="_blank" rel="noopener" href="http://apijson.cn:8080/head/%7B%22User%22:%7B%22id!%7B%7D%22:[82001,38710]%7D%7D">“id!{}”:[82001,38710]</a>，对应SQL是<code>id NOT IN(82001,38710)</code>，即id满足 ! (id&#x3D;82001 | id&#x3D;38710)，可过滤黑名单的消息</td>
</tr>
<tr>
<td>数组关键词，可自定义</td>
<td>“key”:Object，key为 “[]”:{} 中{}内的关键词，Object的类型由key指定<br /><br />① “count”:Integer，查询数量，0 表示最大值，默认最大值为100 <br /><br />② “page”:Integer，查询页码，从0开始，默认最大值为100，一般和count一起用<br /><br />③ “query”:Integer，查询内容<br />0-对象，1-总数和分页详情，2-数据、总数和分页详情<br />总数关键词为 total，分页详情关键词为 info，<br /> 它们都和 query 同级，通过引用赋值得到，例如  <br />“total@”:”&#x2F;[]&#x2F;total”, “info@”:”&#x2F;[]&#x2F;info” <br />这里query及total仅为GET类型的请求提供方便，<br /> 一般可直接用HEAD类型的请求获取总数<br /><br />④ “join”:”&amp;&#x2F;Table0,&lt;&#x2F;Table1&#x2F;key1@” 或 <br />“join”:{<br />    “&amp;&#x2F;Table0”:{},  &#x2F;&#x2F; 支持 ON 多个字段关联,<br />    “&lt;&#x2F;Table1&#x2F;key1@”:{  &#x2F;&#x2F; ON 只允许指定的 key1 关联<br />      “key0”:value0,  &#x2F;&#x2F; 其它ON条件 <br />      “key2”:value2,<br />      … <br />      “@combine”:”…”,  &#x2F;&#x2F; 其它ON条件的组合方式 <br />      “@column”:”…”,  &#x2F;&#x2F; 外层 SELECT <br />      “@group”:”…”,  &#x2F;&#x2F; 外层 GROUP BY <br />      “@having”:”…”  &#x2F;&#x2F; 外层 HAVING <br />    }<br />}<br />多表连接方式：<br />  “@” - APP JOIN <br /> “&lt;“ - LEFT JOIN <br /> “&gt;” - RIGHT JOIN <br /> “&amp;” - INNER JOIN <br /> “|” - FULL JOIN <br />  “!” - OUTER JOIN <br />  “*” - CROSS JOIN <br />  “^” - SIDE JOIN <br />  “(“ - ANTI JOIN <br />  “)” - FOREIGN JOIN <br />其中 @ APP JOIN 为应用层连表，会从已查出的主表里取得所有副表 key@ 关联的主表内的 refKey 作为一个数组 refKeys: [value0, value1…]，然后把原来副表 count 次查询 key&#x3D;$refKey 的 SQL 用 key IN($refKeys) 的方式合并为一条 SQL 来优化性能；<br /> 其它 JOIN 都是 SQL JOIN，具体功能和 MySQL,PostgreSQL 等数据库的 JOIN 一一对应 <br /><code>&quot;join&quot;:&quot;&lt;/ViceTable/key@&quot;,</code><br /><code>&quot;MainTable&quot;:&#123;&#125;,</code><br /><code>&quot;ViceTable&quot;:&#123;&quot;key@&quot;:&quot;/MainTable/refKey&quot;&#125;</code><br />会对应生成 <br /><code>MainTable LEFT JOIN ViceTable</code> <br /><code>ON ViceTable.key=MainTable.refKey</code> AND 其它ON条件 <br /> 除了 &#x3D; 等价关联，也支持 ! 不等关联、&gt; &lt; &gt;&#x3D; &lt;&#x3D; 等比较关联和 $ ~ {} &lt;&gt; 等其它复杂关联方式 <br /><br />⑤ “otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值</td>
<td>① 查询User数组，最多5个：<br /><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22[]%22:%7B%22count%22:5,%22User%22:%7B%7D%7D%7D">“count”:5</a><br />对应SQL是<code>LIMIT 5</code> <br /><br /> ② 查询第3页的User数组，每页5个：<br /><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22[]%22:%7B%22count%22:5,%22page%22:3,%22User%22:%7B%7D%7D%7D">“count”:5,<br />“page”:3</a><br />对应SQL是<code>LIMIT 5 OFFSET 15</code> <br /><br /> ③ 查询User数组和对应的User总数：<br /><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22[]%22:%7B%22query%22:2,%22count%22:5,%22User%22:%7B%7D%7D,%22total@%22:%22%252F[]%252Ftotal%22,%22info@%22:%22%252F[]%252Finfo%22%7D">“[]”:{<br />    “query”:2,<br />    “User”:{}<br />},<br />“total@”:”&#x2F;[]&#x2F;total”,<br />“info@”:”&#x2F;[]&#x2F;info”</a><br /> 返回的数据中，总数及分页详情结构为： <br />  “total”:139,  &#x2F;&#x2F;总数 <br /> “info”:{  &#x2F;&#x2F;分页详情 <br />    “total”:139,  &#x2F;&#x2F;总数 <br />    “count”:5,  &#x2F;&#x2F;每页数量 <br />    “page”:0,  &#x2F;&#x2F;当前页码 <br />    “max”:27,  &#x2F;&#x2F;最大页码 <br />    “more”:true,  &#x2F;&#x2F;是否还有更多 <br />    “first”:true,  &#x2F;&#x2F;是否为首页 <br />    “last”:false  &#x2F;&#x2F;是否为尾页 <br />} <br /><br /> ④ Moment INNER JOIN User LEFT JOIN Comment：<br /><a target="_blank" rel="noopener" href="http://apijson.cn/api/?type=JSON&url=http://apijson.cn:8080/get&json=%7B%22%5B%5D%22:%7B%22count%22:5,%22join%22:%22&/User/id@,%3C/Comment%22,%22Moment%22:%7B%22@column%22:%22id,userId,content%22,%22@group%22:%22id%22%7D,%22User%22:%7B%22name~%22:%22t%22,%22id@%22:%22/Moment/userId%22,%22@column%22:%22id,name,head%22%7D,%22Comment%22:%7B%22momentId@%22:%22/Moment/id%22,%22@column%22:%22id,momentId,content%22%7D%7D%7D">“[]”:{<br />    “join”:”&amp;&#x2F;User&#x2F;id@,&lt;&#x2F;Comment”,<br />    “Moment”:{<br />     “@group”:”id”  &#x2F;&#x2F;主副表不是一对一，要去除重复数据<br />   },<br />    “User”:{<br />      “name~”:”t”,<br />      “id@”:”&#x2F;Moment&#x2F;userId”<br />    },<br />    “Comment”:{<br />      “momentId@”:”&#x2F;Moment&#x2F;id”<br />    }<br />}</a><br /><br /> ⑤ 每一层都加当前用户名：<br /><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22User%22:%7B%7D,%22[]%22:%7B%22name@%22:%22User%252Fname%22,%22Moment%22:%7B%7D%7D%7D">“User”:{},<br />“[]”:{<br />    “name@”:”User&#x2F;name”, &#x2F;&#x2F;自定义关键词<br />    “Moment”:{}<br />}</a></td>
</tr>
<tr>
<td>对象关键词，可自定义</td>
<td>“@key”:Object，@key为 Table:{} 中{}内的关键词，Object的类型由@key指定<br /><br />① “@combine”:”key0 | (key1 &amp; (key2 | !key3))…”，条件组合方式，最终按 <br /> (其它key条件 AND 连接) AND (key0条件 OR (key1条件 AND (key2条件 OR (NOT key3条件)))) <br />这种方式连接，其中 “其它key” 是指与 @combine 在同一对象，且未被它声明的条件 key，默认都是 &amp; 连接。注意不要缺少或多余任何一个空格。 <br /><br />② “@column”:”column;function(arg)…”，返回字段<br /><br />③ “@order”:”column0+,column1-…”，排序方式<br /><br />④ “@group”:”column0,column1…”，分组方式。如果@column里声明了Table的id，则id也必须在@group中声明；其它情况下必须满足至少一个条件:<br />1.分组的key在@column里声明<br />2.Table主键在@group中声明 <br /><br />⑤ “@having”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…” &#x2F;&#x2F; OR 连接，或 <br />“@having&amp;”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…”  &#x2F;&#x2F; AND 连接，或 <br />“@having”:{<br />   “h0”:”function0(…)?value0”,<br />   “h1”:function1(…)?value1”,<br />   “h2”:function2(…)?value2…”,<br />   “@combine”:”h0 &amp; (h1 | !h2)”  &#x2F;&#x2F; 任意组合，非必传<br />}<br />SQL函数条件，一般和@group一起用，函数一般在@column里声明<br /><br />⑥ “@schema”:”sys”，集合空间(数据库名&#x2F;模式)，非默认的值可通过它来指定，可以在最外层作为全局默认配置<br /><br />⑦ “@database”:”POSTGRESQL”，数据库类型，非默认的值可通过它来指定，可以在最外层作为全局默认配置<br /><br />⑧ “@datasource”:”DRUID”，跨数据源，非默认的值可通过它来指定，可以在最外层作为全局默认配置<br /><br />⑨ “@json”:”key0,key1…”，转为 JSON 格式返回，符合 JSONObject 则转为 {…}，符合 JSONArray 则转为 […] <br /><br />⑩ “@role”:”OWNER”，来访角色，包括<br />UNKNOWN,LOGIN,CONTACT,CIRCLE,OWNER,ADMIN，<br />可以在最外层作为全局默认配置，<br />可自定义其它角色并重写 Verifier.verify 等相关方法来自定义校验 <br /><br />⑪ “@explain”:true，性能分析，可以在最外层作为全局默认配置 <br /><br />⑫ “@raw”:”key0,key1…”，其中 key0, key1 都对应有键值对<br /> “key0”:”SQL片段或SQL片段的别名”, <br /> “key1”:”SQL片段或SQL片段的别名” <br /> 自定义原始SQL片段，可扩展嵌套SQL函数等复杂语句，必须是后端已配置的，只有其它功能符都做不到才考虑，谨慎使用，注意防SQL注入<br /><br />⑬ “@otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值</td>
<td>① 搜索name或tag任何一个字段包含字符a的User列表：<br /> <a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22User[]%22:%7B%22count%22:10,%22User%22:%7B%22@column%22:%22id,name,tag%22,%22name~%22:%22a%22,%22tag~%22:%22a%22,%22@combine%22:%22name~%20%7C%20tag~%22%7D%7D%7D">“name<del>“:”a”,<br />“tag</del>“:”a”,<br />“@combine”:”name~ | tag~”</a> <br />对应SQL是<code>name REGEXP &#39;a&#39; OR tag REGEXP &#39;a&#39;</code> <br /><br /> ② 只查询id,sex,name这几列并且请求结果也按照这个顺序：<br /><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22User%22:%7B%22@column%22:%22id,sex,name%22,%22id%22:38710%7D%7D">“@column”:”id,sex,name”</a><br />对应SQL是<code>SELECT id,sex,name</code> <br /><br /> ③ 查询按 name降序、id默认顺序 排序的User数组：<br /><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22[]%22:%7B%22count%22:10,%22User%22:%7B%22@column%22:%22name,id%22,%22@order%22:%22name-,id%22%7D%7D%7D">“@order”:”name-,id”</a><br />对应SQL是<code>ORDER BY name DESC,id</code> <br /><br /> ④ 查询按userId分组的Moment数组：<br /><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22[]%22:%7B%22count%22:10,%22Moment%22:%7B%22@column%22:%22userId,id%22,%22@group%22:%22userId,id%22%7D%7D%7D">“@group”:”userId,id”</a><br />对应SQL是<code>GROUP BY userId,id</code> <br /><br /> ⑤ 查询 按userId分组、id最大值&gt;&#x3D;100 的Moment数组：<br /><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22[]%22:%7B%22count%22:10,%22Moment%22:%7B%22@column%22:%22userId%253Bmax(id)%22,%22@group%22:%22userId%22,%22@having%22:%22max(id)%3E=100%22%7D%7D%7D">“@column”:”userId;max(id)”,<br />“@group”:”userId”,<br />“@having”:”max(id)&gt;&#x3D;100”</a><br />对应SQL是<code>SELECT userId,max(id) ... GROUP BY userId HAVING max(id)&gt;=100</code> <br />还可以指定函数返回名：<br /><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22[]%22:%7B%22count%22:10,%22Moment%22:%7B%22@column%22:%22userId%253Bmax(id):maxId%22,%22@group%22:%22userId%22,%22@having%22:%22(maxId)%3E=100%22%7D%7D%7D">“@column”:”userId;max(id):maxId”,<br />“@group”:”userId”,<br />“@having”:”(maxId)&gt;&#x3D;100”</a><br />对应SQL是<code>SELECT userId,max(id) AS maxId ... GROUP BY userId HAVING (maxId)&gt;=100</code> <br /><br /> ⑥ 查询 sys 内的 User 表：<br /><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22User%22:%7B%22@schema%22:%22sys%22%7D%7D">“@schema”:”sys”</a><br />对应SQL是<code>FROM sys.User</code> <br /><br /> ⑦ 查询 PostgreSQL 数据库的 User 表：<br /><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22User%22:%7B%22@database%22:%22POSTGRESQL%22,%22@explain%22:true%7D%7D">“@database”:”POSTGRESQL”</a><br /><br /> ⑧ 使用 Druid 连接池查询 User 表：<br /><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22User%22:%7B%22@datasource%22:%22DRUID%22%7D%7D">“@datasource”:”DRUID”</a><br /><br /> ⑨ 将 VARCHAR 字符串字段 get 转为 JSONArray 返回：<br /><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22Access%22:%7B%22@json%22:%22get%22%7D%7D">“@json”:”get”</a><br /><br /> ⑩ 查询当前用户的动态：<br /><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22[]%22:%7B%22Moment%22:%7B%22@role%22:%22OWNER%22%7D%7D%7D">“@role”:”OWNER”</a><br /><br /> ⑪ 开启性能分析：<br /><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22[]%22:%7B%22Moment%22:%7B%22@explain%22:true%7D%7D%7D">“@explain”:true</a><br />对应SQL是<code>EXPLAIN</code> <br /><br /> ⑫ 统计最近一周偶数userId的数量<br /><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22[]%22:%7B%22Moment%22:%7B%22@column%22:%22date%3bleft(date,10):day%3bsum(if(userId%252=0,1,0))%22,%22@group%22:%22day%22,%22@having%22:%22to_days(now())-to_days(%60date%60)%3C=7%22,%22@raw%22:%22@column,@having%22%7D%7D%7D">“@column”:”date;left(date,10):day;sum(if(userId%2&#x3D;0,1,0))”,<br />“@group”:”day”,<br />“@having”:”to_days(now())-to_days(`date`)&lt;&#x3D;7”,<br />“@raw”:”@column,@having”</a><br />对应SQL是<code>SELECT date, left(date,10) AS day, sum(if(userId%2=0,1,0)) ... GROUP BY day HAVING to_days(now())-to_days(`date`)&lt;=7</code> <br /><br /> ⑬ 从pictureList获取第0张图片：<br /><a target="_blank" rel="noopener" href="http://apijson.cn:8080/get/%7B%22User%22:%7B%22id%22:38710,%22@position%22:0,%22firstPicture()%22:%22getFromArray(pictureList,@position)%22%7D%7D">“@position”:0, &#x2F;&#x2F;自定义关键词<br />“firstPicture()”:”getFromArray(pictureList,@position)”</a></td>
</tr>
<tr>
<td>全局关键词</td>
<td>为最外层对象 {} 内的关键词。其中 @database，@schema, @datasource, @role, @explain 基本同对象关键词，见上方说明，区别是全局关键词会每个表对象中没有时自动放入，作为默认值。 <br /><br />① “tag”:String，后面的 tag 是非 GET、HEAD 请求中匹配请求的 JSON 结构的标识，一般是要查询的 Table 的名称或该名称对应的数组 Table[] 或 Table:[]，由后端 Request 表中指定。 <br /><br />② “version”:Integer，接口版本，version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本，由后端 Request 表中指定。<br /><br />③ “format”:Boolean，格式化返回 Response JSON 的 key，一般是将 TableName 转为 tableName, TableName[] 转为 tableNameList, Table:alias 转为 alias, TableName-key[] 转为 tableNameKeyList 等小驼峰格式。</td>
<td>①  查隐私信息：<br />[{“tag”:”Privacy”,”Privacy”:{“id”:82001}}](<a target="_blank" rel="noopener" href="http://apijson.cn/api?url=http://apijson.cn:8080/gets&type=JSON&json=">http://apijson.cn/api?url=http%3A%2F%2Fapijson.cn%3A8080%2Fgets&amp;type=JSON&amp;json=</a></td>
</tr>
</tbody></table>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls"
                data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
            <ul id="audio-list" style="display:none">
                
                
                <li title='0' data-url='/statics/chengdu.mp3'></li>
                
                    
            </ul>
            
            
            <div class="post-nav">
                <hr>
                
                
                    <div class="post-nav-item">下一篇:<a href="/2023/04/09/APIJSON-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/" rel="next" 
                        title="APIJSON 入门教程">APIJSON 入门教程</a></div>
                                
            </div>   
                        
            
            
    <div id='gitalk-container' class="comment link"
        data-ae='true'
        data-ci='ec894e2b66f752e8b7fb'
        data-cs='3ccc2e92bb350688fe2c2dc2930189b62622bfb1'
        data-r='blog-comments'
        data-o='TriDiamond'
        data-a='TriDiamond'
        data-d=''
        data-p='https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token'
    >留言</div>


            
            
        </div>
        <div class="sidebar">
            <div class="box animated fadeInRight">
                <div class="subbox">
                    <img src="https://res.cloudinary.com/tridiamond/image/upload/v1573019751/TriDiamond_logo_ui_xeublz.jpg" height=300 width=300></img>
                    <p>Pebble</p>
                    <span>Think like an artist, develop like an artisan</span>
                    <dl>
                        
                        
                    </dl>
                </div>
                <ul>
                    <li><a href="/">3 <p>文章</p></a></li>
                    <li><a href="/categories">0 <p>分类</p></a></li>
                    <li><a href="/tags">0 <p>标签</p></a></li>
                </ul>
            </div>
            
            
            
            <div class="box sticky animated fadeInRight faster">
                <div id="toc" class="subbox">
                    <h4>目录</h4>
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#APIJSON-%E9%80%9A%E7%94%A8%E6%96%87%E6%A1%A3"><span class="toc-number">1.</span> <span class="toc-text">APIJSON 通用文档</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.0.1.</span> <span class="toc-text">1.示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AF%B9%E6%AF%94%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F"><span class="toc-number">1.0.2.</span> <span class="toc-text">2.对比传统方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="toc-number">1.0.3.</span> <span class="toc-text">3.设计规范</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">1.1.</span> <span class="toc-text">1.示例获取用户请求：
{
  &quot;User&quot;:{
    &quot;id&quot;:38710
  }
}


点击这里测试
返回：
{
  &quot;User&quot;:{
    &quot;id&quot;:38710,
    &quot;sex&quot;:0,
    &quot;name&quot;:&quot;TommyLemon&quot;,
    &quot;tag&quot;:&quot;Android&amp;Java&quot;,
    &quot;head&quot;:&quot;http:&#x2F;&#x2F;static.oschina.net&#x2F;uploads&#x2F;user&#x2F;1218&#x2F;2437072_100.jpg?t&#x3D;1461076033000&quot;,
    &quot;date&quot;:1485948110000,
    &quot;pictureList&quot;:[
      &quot;http:&#x2F;&#x2F;static.oschina.net&#x2F;uploads&#x2F;user&#x2F;1218&#x2F;2437072_100.jpg?t&#x3D;1461076033000&quot;,
      &quot;http:&#x2F;&#x2F;common.cnblogs.com&#x2F;images&#x2F;icon_weibo_24.png&quot;
    ]
  },
  &quot;code&quot;:200,
  &quot;msg&quot;:&quot;success&quot;
}



  [GIF] APIJSON 各种单表对象查询：简单查询、统计、分组、排序、聚合、比较、筛选字段、字段别名 等
 
  



获取用户列表请求：
{
  &quot;[]&quot;:{
    &quot;count&quot;:3,             &#x2F;&#x2F;只要3个
    &quot;User&quot;:{
      &quot;@column&quot;:&quot;id,name&quot;  &#x2F;&#x2F;只要id,name这两个字段
    }
  }
}


点击这里测试
返回：
{
  &quot;[]&quot;:[
    {
      &quot;User&quot;:{
        &quot;id&quot;:38710,
        &quot;name&quot;:&quot;TommyLemon&quot;
      }
    },
    {
      &quot;User&quot;:{
        &quot;id&quot;:70793,
        &quot;name&quot;:&quot;Strong&quot;
      }
    },
    {
      &quot;User&quot;:{
        &quot;id&quot;:82001,
        &quot;name&quot;:&quot;Android&quot;
      }
    }
  ],
  &quot;code&quot;:200,
  &quot;msg&quot;:&quot;success&quot;
}



  [GIF] APIJSON 各种单表数组查询：简单查询、统计、分组、排序、聚合、分页、比较、搜索、正则、条件组合 等
 




获取动态及发布者用户请求：
{
  &quot;Moment&quot;:{
  },
  &quot;User&quot;:{
    &quot;id@&quot;:&quot;Moment&#x2F;userId&quot;  &#x2F;&#x2F;User.id &#x3D; Moment.userId
  }
}


点击这里测试
返回：
{
  &quot;Moment&quot;:{
    &quot;id&quot;:12,
    &quot;userId&quot;:70793,
    &quot;date&quot;:&quot;2017-02-08 16:06:11.0&quot;,
    &quot;content&quot;:&quot;1111534034&quot;
  },
  &quot;User&quot;:{
    &quot;id&quot;:70793,
    &quot;sex&quot;:0,
    &quot;name&quot;:&quot;Strong&quot;,
    &quot;tag&quot;:&quot;djdj&quot;,
    &quot;head&quot;:&quot;http:&#x2F;&#x2F;static.oschina.net&#x2F;uploads&#x2F;user&#x2F;585&#x2F;1170143_50.jpg?t&#x3D;1390226446000&quot;,
    &quot;contactIdList&quot;:[
      38710,
      82002
    ],
    &quot;date&quot;:&quot;2017-02-01 19:21:50.0&quot;
  },
  &quot;code&quot;:200,
  &quot;msg&quot;:&quot;success&quot;
}



获取类似微信朋友圈的动态列表请求：
{
  &quot;[]&quot;:{                             &#x2F;&#x2F;请求一个数组
    &quot;page&quot;:0,                        &#x2F;&#x2F;数组条件
    &quot;count&quot;:2,
    &quot;Moment&quot;:{                       &#x2F;&#x2F;请求一个名为Moment的对象
      &quot;content$&quot;:&quot;%a%&quot;               &#x2F;&#x2F;对象条件，搜索content中包含a的动态
    },
    &quot;User&quot;:{
      &quot;id@&quot;:&quot;&#x2F;Moment&#x2F;userId&quot;,        &#x2F;&#x2F;User.id &#x3D; Moment.userId  缺省引用赋值路径，从所处容器的父容器路径开始
      &quot;@column&quot;:&quot;id,name,head&quot;       &#x2F;&#x2F;指定返回字段
    },
    &quot;Comment[]&quot;:{                    &#x2F;&#x2F;请求一个名为Comment的数组，并去除Comment包装
      &quot;count&quot;:2,
      &quot;Comment&quot;:{
        &quot;momentId@&quot;:&quot;[]&#x2F;Moment&#x2F;id&quot;   &#x2F;&#x2F;Comment.momentId &#x3D; Moment.id  完整引用赋值路径
      }
    }
  }
}


点击这里测试
返回：
{
  &quot;[]&quot;:[
    {
      &quot;Moment&quot;:{
        &quot;id&quot;:15,
        &quot;userId&quot;:70793,
        &quot;date&quot;:1486541171000,
        &quot;content&quot;:&quot;APIJSON is a JSON Transmission Structure Protocol…&quot;,
        &quot;praiseUserIdList&quot;:[
          82055,
          82002,
          82001
        ],
        &quot;pictureList&quot;:[
          &quot;http:&#x2F;&#x2F;static.oschina.net&#x2F;uploads&#x2F;user&#x2F;1218&#x2F;2437072_100.jpg?t&#x3D;1461076033000&quot;,
          &quot;http:&#x2F;&#x2F;common.cnblogs.com&#x2F;images&#x2F;icon_weibo_24.png&quot;
        ]
      },
      &quot;User&quot;:{
        &quot;id&quot;:70793,
        &quot;name&quot;:&quot;Strong&quot;,
        &quot;head&quot;:&quot;http:&#x2F;&#x2F;static.oschina.net&#x2F;uploads&#x2F;user&#x2F;585&#x2F;1170143_50.jpg?t&#x3D;1390226446000&quot;
      },
      &quot;Comment[]&quot;:[
        {
          &quot;id&quot;:176,
          &quot;toId&quot;:166,
          &quot;userId&quot;:38710,
          &quot;momentId&quot;:15,
          &quot;date&quot;:1490444883000,
          &quot;content&quot;:&quot;thank you&quot;
        },
        {
          &quot;id&quot;:1490863469638,
          &quot;toId&quot;:0,
          &quot;userId&quot;:82002,
          &quot;momentId&quot;:15,
          &quot;date&quot;:1490863469000,
          &quot;content&quot;:&quot;Just do it&quot;
        }
      ]
    },
    {
      &quot;Moment&quot;:{
        &quot;id&quot;:58,
        &quot;userId&quot;:90814,
        &quot;date&quot;:1485947671000,
        &quot;content&quot;:&quot;This is a Content...-435&quot;,
        &quot;praiseUserIdList&quot;:[
          38710,
          82003,
          82005,
          93793,
          82006,
          82044,
          82001
        ],
        &quot;pictureList&quot;:[
          &quot;http:&#x2F;&#x2F;static.oschina.net&#x2F;uploads&#x2F;img&#x2F;201604&#x2F;22172507_aMmH.jpg&quot;
        ]
      },
      &quot;User&quot;:{
        &quot;id&quot;:90814,
        &quot;name&quot;:7,
        &quot;head&quot;:&quot;http:&#x2F;&#x2F;static.oschina.net&#x2F;uploads&#x2F;user&#x2F;51&#x2F;102723_50.jpg?t&#x3D;1449212504000&quot;
      },
      &quot;Comment[]&quot;:[
        {
          &quot;id&quot;:13,
          &quot;toId&quot;:0,
          &quot;userId&quot;:82005,
          &quot;momentId&quot;:58,
          &quot;date&quot;:1485948050000,
          &quot;content&quot;:&quot;This is a Content...-13&quot;
        },
        {
          &quot;id&quot;:77,
          &quot;toId&quot;:13,
          &quot;userId&quot;:93793,
          &quot;momentId&quot;:58,
          &quot;date&quot;:1485948050000,
          &quot;content&quot;:&quot;This is a Content...-77&quot;
        }
      ]
    }
  ],
  &quot;code&quot;:200,
  &quot;msg&quot;:&quot;success&quot;
}



  [GIF] APIJSON 各种多表关联查询：一对一、一对多、多对一、各种条件 等
 



  

  [GIF] APIJSON 各种 JOIN：&lt; LEFT JOIN, &amp; INNER JOIN 等
 



  

  [GIF] APIJSON 各种子查询：@from@ FROM, key@ &#x3D;, key&gt;@ &gt;, key{}@ IN, key}{@ EXISTS 等 
 



    

  [GIF] APIJSON 部分功能演示集合，由浅入深、由简单到复杂 
 




在线测试


 
2.对比传统RESTful方式2.1 开发流程


开发流程
传统方式
APIJSON



接口传输
等后端编辑接口，然后更新文档，前端再按照文档编辑请求和解析代码
前端按照自己的需求编辑请求和解析代码。没有接口，更不需要文档！前端再也不用和后端沟通接口或文档问题了！


兼容旧版
后端增加新接口，用v2表示第2版接口，然后更新文档
什么都不用做！


 
 
2.2 前端请求


前端请求
传统方式
APIJSON



要求
前端按照文档在对应URL后面拼接键值对
前端按照自己的需求在固定URL后拼接JSON


URL
不同的请求对应不同的URL，基本上有多少个不同的请求就得有多少个接口URL
相同的操作方法(增删改查)都用同一个URL，大部分请求都用7个通用接口URL的其中一个


键值对
key&#x3D;value
key:value


结构
同一个URL内table_name只能有一个  base_url&#x2F;get&#x2F;table_name?key0&#x3D;value0&amp;key1&#x3D;value1…
同一个URL后TableName可传任意数量个  base_url&#x2F;get&#x2F;{    TableName0:{      key0:value0,      key1:value1,      …    },    TableName1:{      …    }    … }


 
 
2.3 后端操作


后端操作
传统方式
APIJSON



解析和返回
取出键值对，把键值对作为条件用预设的的方式去查询数据库，最后封装JSON并返回给前端
把Parser#parse方法的返回值返回给前端就行


返回JSON结构的设定方式
由后端设定，前端不能修改
由前端设定，后端不能修改


 
 
2.4 前端解析


前端解析
传统方式
APIJSON



查看方式
查文档或问后端，或等请求成功后看日志
看请求就行，所求即所得，不用查、不用问、不用等。也可以等请求成功后看日志


解析方法
用JSON解析器来解析JSONObject
可以用JSONResponse解析JSONObject，或使用传统方式


 
 
2.5 前端对应不同需求的请求


前端的请求
传统方式
APIJSON



User
base_url&#x2F;get&#x2F;user?id&#x3D;38710
base_url&#x2F;get&#x2F;{    “User”:{      “id”:38710    }}


Moment和对应的User
分两次请求Moment:  base_url&#x2F;get&#x2F;moment?userId&#x3D;38710User:  base_url&#x2F;get&#x2F;user?id&#x3D;38710
base_url&#x2F;get&#x2F;{    “Moment”:{      “userId”:38710    },     “User”:{      “id”:38710    }}


User列表
base_url&#x2F;get&#x2F;user&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;sex&#x3D;0
base_url&#x2F;get&#x2F;{    “User[]”:{      “page”:0,       “count”:3,       “User”:{        “sex”:0      }    }}


Moment列表，每个Moment包括1.发布者User2.前3条Comment
Moment里必须有1.User对象2.Comment数组 base_url&#x2F;get&#x2F;moment&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;commentCount&#x3D;3
base_url&#x2F;get&#x2F;{    “[]”:{      “page”:0,       “count”:3,       “Moment”:{},       “User”:{        “id@”:”&#x2F;Moment&#x2F;userId”      },      “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }}


User发布的Moment列表， 每个Moment包括 1.发布者User 2.前3条Comment
1.Moment里必须有User对象和Comment数组 2.字段名必须查接口文档，例如评论数量字段名可能是 commentCount,comment_count或者简写cmt_count等各种奇葩写法…  base_url&#x2F;get&#x2F;moment&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;commentCount&#x3D;3&amp;userId&#x3D;38710
有以下几种方式: ① 把以上请求里的“Moment”:{}, “User”:{“id@”:”&#x2F;Moment&#x2F;userId”}改为“Moment”:{“userId”:38710}, “User”:{“id”:38710}  ② 或把User放在上面的最外层省去重复的Userbase_url&#x2F;get&#x2F;{    “User”:{      “id”:38710    },    “[]”:{      “page”:0,      “count”:3,       “Moment”:{        “userId”:38710      },       “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }} ③ 如果User之前已经获取到了，还可以不传User来节省请求和返回数据的流量并提升速度base_url&#x2F;get&#x2F;{    “[]”:{      “page”:0,      “count”:3,       “Moment”:{        “userId”:38710      },      “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }}


 
 
2.6 后端对应不同请求的返回结果


后端的返回结果
传统方式
APIJSON



User
{    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
{    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


Moment和对应的User
分别返回两次请求的结果，获取到Moment后取出userId作为User的id条件去查询User  Moment:  {    “data”:{      “id”:235,      “content”:”xxx”,      …    },    “code”:200,    “msg”:”success”}  User:  {    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
一次性返回，没有传统方式导致的 长时间等待结果、两次结果间关联、线程多次切换 等问题  {    “Moment”:{      “id”:235,      “content”:”xxx”,      …    },    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


User列表
{    “data”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}
{    “User[]”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}


Moment列表，每个Moment包括发布者User和前3条Comment
Moment里必须有1.User对象2.Comment数组  {    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          …        },        “Comment”:[          …        ]      },      {        “id”:301,        “content”:”xxx”,        …,        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}
1.高灵活，可任意组合2.低耦合，逻辑很清晰{    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          …        },        “Comment[]”:[          …        ]      },      {        “Moment”:{          “id”:301,          “content”:”xxx”,          …        },        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}


User发布的Moment列表，每个Moment包括发布者User和前3条Comment
1.大量重复User，浪费流量和服务器性能2.优化很繁琐，需要后端扩展接口、写好文档，前端&#x2F;前端再配合优化{    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:470,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:511,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:595,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      …    ],    “code”:200,    “msg”:”success”}
以上不同请求方式的结果: ① 常规请求  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ② 省去重复的User  {    “User”:{      “id”:38710,      “name”:”Tommy”,      …    },    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ③ 不查询已获取到的User  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”}


1.base_url指基地址，一般是顶级域名，其它分支url都是在base_url后扩展。如base_url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F; ，对应的GET分支url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F;get&#x2F; 。下同。2.请求中的key或value任意一个为null值时，这个 key:value键值对 被视为无效。下同。3.请求中的 &#x2F; 需要转义。JSONRequest.java已经用URLEncoder.encode转义，不需要再写；但如果是浏览器或Postman等直接输入url&#x2F;request，需要把request中的所有 &#x2F; 都改成 %252F 。下同。4.code，指返回结果中的状态码，200表示成功，其它都是错误码，值全部都是HTTP标准状态码。下同。5.msg，指返回结果中的状态信息，对成功结果或错误原因的详细说明。下同。6.code和msg总是在返回结果的同一层级成对出现。对所有请求的返回结果都会在最外层有一对总结式code和msg。下同。7.id等字段对应的值仅供说明，不一定是数据库里存在的，请求里用的是真实存在的值。下同。



3.设计规范3.1 操作方法


方法及说明
URL
Request
Response



GET:  普通获取数据， 可用浏览器调试
base_url&#x2F;get&#x2F;
{    TableName:{      …     }}  {…}内为限制条件 例如获取一个 id &#x3D; 235 的 Moment： {    “Moment”:{      “id”:235    }}  后端校验通过后自动解析为 SQL 并执行：SELECT * FROM Moment WHERE id&#x3D;235 LIMIT 1
{    TableName:{      …    },    “code”:200,    “msg”:”success”}例如{    “Moment”:{      “id”:235,      “userId”:38710,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “code”:200,    “msg”:”success” }


HEAD:  普通获取数量， 可用浏览器调试
base_url&#x2F;head&#x2F;
{    TableName:{      …    } }  {…}内为限制条件  例如获取一个 id &#x3D; 38710 的 User 所发布的 Moment 总数： {    “Moment”:{      “userId”:38710    }}  后端校验通过后自动解析为 SQL 并执行：SELECT count(*) FROM Moment WHERE userId&#x3D;38710 LIMIT 1
{    TableName:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,    “msg”:”success”}  例如{    “Moment”:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,     “msg”:”success”}


GETS:  安全&#x2F;私密获取数据， 用于获取钱包等对安全性要求高的数据
base_url&#x2F;gets&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Privacy”，其它同GET
同GET


HEADS:  安全&#x2F;私密获取数量， 用于获取银行卡数量等对安全性要求高的数据总数
base_url&#x2F;heads&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Verify”，其它同HEAD
同HEAD


POST:  新增数据
base_url&#x2F;post&#x2F;
单个：  {    TableName:{      …    },    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 38710 发布一个新 Comment：{    “Comment”:{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”     },    “tag”:”Comment”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(38710,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;)    批量：  {    TableName[]:[{        …      }, {        …      }      …    ],    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 82001 发布 2 个 Comment：{    “Comment[]”:[{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”      }, {      “momentId”:15,      “content”:”APIJSON is a JSON transmision protocol.”    }],    “tag”:”Comment:[]”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(82001,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;);INSERT INTO Comment(userId,momentId,content) VALUES(82001,15,&#39;APIJSON is a JSON transmision protocol.&#39;);
单个：  {    TableName:{      “code”:200,      “msg”:”success”,      “id”:38710    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “id”:120    },    “code”:200,    “msg”:”success”}   批量：  {    TableName:{      “code”:200,      “msg”:”success”,      “count”:5,      “id[]”:[1, 2, 3, 4, 5]    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “count”:2,      “id[]”:[1, 2]    },    “code”:200,    “msg”:”success”}


PUT:  修改数据， 只修改所传的字段
base_url&#x2F;put&#x2F;
{    TableName:{      “id”:id,      …    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个 例如当前登录用户 82001 修改 id &#x3D; 235 的 Moment 的 content：{    “Moment”:{      “id”:235,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “tag”:”Moment”}  后端校验通过后自动解析为 SQL 并执行：UPDATE Moment SET content&#x3D;&#39;APIJSON,let interfaces and documents go to hell !&#39; WHERE id&#x3D;235 AND userId&#x3D;82001 LIMIT 1  批量除了 id{}:[] 也可类似批量 POST，只是每个 {…} 里面都必须有 id。“tag”:”Comment[]” 对应对象 “Comment”:{“id{}”:[1,2,3]}，表示指定记录全部统一设置；“tag”:”Comment:[]” 多了冒号，对应数组 “Comment[]”:[{“id”:1},{“id”:2},{“id”:3}]，表示每项单独设置
同POST


DELETE:  删除数据
base_url&#x2F;delete&#x2F;
{    TableName:{      “id”:id    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个，一般只传 id 或 id{} 例如当前登录用户 82001 批量删除 id &#x3D; 100,110,120 的 Comment：{    “Comment”:{      “id{}”:[100,110,120]    },    “tag”:”Comment[]”}  后端校验通过后自动解析为 SQL 并执行：DELETE FROM Comment WHERE id IN(100,110,120) AND userId&#x3D;82001 LIMIT 3
{    TableName:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120]      “count”:3    },    “code”:200,    “msg”:”success”}例如{   “Comment”:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120],      “count”:3   },   “code”:200,   “msg”:”success”}


以上接口的简单形式:  base_url&#x2F;{method}&#x2F;{tag}
GET: 普通获取数据  base_url&#x2F;get&#x2F;{tag}  HEAD: 普通获取数量  base_url&#x2F;head&#x2F;{tag}  GETS: 安全&#x2F;私密获取数据   base_url&#x2F;gets&#x2F;{tag}  HEADS: 安全&#x2F;私密获取数量  base_url&#x2F;heads&#x2F;{tag}  POST: 新增数据   base_url&#x2F;post&#x2F;{tag}  PUT: 修改数据  base_url&#x2F;put&#x2F;{tag}  DELETE: 删除数据  base_url&#x2F;delete&#x2F;{tag}
例如安全&#x2F;私密获取一个 id &#x3D; 82001 的 Privacy： base_url&#x2F;gets&#x2F;Privacy&#x2F;  {“id”:82001}  相当于  base_url&#x2F;gets&#x2F; {“tag”:”Privacy”, “Privacy”:{“id”:82001}}   例如批量修改 id &#x3D; 114, 124 的 Comment 的 content：base_url&#x2F;put&#x2F;Comemnt[]&#x2F;  {    “id{}”:[114,124],    “content”:”test multi put”}  相当于  base_url&#x2F;put&#x2F;  {    “tag”:”Comment[]”,     “Comment”:{      “id{}”:[114,124],      “content”:”test multi put”    }}
同以上对应的方法


1.TableName指要查询的数据库表Table的名称字符串。第一个字符为大写字母，剩下的字符要符合英语字母、数字、下划线中的任何一种。对应的值的类型为JSONObject，结构是 {…}，里面放的是Table的字段(列名)。下同。2.”tag”:tag 后面的tag是非GET、HEAD请求中匹配请求的JSON结构的标识，一般是要查询的Table的名称，由后端Request表中指定。下同。3.GET、HEAD请求是开放请求，可任意组合任意嵌套。其它请求为受限制的安全&#x2F;私密请求，对应的 方法（method）, 标识（tag）, 版本（version）, 结构（structure） 都必须和 后端Request表中所指定的 一一对应，否则请求将不被通过。version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本。下同。4.GETS与GET、HEADS与HEAD分别为同一类型的操作方法，请求稍有不同但返回结果相同。下同。5.在HTTP通信中，自动化接口(get,gets,head,heads,post,put,delete) 全用HTTP POST请求。下同。6.所有JSONObject都视为容器(或者文件夹)，结构为 {…} ，里面可以放普通对象或子容器。下同。7.每个对象都有一个唯一的路径(或者叫地址)，假设对象名为refKey，则用 key0&#x2F;key1&#x2F;…&#x2F;refKey 表示。下同。


3.2 功能符


功能
键值对格式
使用示例



查询数组
“key[]”:{}，后面是JSONObject，key可省略。当key和里面的Table名相同时，Table会被提取出来，即 {Table:{Content}} 会被转化为 {Content}
{“User[]”:{“User”:{}}}，查询一个User数组。这里key和Table名都是User，User会被提取出来，即 {“User”:{“id”, …}} 会被转化为 {“id”, …}，如果要进一步提取User中的id，可以把User[]改为User-id[]


匹配选项范围
“key{}”:[]，后面是JSONArray，作为key可取的值的选项
“id{}”:[38710,82001,70793]，对应SQL是id IN(38710,82001,70793)，查询id符合38710,82001,70793中任意一个的一个User数组


匹配条件范围
“key{}”:”条件0,条件1…”，条件为SQL表达式字符串，可进行数字比较运算等
“id{}”:”&lt;&#x3D;80000,&gt;90000”，对应SQL是id&lt;&#x3D;80000 OR id&gt;90000，查询id符合id&lt;&#x3D;80000 | id&gt;90000的一个User数组


包含选项范围
“key&lt;&gt;“:Object  &#x3D;&gt;  “key&lt;&gt;“:[Object]，key对应值的类型必须为JSONArray，Object类型不能为JSON
“contactIdList&lt;&gt;“:38710，对应SQL是json_contains(contactIdList,38710)，查询contactIdList包含38710的一个User数组


判断是否存在
“key}{@”:{    “from”:”Table”,    “Table”:{ … }}其中：}{ 表示 EXISTS； key 用来标识是哪个判断； @ 后面是 子查询 对象，具体见下方 子查询 的说明。
“id}{@”:{    “from”:”Comment”,    “Comment”:{        “momentId”:15     }} WHERE EXISTS(SELECT * FROM Comment WHERE momentId&#x3D;15)


远程调用函数
“key()”:”函数表达式”，函数表达式为 function(key0,key1…)，会调用后端对应的函数 function(JSONObject request, String key0, String key1…)，实现 参数校验、数值计算、数据同步、消息推送、字段拼接、结构变换 等特定的业务逻辑处理，可使用 - 和 + 表示优先级，解析 key-() &gt; 解析当前对象 &gt; 解析 key() &gt; 解析子对象 &gt; 解析 key+()
“isPraised()”:”isContain(praiseUserIdList,userId)”，会调用远程函数 boolean isContain(JSONObject request, String array, String value) ，然后变为 “isPraised”:true 这种（假设点赞用户id列表包含了userId，即这个User点了赞）


存储过程
“@key()”:”SQL函数表达式”，函数表达式为   function(key0,key1…)  会调用后端数据库对应的存储过程 SQL函数  function(String key0, String key1…)  除了参数会提前赋值，其它和 远程函数 一致
“@limit”:10,  “@offset”:0,  “@procedure()”:”getCommentByUserId(id,@limit,@offset)”  会转为  getCommentByUserId(38710,10,0)  来调用存储过程 SQL 函数  getCommentByUserId(IN id bigint, IN limit int, IN offset int)  然后变为 “procedure”:{    “count”:-1,     “update”:false,     “list”:[]  }  其中 count 是指写操作影响记录行数，-1 表示不是写操作；update 是指是否为写操作（增删改）；list 为返回结果集


引用赋值
“key@”:”key0&#x2F;key1&#x2F;…&#x2F;refKey”，引用路径为用&#x2F;分隔的字符串。以&#x2F;开头的是缺省引用路径，从声明key所处容器的父容器路径开始；其它是完整引用路径，从最外层开始。 被引用的refKey必须在声明key的上面。如果对refKey的容器指定了返回字段，则被引用的refKey必须写在@column对应的值内，例如 “@column”:”refKey,key1,…”
“Moment”:{    “userId”:38710},“User”:{    “id@”:”&#x2F;Moment&#x2F;userId”} User内的id引用了与User同级的Moment内的userId，即User.id &#x3D; Moment.userId，请求完成后 “id@”:”&#x2F;Moment&#x2F;userId” 会变成 “id”:38710


子查询
“key@”:{    “range”:”ALL”,     “from”:”Table”,    “Table”:{ … }}其中：range 可为 ALL,ANY；from 为目标表 Table 的名称；@ 后面的对象类似数组对象，可使用 count 和 join 等功能。
“id@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&#x3D;(SELECT min(userId) FROM Comment)


模糊搜索
&quot;key$&quot;:&quot;SQL搜索表达式&quot;  &#x3D;&gt;  &quot;key$&quot;:[&quot;SQL搜索表达式&quot;]，任意SQL搜索表达式字符串，如 %key%(包含key), key%(以key开始), %k%e%y%(包含字母k,e,y) 等，%表示任意字符
“name$”:”%m%”，对应SQL是name LIKE &#39;%m%&#39;，查询name包含”m”的一个User数组


正则匹配
“key“:”正则表达式”  &#x3D;&gt;  “key“:[“正则表达式”]，任意正则表达式字符串，如 ^[0-9]+$ ，*~ 忽略大小写，可用于高级搜索
“name~”:”^[0-9]+$”，对应SQL是name REGEXP &#39;^[0-9]+$&#39;，查询name中字符全为数字的一个User数组


连续范围
“key%”:”start,end”  &#x3D;&gt;  “key%”:[“start,end”]，其中 start 和 end 都只能为 Boolean, Number, String 中的一种，如 “2017-01-01,2019-01-01” ，[“1,90000”, “82001,100000”] ，可用于连续范围内的筛选
“date%”:”2017-10-01,2018-10-01”，对应SQL是date BETWEEN &#39;2017-10-01&#39; AND &#39;2018-10-01&#39;，查询在2017-10-01和2018-10-01期间注册的用户的一个User数组


新建别名
“name:alias”，name映射为alias，用alias替代name。可用于 column,Table,SQL函数 等。只用于GET类型、HEAD类型的请求
“@column”:”toId:parentId”，对应SQL是toId AS parentId，将查询的字段toId变为parentId返回


增加 或 扩展
“key+”:Object，Object的类型由key指定，且类型为Number,String,JSONArray中的一种。如 82001,”apijson”,[“url0”,”url1”] 等。只用于PUT请求
“praiseUserIdList+”:[82001]，对应SQL是json_insert(praiseUserIdList,82001)，添加一个点赞用户id，即这个用户点了赞


减少 或 去除
“key-“:Object，与”key+”相反
“balance-“:100.00，对应SQL是balance &#x3D; balance - 100.00，余额减少100.00，即花费了100元


比较运算
&gt;, &lt;, &gt;&#x3D;, &lt;&#x3D; 比较运算符，用于 ① 提供 “id{}”:”&lt;&#x3D;90000” 这种条件范围的简化写法 ② 实现子查询相关比较运算不支持 “key&#x3D;”:Object 和 “key!&#x3D;”:Object 这两种写法，直接用更简单的 “key”:Object 和 “key!”:Object 替代。
① “id&lt;&#x3D;”:90000，对应SQL是id&lt;&#x3D;90000，查询符合id&lt;&#x3D;90000的一个User数组 ② “id&gt;@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&gt;(SELECT min(userId) FROM Comment)


逻辑运算
&amp;, |, ! 逻辑运算符，对应数据库 SQL 中的 AND, OR, NOT。 横或纵与：同一键值对的值内条件默认 | 或连接，可以在 key 后加逻辑运算符来具体指定；不同键值对的条件默认 &amp; 与连接，可以用下面说明的对象关键词 @combine 来具体指定。 ① &amp; 可用于”key&amp;{}”:”条件”等② | 可用于”key|{}”:”条件”, “key|{}”:[]等，一般可省略③ ! 可单独使用，如”key!”:Object，也可像&amp;,|一样配合其他功能符使用  “key!”:null 无效，null 值会导致整个键值对被忽略解析，可以用 “key{}”:”!&#x3D;null” 替代，“key”:null 同理，用 “key{}”:”&#x3D;null” 替代。
① “id&amp;{}”:”&gt;80000,&lt;&#x3D;90000”，对应SQL是id&gt;80000 AND id&lt;&#x3D;90000，即id满足id&gt;80000 &amp; id&lt;&#x3D;90000 ② “id|{}”:”&gt;90000,&lt;&#x3D;80000”，同”id{}”:”&gt;90000,&lt;&#x3D;80000”，对应SQL是id&gt;80000 OR id&lt;&#x3D;90000，即id满足id&gt;90000 | id&lt;&#x3D;80000 ③ “id!{}”:[82001,38710]，对应SQL是id NOT IN(82001,38710)，即id满足 ! (id&#x3D;82001 | id&#x3D;38710)，可过滤黑名单的消息


数组关键词，可自定义
“key”:Object，key为 “[]”:{} 中{}内的关键词，Object的类型由key指定① “count”:Integer，查询数量，0 表示最大值，默认最大值为100 ② “page”:Integer，查询页码，从0开始，默认最大值为100，一般和count一起用③ “query”:Integer，查询内容0-对象，1-总数和分页详情，2-数据、总数和分页详情总数关键词为 total，分页详情关键词为 info， 它们都和 query 同级，通过引用赋值得到，例如  “total@”:”&#x2F;[]&#x2F;total”, “info@”:”&#x2F;[]&#x2F;info” 这里query及total仅为GET类型的请求提供方便， 一般可直接用HEAD类型的请求获取总数④ “join”:”&amp;&#x2F;Table0,&lt;&#x2F;Table1&#x2F;key1@” 或 “join”:{    “&amp;&#x2F;Table0”:{},  &#x2F;&#x2F; 支持 ON 多个字段关联,    “&lt;&#x2F;Table1&#x2F;key1@”:{  &#x2F;&#x2F; ON 只允许指定的 key1 关联      “key0”:value0,  &#x2F;&#x2F; 其它ON条件       “key2”:value2,      …       “@combine”:”…”,  &#x2F;&#x2F; 其它ON条件的组合方式       “@column”:”…”,  &#x2F;&#x2F; 外层 SELECT       “@group”:”…”,  &#x2F;&#x2F; 外层 GROUP BY       “@having”:”…”  &#x2F;&#x2F; 外层 HAVING     }}多表连接方式：  “@” - APP JOIN  “&lt;“ - LEFT JOIN  “&gt;” - RIGHT JOIN  “&amp;” - INNER JOIN  “|” - FULL JOIN   “!” - OUTER JOIN   “*” - CROSS JOIN   “^” - SIDE JOIN   “(“ - ANTI JOIN   “)” - FOREIGN JOIN 其中 @ APP JOIN 为应用层连表，会从已查出的主表里取得所有副表 key@ 关联的主表内的 refKey 作为一个数组 refKeys: [value0, value1…]，然后把原来副表 count 次查询 key&#x3D;$refKey 的 SQL 用 key IN($refKeys) 的方式合并为一条 SQL 来优化性能； 其它 JOIN 都是 SQL JOIN，具体功能和 MySQL,PostgreSQL 等数据库的 JOIN 一一对应 &quot;join&quot;:&quot;&lt;&#x2F;ViceTable&#x2F;key@&quot;,&quot;MainTable&quot;:{},&quot;ViceTable&quot;:{&quot;key@&quot;:&quot;&#x2F;MainTable&#x2F;refKey&quot;}会对应生成 MainTable LEFT JOIN ViceTable ON ViceTable.key&#x3D;MainTable.refKey AND 其它ON条件  除了 &#x3D; 等价关联，也支持 ! 不等关联、&gt; &lt; &gt;&#x3D; &lt;&#x3D; 等比较关联和 $ ~ {} &lt;&gt; 等其它复杂关联方式 ⑤ “otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 查询User数组，最多5个：“count”:5对应SQL是LIMIT 5  ② 查询第3页的User数组，每页5个：“count”:5,“page”:3对应SQL是LIMIT 5 OFFSET 15  ③ 查询User数组和对应的User总数：“[]”:{    “query”:2,    “User”:{}},“total@”:”&#x2F;[]&#x2F;total”,“info@”:”&#x2F;[]&#x2F;info” 返回的数据中，总数及分页详情结构为：   “total”:139,  &#x2F;&#x2F;总数  “info”:{  &#x2F;&#x2F;分页详情     “total”:139,  &#x2F;&#x2F;总数     “count”:5,  &#x2F;&#x2F;每页数量     “page”:0,  &#x2F;&#x2F;当前页码     “max”:27,  &#x2F;&#x2F;最大页码     “more”:true,  &#x2F;&#x2F;是否还有更多     “first”:true,  &#x2F;&#x2F;是否为首页     “last”:false  &#x2F;&#x2F;是否为尾页 }  ④ Moment INNER JOIN User LEFT JOIN Comment：“[]”:{    “join”:”&amp;&#x2F;User&#x2F;id@,&lt;&#x2F;Comment”,    “Moment”:{     “@group”:”id”  &#x2F;&#x2F;主副表不是一对一，要去除重复数据   },    “User”:{      “name~”:”t”,      “id@”:”&#x2F;Moment&#x2F;userId”    },    “Comment”:{      “momentId@”:”&#x2F;Moment&#x2F;id”    }} ⑤ 每一层都加当前用户名：“User”:{},“[]”:{    “name@”:”User&#x2F;name”, &#x2F;&#x2F;自定义关键词    “Moment”:{}}


对象关键词，可自定义
“@key”:Object，@key为 Table:{} 中{}内的关键词，Object的类型由@key指定① “@combine”:”key0 | (key1 &amp; (key2 | !key3))…”，条件组合方式，最终按  (其它key条件 AND 连接) AND (key0条件 OR (key1条件 AND (key2条件 OR (NOT key3条件)))) 这种方式连接，其中 “其它key” 是指与 @combine 在同一对象，且未被它声明的条件 key，默认都是 &amp; 连接。注意不要缺少或多余任何一个空格。 ② “@column”:”column;function(arg)…”，返回字段③ “@order”:”column0+,column1-…”，排序方式④ “@group”:”column0,column1…”，分组方式。如果@column里声明了Table的id，则id也必须在@group中声明；其它情况下必须满足至少一个条件:1.分组的key在@column里声明2.Table主键在@group中声明 ⑤ “@having”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…” &#x2F;&#x2F; OR 连接，或 “@having&amp;”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…”  &#x2F;&#x2F; AND 连接，或 “@having”:{   “h0”:”function0(…)?value0”,   “h1”:function1(…)?value1”,   “h2”:function2(…)?value2…”,   “@combine”:”h0 &amp; (h1 | !h2)”  &#x2F;&#x2F; 任意组合，非必传}SQL函数条件，一般和@group一起用，函数一般在@column里声明⑥ “@schema”:”sys”，集合空间(数据库名&#x2F;模式)，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑦ “@database”:”POSTGRESQL”，数据库类型，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑧ “@datasource”:”DRUID”，跨数据源，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑨ “@json”:”key0,key1…”，转为 JSON 格式返回，符合 JSONObject 则转为 {…}，符合 JSONArray 则转为 […] ⑩ “@role”:”OWNER”，来访角色，包括UNKNOWN,LOGIN,CONTACT,CIRCLE,OWNER,ADMIN，可以在最外层作为全局默认配置，可自定义其它角色并重写 Verifier.verify 等相关方法来自定义校验 ⑪ “@explain”:true，性能分析，可以在最外层作为全局默认配置 ⑫ “@raw”:”key0,key1…”，其中 key0, key1 都对应有键值对 “key0”:”SQL片段或SQL片段的别名”,  “key1”:”SQL片段或SQL片段的别名”  自定义原始SQL片段，可扩展嵌套SQL函数等复杂语句，必须是后端已配置的，只有其它功能符都做不到才考虑，谨慎使用，注意防SQL注入⑬ “@otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 搜索name或tag任何一个字段包含字符a的User列表： “name“:”a”,“tag“:”a”,“@combine”:”name~ | tag~” 对应SQL是name REGEXP &#39;a&#39; OR tag REGEXP &#39;a&#39;  ② 只查询id,sex,name这几列并且请求结果也按照这个顺序：“@column”:”id,sex,name”对应SQL是SELECT id,sex,name  ③ 查询按 name降序、id默认顺序 排序的User数组：“@order”:”name-,id”对应SQL是ORDER BY name DESC,id  ④ 查询按userId分组的Moment数组：“@group”:”userId,id”对应SQL是GROUP BY userId,id  ⑤ 查询 按userId分组、id最大值&gt;&#x3D;100 的Moment数组：“@column”:”userId;max(id)”,“@group”:”userId”,“@having”:”max(id)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) ... GROUP BY userId HAVING max(id)&gt;&#x3D;100 还可以指定函数返回名：“@column”:”userId;max(id):maxId”,“@group”:”userId”,“@having”:”(maxId)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) AS maxId ... GROUP BY userId HAVING (maxId)&gt;&#x3D;100  ⑥ 查询 sys 内的 User 表：“@schema”:”sys”对应SQL是FROM sys.User  ⑦ 查询 PostgreSQL 数据库的 User 表：“@database”:”POSTGRESQL” ⑧ 使用 Druid 连接池查询 User 表：“@datasource”:”DRUID” ⑨ 将 VARCHAR 字符串字段 get 转为 JSONArray 返回：“@json”:”get” ⑩ 查询当前用户的动态：“@role”:”OWNER” ⑪ 开启性能分析：“@explain”:true对应SQL是EXPLAIN  ⑫ 统计最近一周偶数userId的数量“@column”:”date;left(date,10):day;sum(if(userId%2&#x3D;0,1,0))”,“@group”:”day”,“@having”:”to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7”,“@raw”:”@column,@having”对应SQL是SELECT date, left(date,10) AS day, sum(if(userId%2&#x3D;0,1,0)) ... GROUP BY day HAVING to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7  ⑬ 从pictureList获取第0张图片：“@position”:0, &#x2F;&#x2F;自定义关键词“firstPicture()”:”getFromArray(pictureList,@position)”


全局关键词
为最外层对象 {} 内的关键词。其中 @database，@schema, @datasource, @role, @explain 基本同对象关键词，见上方说明，区别是全局关键词会每个表对象中没有时自动放入，作为默认值。 ① “tag”:String，后面的 tag 是非 GET、HEAD 请求中匹配请求的 JSON 结构的标识，一般是要查询的 Table 的名称或该名称对应的数组 Table[] 或 Table:[]，由后端 Request 表中指定。 ② “version”:Integer，接口版本，version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本，由后端 Request 表中指定。③ “format”:Boolean，格式化返回 Response JSON 的 key，一般是将 TableName 转为 tableName, TableName[] 转为 tableNameList, Table:alias 转为 alias, TableName-key[] 转为 tableNameKeyList 等小驼峰格式。
①  查隐私信息：[{“tag”:”Privacy”,”Privacy”:{“id”:82001}}](http:&#x2F;&#x2F;apijson.cn&#x2F;api?url&#x3D;http%3A%2F%2Fapijson.cn%3A8080%2Fgets&amp;type&#x3D;JSON&amp;json&#x3D;


</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1"><span class="toc-number">1.2.</span> <span class="toc-text">1.示例获取用户请求：
{
  &quot;User&quot;:{
    &quot;id&quot;:38710
  }
}


点击这里测试
返回：
{
  &quot;User&quot;:{
    &quot;id&quot;:38710,
    &quot;sex&quot;:0,
    &quot;name&quot;:&quot;TommyLemon&quot;,
    &quot;tag&quot;:&quot;Android&amp;Java&quot;,
    &quot;head&quot;:&quot;http:&#x2F;&#x2F;static.oschina.net&#x2F;uploads&#x2F;user&#x2F;1218&#x2F;2437072_100.jpg?t&#x3D;1461076033000&quot;,
    &quot;date&quot;:1485948110000,
    &quot;pictureList&quot;:[
      &quot;http:&#x2F;&#x2F;static.oschina.net&#x2F;uploads&#x2F;user&#x2F;1218&#x2F;2437072_100.jpg?t&#x3D;1461076033000&quot;,
      &quot;http:&#x2F;&#x2F;common.cnblogs.com&#x2F;images&#x2F;icon_weibo_24.png&quot;
    ]
  },
  &quot;code&quot;:200,
  &quot;msg&quot;:&quot;success&quot;
}



  [GIF] APIJSON 各种单表对象查询：简单查询、统计、分组、排序、聚合、比较、筛选字段、字段别名 等
 
  



获取用户列表请求：
{
  &quot;[]&quot;:{
    &quot;count&quot;:3,             &#x2F;&#x2F;只要3个
    &quot;User&quot;:{
      &quot;@column&quot;:&quot;id,name&quot;  &#x2F;&#x2F;只要id,name这两个字段
    }
  }
}


点击这里测试
返回：
{
  &quot;[]&quot;:[
    {
      &quot;User&quot;:{
        &quot;id&quot;:38710,
        &quot;name&quot;:&quot;TommyLemon&quot;
      }
    },
    {
      &quot;User&quot;:{
        &quot;id&quot;:70793,
        &quot;name&quot;:&quot;Strong&quot;
      }
    },
    {
      &quot;User&quot;:{
        &quot;id&quot;:82001,
        &quot;name&quot;:&quot;Android&quot;
      }
    }
  ],
  &quot;code&quot;:200,
  &quot;msg&quot;:&quot;success&quot;
}



  [GIF] APIJSON 各种单表数组查询：简单查询、统计、分组、排序、聚合、分页、比较、搜索、正则、条件组合 等
 




获取动态及发布者用户请求：
{
  &quot;Moment&quot;:{
  },
  &quot;User&quot;:{
    &quot;id@&quot;:&quot;Moment&#x2F;userId&quot;  &#x2F;&#x2F;User.id &#x3D; Moment.userId
  }
}


点击这里测试
返回：
{
  &quot;Moment&quot;:{
    &quot;id&quot;:12,
    &quot;userId&quot;:70793,
    &quot;date&quot;:&quot;2017-02-08 16:06:11.0&quot;,
    &quot;content&quot;:&quot;1111534034&quot;
  },
  &quot;User&quot;:{
    &quot;id&quot;:70793,
    &quot;sex&quot;:0,
    &quot;name&quot;:&quot;Strong&quot;,
    &quot;tag&quot;:&quot;djdj&quot;,
    &quot;head&quot;:&quot;http:&#x2F;&#x2F;static.oschina.net&#x2F;uploads&#x2F;user&#x2F;585&#x2F;1170143_50.jpg?t&#x3D;1390226446000&quot;,
    &quot;contactIdList&quot;:[
      38710,
      82002
    ],
    &quot;date&quot;:&quot;2017-02-01 19:21:50.0&quot;
  },
  &quot;code&quot;:200,
  &quot;msg&quot;:&quot;success&quot;
}



获取类似微信朋友圈的动态列表请求：
{
  &quot;[]&quot;:{                             &#x2F;&#x2F;请求一个数组
    &quot;page&quot;:0,                        &#x2F;&#x2F;数组条件
    &quot;count&quot;:2,
    &quot;Moment&quot;:{                       &#x2F;&#x2F;请求一个名为Moment的对象
      &quot;content$&quot;:&quot;%a%&quot;               &#x2F;&#x2F;对象条件，搜索content中包含a的动态
    },
    &quot;User&quot;:{
      &quot;id@&quot;:&quot;&#x2F;Moment&#x2F;userId&quot;,        &#x2F;&#x2F;User.id &#x3D; Moment.userId  缺省引用赋值路径，从所处容器的父容器路径开始
      &quot;@column&quot;:&quot;id,name,head&quot;       &#x2F;&#x2F;指定返回字段
    },
    &quot;Comment[]&quot;:{                    &#x2F;&#x2F;请求一个名为Comment的数组，并去除Comment包装
      &quot;count&quot;:2,
      &quot;Comment&quot;:{
        &quot;momentId@&quot;:&quot;[]&#x2F;Moment&#x2F;id&quot;   &#x2F;&#x2F;Comment.momentId &#x3D; Moment.id  完整引用赋值路径
      }
    }
  }
}


点击这里测试
返回：
{
  &quot;[]&quot;:[
    {
      &quot;Moment&quot;:{
        &quot;id&quot;:15,
        &quot;userId&quot;:70793,
        &quot;date&quot;:1486541171000,
        &quot;content&quot;:&quot;APIJSON is a JSON Transmission Structure Protocol…&quot;,
        &quot;praiseUserIdList&quot;:[
          82055,
          82002,
          82001
        ],
        &quot;pictureList&quot;:[
          &quot;http:&#x2F;&#x2F;static.oschina.net&#x2F;uploads&#x2F;user&#x2F;1218&#x2F;2437072_100.jpg?t&#x3D;1461076033000&quot;,
          &quot;http:&#x2F;&#x2F;common.cnblogs.com&#x2F;images&#x2F;icon_weibo_24.png&quot;
        ]
      },
      &quot;User&quot;:{
        &quot;id&quot;:70793,
        &quot;name&quot;:&quot;Strong&quot;,
        &quot;head&quot;:&quot;http:&#x2F;&#x2F;static.oschina.net&#x2F;uploads&#x2F;user&#x2F;585&#x2F;1170143_50.jpg?t&#x3D;1390226446000&quot;
      },
      &quot;Comment[]&quot;:[
        {
          &quot;id&quot;:176,
          &quot;toId&quot;:166,
          &quot;userId&quot;:38710,
          &quot;momentId&quot;:15,
          &quot;date&quot;:1490444883000,
          &quot;content&quot;:&quot;thank you&quot;
        },
        {
          &quot;id&quot;:1490863469638,
          &quot;toId&quot;:0,
          &quot;userId&quot;:82002,
          &quot;momentId&quot;:15,
          &quot;date&quot;:1490863469000,
          &quot;content&quot;:&quot;Just do it&quot;
        }
      ]
    },
    {
      &quot;Moment&quot;:{
        &quot;id&quot;:58,
        &quot;userId&quot;:90814,
        &quot;date&quot;:1485947671000,
        &quot;content&quot;:&quot;This is a Content...-435&quot;,
        &quot;praiseUserIdList&quot;:[
          38710,
          82003,
          82005,
          93793,
          82006,
          82044,
          82001
        ],
        &quot;pictureList&quot;:[
          &quot;http:&#x2F;&#x2F;static.oschina.net&#x2F;uploads&#x2F;img&#x2F;201604&#x2F;22172507_aMmH.jpg&quot;
        ]
      },
      &quot;User&quot;:{
        &quot;id&quot;:90814,
        &quot;name&quot;:7,
        &quot;head&quot;:&quot;http:&#x2F;&#x2F;static.oschina.net&#x2F;uploads&#x2F;user&#x2F;51&#x2F;102723_50.jpg?t&#x3D;1449212504000&quot;
      },
      &quot;Comment[]&quot;:[
        {
          &quot;id&quot;:13,
          &quot;toId&quot;:0,
          &quot;userId&quot;:82005,
          &quot;momentId&quot;:58,
          &quot;date&quot;:1485948050000,
          &quot;content&quot;:&quot;This is a Content...-13&quot;
        },
        {
          &quot;id&quot;:77,
          &quot;toId&quot;:13,
          &quot;userId&quot;:93793,
          &quot;momentId&quot;:58,
          &quot;date&quot;:1485948050000,
          &quot;content&quot;:&quot;This is a Content...-77&quot;
        }
      ]
    }
  ],
  &quot;code&quot;:200,
  &quot;msg&quot;:&quot;success&quot;
}



  [GIF] APIJSON 各种多表关联查询：一对一、一对多、多对一、各种条件 等
 



  

  [GIF] APIJSON 各种 JOIN：&lt; LEFT JOIN, &amp; INNER JOIN 等
 



  

  [GIF] APIJSON 各种子查询：@from@ FROM, key@ &#x3D;, key&gt;@ &gt;, key{}@ IN, key}{@ EXISTS 等 
 



    

  [GIF] APIJSON 部分功能演示集合，由浅入深、由简单到复杂 
 




在线测试


 
2.对比传统RESTful方式2.1 开发流程


开发流程
传统方式
APIJSON



接口传输
等后端编辑接口，然后更新文档，前端再按照文档编辑请求和解析代码
前端按照自己的需求编辑请求和解析代码。没有接口，更不需要文档！前端再也不用和后端沟通接口或文档问题了！


兼容旧版
后端增加新接口，用v2表示第2版接口，然后更新文档
什么都不用做！


 
 
2.2 前端请求


前端请求
传统方式
APIJSON



要求
前端按照文档在对应URL后面拼接键值对
前端按照自己的需求在固定URL后拼接JSON


URL
不同的请求对应不同的URL，基本上有多少个不同的请求就得有多少个接口URL
相同的操作方法(增删改查)都用同一个URL，大部分请求都用7个通用接口URL的其中一个


键值对
key&#x3D;value
key:value


结构
同一个URL内table_name只能有一个  base_url&#x2F;get&#x2F;table_name?key0&#x3D;value0&amp;key1&#x3D;value1…
同一个URL后TableName可传任意数量个  base_url&#x2F;get&#x2F;{    TableName0:{      key0:value0,      key1:value1,      …    },    TableName1:{      …    }    … }


 
 
2.3 后端操作


后端操作
传统方式
APIJSON



解析和返回
取出键值对，把键值对作为条件用预设的的方式去查询数据库，最后封装JSON并返回给前端
把Parser#parse方法的返回值返回给前端就行


返回JSON结构的设定方式
由后端设定，前端不能修改
由前端设定，后端不能修改


 
 
2.4 前端解析


前端解析
传统方式
APIJSON



查看方式
查文档或问后端，或等请求成功后看日志
看请求就行，所求即所得，不用查、不用问、不用等。也可以等请求成功后看日志


解析方法
用JSON解析器来解析JSONObject
可以用JSONResponse解析JSONObject，或使用传统方式


 
 
2.5 前端对应不同需求的请求


前端的请求
传统方式
APIJSON



User
base_url&#x2F;get&#x2F;user?id&#x3D;38710
base_url&#x2F;get&#x2F;{    “User”:{      “id”:38710    }}


Moment和对应的User
分两次请求Moment:  base_url&#x2F;get&#x2F;moment?userId&#x3D;38710User:  base_url&#x2F;get&#x2F;user?id&#x3D;38710
base_url&#x2F;get&#x2F;{    “Moment”:{      “userId”:38710    },     “User”:{      “id”:38710    }}


User列表
base_url&#x2F;get&#x2F;user&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;sex&#x3D;0
base_url&#x2F;get&#x2F;{    “User[]”:{      “page”:0,       “count”:3,       “User”:{        “sex”:0      }    }}


Moment列表，每个Moment包括1.发布者User2.前3条Comment
Moment里必须有1.User对象2.Comment数组 base_url&#x2F;get&#x2F;moment&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;commentCount&#x3D;3
base_url&#x2F;get&#x2F;{    “[]”:{      “page”:0,       “count”:3,       “Moment”:{},       “User”:{        “id@”:”&#x2F;Moment&#x2F;userId”      },      “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }}


User发布的Moment列表， 每个Moment包括 1.发布者User 2.前3条Comment
1.Moment里必须有User对象和Comment数组 2.字段名必须查接口文档，例如评论数量字段名可能是 commentCount,comment_count或者简写cmt_count等各种奇葩写法…  base_url&#x2F;get&#x2F;moment&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;commentCount&#x3D;3&amp;userId&#x3D;38710
有以下几种方式: ① 把以上请求里的“Moment”:{}, “User”:{“id@”:”&#x2F;Moment&#x2F;userId”}改为“Moment”:{“userId”:38710}, “User”:{“id”:38710}  ② 或把User放在上面的最外层省去重复的Userbase_url&#x2F;get&#x2F;{    “User”:{      “id”:38710    },    “[]”:{      “page”:0,      “count”:3,       “Moment”:{        “userId”:38710      },       “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }} ③ 如果User之前已经获取到了，还可以不传User来节省请求和返回数据的流量并提升速度base_url&#x2F;get&#x2F;{    “[]”:{      “page”:0,      “count”:3,       “Moment”:{        “userId”:38710      },      “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }}


 
 
2.6 后端对应不同请求的返回结果


后端的返回结果
传统方式
APIJSON



User
{    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
{    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


Moment和对应的User
分别返回两次请求的结果，获取到Moment后取出userId作为User的id条件去查询User  Moment:  {    “data”:{      “id”:235,      “content”:”xxx”,      …    },    “code”:200,    “msg”:”success”}  User:  {    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
一次性返回，没有传统方式导致的 长时间等待结果、两次结果间关联、线程多次切换 等问题  {    “Moment”:{      “id”:235,      “content”:”xxx”,      …    },    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


User列表
{    “data”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}
{    “User[]”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}


Moment列表，每个Moment包括发布者User和前3条Comment
Moment里必须有1.User对象2.Comment数组  {    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          …        },        “Comment”:[          …        ]      },      {        “id”:301,        “content”:”xxx”,        …,        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}
1.高灵活，可任意组合2.低耦合，逻辑很清晰{    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          …        },        “Comment[]”:[          …        ]      },      {        “Moment”:{          “id”:301,          “content”:”xxx”,          …        },        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}


User发布的Moment列表，每个Moment包括发布者User和前3条Comment
1.大量重复User，浪费流量和服务器性能2.优化很繁琐，需要后端扩展接口、写好文档，前端&#x2F;前端再配合优化{    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:470,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:511,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:595,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      …    ],    “code”:200,    “msg”:”success”}
以上不同请求方式的结果: ① 常规请求  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ② 省去重复的User  {    “User”:{      “id”:38710,      “name”:”Tommy”,      …    },    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ③ 不查询已获取到的User  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”}


1.base_url指基地址，一般是顶级域名，其它分支url都是在base_url后扩展。如base_url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F; ，对应的GET分支url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F;get&#x2F; 。下同。2.请求中的key或value任意一个为null值时，这个 key:value键值对 被视为无效。下同。3.请求中的 &#x2F; 需要转义。JSONRequest.java已经用URLEncoder.encode转义，不需要再写；但如果是浏览器或Postman等直接输入url&#x2F;request，需要把request中的所有 &#x2F; 都改成 %252F 。下同。4.code，指返回结果中的状态码，200表示成功，其它都是错误码，值全部都是HTTP标准状态码。下同。5.msg，指返回结果中的状态信息，对成功结果或错误原因的详细说明。下同。6.code和msg总是在返回结果的同一层级成对出现。对所有请求的返回结果都会在最外层有一对总结式code和msg。下同。7.id等字段对应的值仅供说明，不一定是数据库里存在的，请求里用的是真实存在的值。下同。



3.设计规范3.1 操作方法


方法及说明
URL
Request
Response



GET:  普通获取数据， 可用浏览器调试
base_url&#x2F;get&#x2F;
{    TableName:{      …     }}  {…}内为限制条件 例如获取一个 id &#x3D; 235 的 Moment： {    “Moment”:{      “id”:235    }}  后端校验通过后自动解析为 SQL 并执行：SELECT * FROM Moment WHERE id&#x3D;235 LIMIT 1
{    TableName:{      …    },    “code”:200,    “msg”:”success”}例如{    “Moment”:{      “id”:235,      “userId”:38710,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “code”:200,    “msg”:”success” }


HEAD:  普通获取数量， 可用浏览器调试
base_url&#x2F;head&#x2F;
{    TableName:{      …    } }  {…}内为限制条件  例如获取一个 id &#x3D; 38710 的 User 所发布的 Moment 总数： {    “Moment”:{      “userId”:38710    }}  后端校验通过后自动解析为 SQL 并执行：SELECT count(*) FROM Moment WHERE userId&#x3D;38710 LIMIT 1
{    TableName:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,    “msg”:”success”}  例如{    “Moment”:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,     “msg”:”success”}


GETS:  安全&#x2F;私密获取数据， 用于获取钱包等对安全性要求高的数据
base_url&#x2F;gets&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Privacy”，其它同GET
同GET


HEADS:  安全&#x2F;私密获取数量， 用于获取银行卡数量等对安全性要求高的数据总数
base_url&#x2F;heads&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Verify”，其它同HEAD
同HEAD


POST:  新增数据
base_url&#x2F;post&#x2F;
单个：  {    TableName:{      …    },    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 38710 发布一个新 Comment：{    “Comment”:{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”     },    “tag”:”Comment”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(38710,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;)    批量：  {    TableName[]:[{        …      }, {        …      }      …    ],    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 82001 发布 2 个 Comment：{    “Comment[]”:[{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”      }, {      “momentId”:15,      “content”:”APIJSON is a JSON transmision protocol.”    }],    “tag”:”Comment:[]”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(82001,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;);INSERT INTO Comment(userId,momentId,content) VALUES(82001,15,&#39;APIJSON is a JSON transmision protocol.&#39;);
单个：  {    TableName:{      “code”:200,      “msg”:”success”,      “id”:38710    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “id”:120    },    “code”:200,    “msg”:”success”}   批量：  {    TableName:{      “code”:200,      “msg”:”success”,      “count”:5,      “id[]”:[1, 2, 3, 4, 5]    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “count”:2,      “id[]”:[1, 2]    },    “code”:200,    “msg”:”success”}


PUT:  修改数据， 只修改所传的字段
base_url&#x2F;put&#x2F;
{    TableName:{      “id”:id,      …    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个 例如当前登录用户 82001 修改 id &#x3D; 235 的 Moment 的 content：{    “Moment”:{      “id”:235,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “tag”:”Moment”}  后端校验通过后自动解析为 SQL 并执行：UPDATE Moment SET content&#x3D;&#39;APIJSON,let interfaces and documents go to hell !&#39; WHERE id&#x3D;235 AND userId&#x3D;82001 LIMIT 1  批量除了 id{}:[] 也可类似批量 POST，只是每个 {…} 里面都必须有 id。“tag”:”Comment[]” 对应对象 “Comment”:{“id{}”:[1,2,3]}，表示指定记录全部统一设置；“tag”:”Comment:[]” 多了冒号，对应数组 “Comment[]”:[{“id”:1},{“id”:2},{“id”:3}]，表示每项单独设置
同POST


DELETE:  删除数据
base_url&#x2F;delete&#x2F;
{    TableName:{      “id”:id    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个，一般只传 id 或 id{} 例如当前登录用户 82001 批量删除 id &#x3D; 100,110,120 的 Comment：{    “Comment”:{      “id{}”:[100,110,120]    },    “tag”:”Comment[]”}  后端校验通过后自动解析为 SQL 并执行：DELETE FROM Comment WHERE id IN(100,110,120) AND userId&#x3D;82001 LIMIT 3
{    TableName:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120]      “count”:3    },    “code”:200,    “msg”:”success”}例如{   “Comment”:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120],      “count”:3   },   “code”:200,   “msg”:”success”}


以上接口的简单形式:  base_url&#x2F;{method}&#x2F;{tag}
GET: 普通获取数据  base_url&#x2F;get&#x2F;{tag}  HEAD: 普通获取数量  base_url&#x2F;head&#x2F;{tag}  GETS: 安全&#x2F;私密获取数据   base_url&#x2F;gets&#x2F;{tag}  HEADS: 安全&#x2F;私密获取数量  base_url&#x2F;heads&#x2F;{tag}  POST: 新增数据   base_url&#x2F;post&#x2F;{tag}  PUT: 修改数据  base_url&#x2F;put&#x2F;{tag}  DELETE: 删除数据  base_url&#x2F;delete&#x2F;{tag}
例如安全&#x2F;私密获取一个 id &#x3D; 82001 的 Privacy： base_url&#x2F;gets&#x2F;Privacy&#x2F;  {“id”:82001}  相当于  base_url&#x2F;gets&#x2F; {“tag”:”Privacy”, “Privacy”:{“id”:82001}}   例如批量修改 id &#x3D; 114, 124 的 Comment 的 content：base_url&#x2F;put&#x2F;Comemnt[]&#x2F;  {    “id{}”:[114,124],    “content”:”test multi put”}  相当于  base_url&#x2F;put&#x2F;  {    “tag”:”Comment[]”,     “Comment”:{      “id{}”:[114,124],      “content”:”test multi put”    }}
同以上对应的方法


1.TableName指要查询的数据库表Table的名称字符串。第一个字符为大写字母，剩下的字符要符合英语字母、数字、下划线中的任何一种。对应的值的类型为JSONObject，结构是 {…}，里面放的是Table的字段(列名)。下同。2.”tag”:tag 后面的tag是非GET、HEAD请求中匹配请求的JSON结构的标识，一般是要查询的Table的名称，由后端Request表中指定。下同。3.GET、HEAD请求是开放请求，可任意组合任意嵌套。其它请求为受限制的安全&#x2F;私密请求，对应的 方法（method）, 标识（tag）, 版本（version）, 结构（structure） 都必须和 后端Request表中所指定的 一一对应，否则请求将不被通过。version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本。下同。4.GETS与GET、HEADS与HEAD分别为同一类型的操作方法，请求稍有不同但返回结果相同。下同。5.在HTTP通信中，自动化接口(get,gets,head,heads,post,put,delete) 全用HTTP POST请求。下同。6.所有JSONObject都视为容器(或者文件夹)，结构为 {…} ，里面可以放普通对象或子容器。下同。7.每个对象都有一个唯一的路径(或者叫地址)，假设对象名为refKey，则用 key0&#x2F;key1&#x2F;…&#x2F;refKey 表示。下同。


3.2 功能符


功能
键值对格式
使用示例



查询数组
“key[]”:{}，后面是JSONObject，key可省略。当key和里面的Table名相同时，Table会被提取出来，即 {Table:{Content}} 会被转化为 {Content}
{“User[]”:{“User”:{}}}，查询一个User数组。这里key和Table名都是User，User会被提取出来，即 {“User”:{“id”, …}} 会被转化为 {“id”, …}，如果要进一步提取User中的id，可以把User[]改为User-id[]


匹配选项范围
“key{}”:[]，后面是JSONArray，作为key可取的值的选项
“id{}”:[38710,82001,70793]，对应SQL是id IN(38710,82001,70793)，查询id符合38710,82001,70793中任意一个的一个User数组


匹配条件范围
“key{}”:”条件0,条件1…”，条件为SQL表达式字符串，可进行数字比较运算等
“id{}”:”&lt;&#x3D;80000,&gt;90000”，对应SQL是id&lt;&#x3D;80000 OR id&gt;90000，查询id符合id&lt;&#x3D;80000 | id&gt;90000的一个User数组


包含选项范围
“key&lt;&gt;“:Object  &#x3D;&gt;  “key&lt;&gt;“:[Object]，key对应值的类型必须为JSONArray，Object类型不能为JSON
“contactIdList&lt;&gt;“:38710，对应SQL是json_contains(contactIdList,38710)，查询contactIdList包含38710的一个User数组


判断是否存在
“key}{@”:{    “from”:”Table”,    “Table”:{ … }}其中：}{ 表示 EXISTS； key 用来标识是哪个判断； @ 后面是 子查询 对象，具体见下方 子查询 的说明。
“id}{@”:{    “from”:”Comment”,    “Comment”:{        “momentId”:15     }} WHERE EXISTS(SELECT * FROM Comment WHERE momentId&#x3D;15)


远程调用函数
“key()”:”函数表达式”，函数表达式为 function(key0,key1…)，会调用后端对应的函数 function(JSONObject request, String key0, String key1…)，实现 参数校验、数值计算、数据同步、消息推送、字段拼接、结构变换 等特定的业务逻辑处理，可使用 - 和 + 表示优先级，解析 key-() &gt; 解析当前对象 &gt; 解析 key() &gt; 解析子对象 &gt; 解析 key+()
“isPraised()”:”isContain(praiseUserIdList,userId)”，会调用远程函数 boolean isContain(JSONObject request, String array, String value) ，然后变为 “isPraised”:true 这种（假设点赞用户id列表包含了userId，即这个User点了赞）


存储过程
“@key()”:”SQL函数表达式”，函数表达式为   function(key0,key1…)  会调用后端数据库对应的存储过程 SQL函数  function(String key0, String key1…)  除了参数会提前赋值，其它和 远程函数 一致
“@limit”:10,  “@offset”:0,  “@procedure()”:”getCommentByUserId(id,@limit,@offset)”  会转为  getCommentByUserId(38710,10,0)  来调用存储过程 SQL 函数  getCommentByUserId(IN id bigint, IN limit int, IN offset int)  然后变为 “procedure”:{    “count”:-1,     “update”:false,     “list”:[]  }  其中 count 是指写操作影响记录行数，-1 表示不是写操作；update 是指是否为写操作（增删改）；list 为返回结果集


引用赋值
“key@”:”key0&#x2F;key1&#x2F;…&#x2F;refKey”，引用路径为用&#x2F;分隔的字符串。以&#x2F;开头的是缺省引用路径，从声明key所处容器的父容器路径开始；其它是完整引用路径，从最外层开始。 被引用的refKey必须在声明key的上面。如果对refKey的容器指定了返回字段，则被引用的refKey必须写在@column对应的值内，例如 “@column”:”refKey,key1,…”
“Moment”:{    “userId”:38710},“User”:{    “id@”:”&#x2F;Moment&#x2F;userId”} User内的id引用了与User同级的Moment内的userId，即User.id &#x3D; Moment.userId，请求完成后 “id@”:”&#x2F;Moment&#x2F;userId” 会变成 “id”:38710


子查询
“key@”:{    “range”:”ALL”,     “from”:”Table”,    “Table”:{ … }}其中：range 可为 ALL,ANY；from 为目标表 Table 的名称；@ 后面的对象类似数组对象，可使用 count 和 join 等功能。
“id@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&#x3D;(SELECT min(userId) FROM Comment)


模糊搜索
&quot;key$&quot;:&quot;SQL搜索表达式&quot;  &#x3D;&gt;  &quot;key$&quot;:[&quot;SQL搜索表达式&quot;]，任意SQL搜索表达式字符串，如 %key%(包含key), key%(以key开始), %k%e%y%(包含字母k,e,y) 等，%表示任意字符
“name$”:”%m%”，对应SQL是name LIKE &#39;%m%&#39;，查询name包含”m”的一个User数组


正则匹配
“key“:”正则表达式”  &#x3D;&gt;  “key“:[“正则表达式”]，任意正则表达式字符串，如 ^[0-9]+$ ，*~ 忽略大小写，可用于高级搜索
“name~”:”^[0-9]+$”，对应SQL是name REGEXP &#39;^[0-9]+$&#39;，查询name中字符全为数字的一个User数组


连续范围
“key%”:”start,end”  &#x3D;&gt;  “key%”:[“start,end”]，其中 start 和 end 都只能为 Boolean, Number, String 中的一种，如 “2017-01-01,2019-01-01” ，[“1,90000”, “82001,100000”] ，可用于连续范围内的筛选
“date%”:”2017-10-01,2018-10-01”，对应SQL是date BETWEEN &#39;2017-10-01&#39; AND &#39;2018-10-01&#39;，查询在2017-10-01和2018-10-01期间注册的用户的一个User数组


新建别名
“name:alias”，name映射为alias，用alias替代name。可用于 column,Table,SQL函数 等。只用于GET类型、HEAD类型的请求
“@column”:”toId:parentId”，对应SQL是toId AS parentId，将查询的字段toId变为parentId返回


增加 或 扩展
“key+”:Object，Object的类型由key指定，且类型为Number,String,JSONArray中的一种。如 82001,”apijson”,[“url0”,”url1”] 等。只用于PUT请求
“praiseUserIdList+”:[82001]，对应SQL是json_insert(praiseUserIdList,82001)，添加一个点赞用户id，即这个用户点了赞


减少 或 去除
“key-“:Object，与”key+”相反
“balance-“:100.00，对应SQL是balance &#x3D; balance - 100.00，余额减少100.00，即花费了100元


比较运算
&gt;, &lt;, &gt;&#x3D;, &lt;&#x3D; 比较运算符，用于 ① 提供 “id{}”:”&lt;&#x3D;90000” 这种条件范围的简化写法 ② 实现子查询相关比较运算不支持 “key&#x3D;”:Object 和 “key!&#x3D;”:Object 这两种写法，直接用更简单的 “key”:Object 和 “key!”:Object 替代。
① “id&lt;&#x3D;”:90000，对应SQL是id&lt;&#x3D;90000，查询符合id&lt;&#x3D;90000的一个User数组 ② “id&gt;@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&gt;(SELECT min(userId) FROM Comment)


逻辑运算
&amp;, |, ! 逻辑运算符，对应数据库 SQL 中的 AND, OR, NOT。 横或纵与：同一键值对的值内条件默认 | 或连接，可以在 key 后加逻辑运算符来具体指定；不同键值对的条件默认 &amp; 与连接，可以用下面说明的对象关键词 @combine 来具体指定。 ① &amp; 可用于”key&amp;{}”:”条件”等② | 可用于”key|{}”:”条件”, “key|{}”:[]等，一般可省略③ ! 可单独使用，如”key!”:Object，也可像&amp;,|一样配合其他功能符使用  “key!”:null 无效，null 值会导致整个键值对被忽略解析，可以用 “key{}”:”!&#x3D;null” 替代，“key”:null 同理，用 “key{}”:”&#x3D;null” 替代。
① “id&amp;{}”:”&gt;80000,&lt;&#x3D;90000”，对应SQL是id&gt;80000 AND id&lt;&#x3D;90000，即id满足id&gt;80000 &amp; id&lt;&#x3D;90000 ② “id|{}”:”&gt;90000,&lt;&#x3D;80000”，同”id{}”:”&gt;90000,&lt;&#x3D;80000”，对应SQL是id&gt;80000 OR id&lt;&#x3D;90000，即id满足id&gt;90000 | id&lt;&#x3D;80000 ③ “id!{}”:[82001,38710]，对应SQL是id NOT IN(82001,38710)，即id满足 ! (id&#x3D;82001 | id&#x3D;38710)，可过滤黑名单的消息


数组关键词，可自定义
“key”:Object，key为 “[]”:{} 中{}内的关键词，Object的类型由key指定① “count”:Integer，查询数量，0 表示最大值，默认最大值为100 ② “page”:Integer，查询页码，从0开始，默认最大值为100，一般和count一起用③ “query”:Integer，查询内容0-对象，1-总数和分页详情，2-数据、总数和分页详情总数关键词为 total，分页详情关键词为 info， 它们都和 query 同级，通过引用赋值得到，例如  “total@”:”&#x2F;[]&#x2F;total”, “info@”:”&#x2F;[]&#x2F;info” 这里query及total仅为GET类型的请求提供方便， 一般可直接用HEAD类型的请求获取总数④ “join”:”&amp;&#x2F;Table0,&lt;&#x2F;Table1&#x2F;key1@” 或 “join”:{    “&amp;&#x2F;Table0”:{},  &#x2F;&#x2F; 支持 ON 多个字段关联,    “&lt;&#x2F;Table1&#x2F;key1@”:{  &#x2F;&#x2F; ON 只允许指定的 key1 关联      “key0”:value0,  &#x2F;&#x2F; 其它ON条件       “key2”:value2,      …       “@combine”:”…”,  &#x2F;&#x2F; 其它ON条件的组合方式       “@column”:”…”,  &#x2F;&#x2F; 外层 SELECT       “@group”:”…”,  &#x2F;&#x2F; 外层 GROUP BY       “@having”:”…”  &#x2F;&#x2F; 外层 HAVING     }}多表连接方式：  “@” - APP JOIN  “&lt;“ - LEFT JOIN  “&gt;” - RIGHT JOIN  “&amp;” - INNER JOIN  “|” - FULL JOIN   “!” - OUTER JOIN   “*” - CROSS JOIN   “^” - SIDE JOIN   “(“ - ANTI JOIN   “)” - FOREIGN JOIN 其中 @ APP JOIN 为应用层连表，会从已查出的主表里取得所有副表 key@ 关联的主表内的 refKey 作为一个数组 refKeys: [value0, value1…]，然后把原来副表 count 次查询 key&#x3D;$refKey 的 SQL 用 key IN($refKeys) 的方式合并为一条 SQL 来优化性能； 其它 JOIN 都是 SQL JOIN，具体功能和 MySQL,PostgreSQL 等数据库的 JOIN 一一对应 &quot;join&quot;:&quot;&lt;&#x2F;ViceTable&#x2F;key@&quot;,&quot;MainTable&quot;:{},&quot;ViceTable&quot;:{&quot;key@&quot;:&quot;&#x2F;MainTable&#x2F;refKey&quot;}会对应生成 MainTable LEFT JOIN ViceTable ON ViceTable.key&#x3D;MainTable.refKey AND 其它ON条件  除了 &#x3D; 等价关联，也支持 ! 不等关联、&gt; &lt; &gt;&#x3D; &lt;&#x3D; 等比较关联和 $ ~ {} &lt;&gt; 等其它复杂关联方式 ⑤ “otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 查询User数组，最多5个：“count”:5对应SQL是LIMIT 5  ② 查询第3页的User数组，每页5个：“count”:5,“page”:3对应SQL是LIMIT 5 OFFSET 15  ③ 查询User数组和对应的User总数：“[]”:{    “query”:2,    “User”:{}},“total@”:”&#x2F;[]&#x2F;total”,“info@”:”&#x2F;[]&#x2F;info” 返回的数据中，总数及分页详情结构为：   “total”:139,  &#x2F;&#x2F;总数  “info”:{  &#x2F;&#x2F;分页详情     “total”:139,  &#x2F;&#x2F;总数     “count”:5,  &#x2F;&#x2F;每页数量     “page”:0,  &#x2F;&#x2F;当前页码     “max”:27,  &#x2F;&#x2F;最大页码     “more”:true,  &#x2F;&#x2F;是否还有更多     “first”:true,  &#x2F;&#x2F;是否为首页     “last”:false  &#x2F;&#x2F;是否为尾页 }  ④ Moment INNER JOIN User LEFT JOIN Comment：“[]”:{    “join”:”&amp;&#x2F;User&#x2F;id@,&lt;&#x2F;Comment”,    “Moment”:{     “@group”:”id”  &#x2F;&#x2F;主副表不是一对一，要去除重复数据   },    “User”:{      “name~”:”t”,      “id@”:”&#x2F;Moment&#x2F;userId”    },    “Comment”:{      “momentId@”:”&#x2F;Moment&#x2F;id”    }} ⑤ 每一层都加当前用户名：“User”:{},“[]”:{    “name@”:”User&#x2F;name”, &#x2F;&#x2F;自定义关键词    “Moment”:{}}


对象关键词，可自定义
“@key”:Object，@key为 Table:{} 中{}内的关键词，Object的类型由@key指定① “@combine”:”key0 | (key1 &amp; (key2 | !key3))…”，条件组合方式，最终按  (其它key条件 AND 连接) AND (key0条件 OR (key1条件 AND (key2条件 OR (NOT key3条件)))) 这种方式连接，其中 “其它key” 是指与 @combine 在同一对象，且未被它声明的条件 key，默认都是 &amp; 连接。注意不要缺少或多余任何一个空格。 ② “@column”:”column;function(arg)…”，返回字段③ “@order”:”column0+,column1-…”，排序方式④ “@group”:”column0,column1…”，分组方式。如果@column里声明了Table的id，则id也必须在@group中声明；其它情况下必须满足至少一个条件:1.分组的key在@column里声明2.Table主键在@group中声明 ⑤ “@having”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…” &#x2F;&#x2F; OR 连接，或 “@having&amp;”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…”  &#x2F;&#x2F; AND 连接，或 “@having”:{   “h0”:”function0(…)?value0”,   “h1”:function1(…)?value1”,   “h2”:function2(…)?value2…”,   “@combine”:”h0 &amp; (h1 | !h2)”  &#x2F;&#x2F; 任意组合，非必传}SQL函数条件，一般和@group一起用，函数一般在@column里声明⑥ “@schema”:”sys”，集合空间(数据库名&#x2F;模式)，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑦ “@database”:”POSTGRESQL”，数据库类型，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑧ “@datasource”:”DRUID”，跨数据源，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑨ “@json”:”key0,key1…”，转为 JSON 格式返回，符合 JSONObject 则转为 {…}，符合 JSONArray 则转为 […] ⑩ “@role”:”OWNER”，来访角色，包括UNKNOWN,LOGIN,CONTACT,CIRCLE,OWNER,ADMIN，可以在最外层作为全局默认配置，可自定义其它角色并重写 Verifier.verify 等相关方法来自定义校验 ⑪ “@explain”:true，性能分析，可以在最外层作为全局默认配置 ⑫ “@raw”:”key0,key1…”，其中 key0, key1 都对应有键值对 “key0”:”SQL片段或SQL片段的别名”,  “key1”:”SQL片段或SQL片段的别名”  自定义原始SQL片段，可扩展嵌套SQL函数等复杂语句，必须是后端已配置的，只有其它功能符都做不到才考虑，谨慎使用，注意防SQL注入⑬ “@otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 搜索name或tag任何一个字段包含字符a的User列表： “name“:”a”,“tag“:”a”,“@combine”:”name~ | tag~” 对应SQL是name REGEXP &#39;a&#39; OR tag REGEXP &#39;a&#39;  ② 只查询id,sex,name这几列并且请求结果也按照这个顺序：“@column”:”id,sex,name”对应SQL是SELECT id,sex,name  ③ 查询按 name降序、id默认顺序 排序的User数组：“@order”:”name-,id”对应SQL是ORDER BY name DESC,id  ④ 查询按userId分组的Moment数组：“@group”:”userId,id”对应SQL是GROUP BY userId,id  ⑤ 查询 按userId分组、id最大值&gt;&#x3D;100 的Moment数组：“@column”:”userId;max(id)”,“@group”:”userId”,“@having”:”max(id)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) ... GROUP BY userId HAVING max(id)&gt;&#x3D;100 还可以指定函数返回名：“@column”:”userId;max(id):maxId”,“@group”:”userId”,“@having”:”(maxId)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) AS maxId ... GROUP BY userId HAVING (maxId)&gt;&#x3D;100  ⑥ 查询 sys 内的 User 表：“@schema”:”sys”对应SQL是FROM sys.User  ⑦ 查询 PostgreSQL 数据库的 User 表：“@database”:”POSTGRESQL” ⑧ 使用 Druid 连接池查询 User 表：“@datasource”:”DRUID” ⑨ 将 VARCHAR 字符串字段 get 转为 JSONArray 返回：“@json”:”get” ⑩ 查询当前用户的动态：“@role”:”OWNER” ⑪ 开启性能分析：“@explain”:true对应SQL是EXPLAIN  ⑫ 统计最近一周偶数userId的数量“@column”:”date;left(date,10):day;sum(if(userId%2&#x3D;0,1,0))”,“@group”:”day”,“@having”:”to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7”,“@raw”:”@column,@having”对应SQL是SELECT date, left(date,10) AS day, sum(if(userId%2&#x3D;0,1,0)) ... GROUP BY day HAVING to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7  ⑬ 从pictureList获取第0张图片：“@position”:0, &#x2F;&#x2F;自定义关键词“firstPicture()”:”getFromArray(pictureList,@position)”


全局关键词
为最外层对象 {} 内的关键词。其中 @database，@schema, @datasource, @role, @explain 基本同对象关键词，见上方说明，区别是全局关键词会每个表对象中没有时自动放入，作为默认值。 ① “tag”:String，后面的 tag 是非 GET、HEAD 请求中匹配请求的 JSON 结构的标识，一般是要查询的 Table 的名称或该名称对应的数组 Table[] 或 Table:[]，由后端 Request 表中指定。 ② “version”:Integer，接口版本，version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本，由后端 Request 表中指定。③ “format”:Boolean，格式化返回 Response JSON 的 key，一般是将 TableName 转为 tableName, TableName[] 转为 tableNameList, Table:alias 转为 alias, TableName-key[] 转为 tableNameKeyList 等小驼峰格式。
①  查隐私信息：[{“tag”:”Privacy”,”Privacy”:{“id”:82001}}](http:&#x2F;&#x2F;apijson.cn&#x2F;api?url&#x3D;http%3A%2F%2Fapijson.cn%3A8080%2Fgets&amp;type&#x3D;JSON&amp;json&#x3D;


</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1"><span class="toc-number">1.3.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AF%B9%E6%AF%94%E4%BC%A0%E7%BB%9FRESTful%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">2.对比传统RESTful方式2.1 开发流程


开发流程
传统方式
APIJSON



接口传输
等后端编辑接口，然后更新文档，前端再按照文档编辑请求和解析代码
前端按照自己的需求编辑请求和解析代码。没有接口，更不需要文档！前端再也不用和后端沟通接口或文档问题了！


兼容旧版
后端增加新接口，用v2表示第2版接口，然后更新文档
什么都不用做！


 
 
2.2 前端请求


前端请求
传统方式
APIJSON



要求
前端按照文档在对应URL后面拼接键值对
前端按照自己的需求在固定URL后拼接JSON


URL
不同的请求对应不同的URL，基本上有多少个不同的请求就得有多少个接口URL
相同的操作方法(增删改查)都用同一个URL，大部分请求都用7个通用接口URL的其中一个


键值对
key&#x3D;value
key:value


结构
同一个URL内table_name只能有一个  base_url&#x2F;get&#x2F;table_name?key0&#x3D;value0&amp;key1&#x3D;value1…
同一个URL后TableName可传任意数量个  base_url&#x2F;get&#x2F;{    TableName0:{      key0:value0,      key1:value1,      …    },    TableName1:{      …    }    … }


 
 
2.3 后端操作


后端操作
传统方式
APIJSON



解析和返回
取出键值对，把键值对作为条件用预设的的方式去查询数据库，最后封装JSON并返回给前端
把Parser#parse方法的返回值返回给前端就行


返回JSON结构的设定方式
由后端设定，前端不能修改
由前端设定，后端不能修改


 
 
2.4 前端解析


前端解析
传统方式
APIJSON



查看方式
查文档或问后端，或等请求成功后看日志
看请求就行，所求即所得，不用查、不用问、不用等。也可以等请求成功后看日志


解析方法
用JSON解析器来解析JSONObject
可以用JSONResponse解析JSONObject，或使用传统方式


 
 
2.5 前端对应不同需求的请求


前端的请求
传统方式
APIJSON



User
base_url&#x2F;get&#x2F;user?id&#x3D;38710
base_url&#x2F;get&#x2F;{    “User”:{      “id”:38710    }}


Moment和对应的User
分两次请求Moment:  base_url&#x2F;get&#x2F;moment?userId&#x3D;38710User:  base_url&#x2F;get&#x2F;user?id&#x3D;38710
base_url&#x2F;get&#x2F;{    “Moment”:{      “userId”:38710    },     “User”:{      “id”:38710    }}


User列表
base_url&#x2F;get&#x2F;user&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;sex&#x3D;0
base_url&#x2F;get&#x2F;{    “User[]”:{      “page”:0,       “count”:3,       “User”:{        “sex”:0      }    }}


Moment列表，每个Moment包括1.发布者User2.前3条Comment
Moment里必须有1.User对象2.Comment数组 base_url&#x2F;get&#x2F;moment&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;commentCount&#x3D;3
base_url&#x2F;get&#x2F;{    “[]”:{      “page”:0,       “count”:3,       “Moment”:{},       “User”:{        “id@”:”&#x2F;Moment&#x2F;userId”      },      “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }}


User发布的Moment列表， 每个Moment包括 1.发布者User 2.前3条Comment
1.Moment里必须有User对象和Comment数组 2.字段名必须查接口文档，例如评论数量字段名可能是 commentCount,comment_count或者简写cmt_count等各种奇葩写法…  base_url&#x2F;get&#x2F;moment&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;commentCount&#x3D;3&amp;userId&#x3D;38710
有以下几种方式: ① 把以上请求里的“Moment”:{}, “User”:{“id@”:”&#x2F;Moment&#x2F;userId”}改为“Moment”:{“userId”:38710}, “User”:{“id”:38710}  ② 或把User放在上面的最外层省去重复的Userbase_url&#x2F;get&#x2F;{    “User”:{      “id”:38710    },    “[]”:{      “page”:0,      “count”:3,       “Moment”:{        “userId”:38710      },       “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }} ③ 如果User之前已经获取到了，还可以不传User来节省请求和返回数据的流量并提升速度base_url&#x2F;get&#x2F;{    “[]”:{      “page”:0,      “count”:3,       “Moment”:{        “userId”:38710      },      “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }}


 
 
2.6 后端对应不同请求的返回结果


后端的返回结果
传统方式
APIJSON



User
{    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
{    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


Moment和对应的User
分别返回两次请求的结果，获取到Moment后取出userId作为User的id条件去查询User  Moment:  {    “data”:{      “id”:235,      “content”:”xxx”,      …    },    “code”:200,    “msg”:”success”}  User:  {    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
一次性返回，没有传统方式导致的 长时间等待结果、两次结果间关联、线程多次切换 等问题  {    “Moment”:{      “id”:235,      “content”:”xxx”,      …    },    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


User列表
{    “data”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}
{    “User[]”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}


Moment列表，每个Moment包括发布者User和前3条Comment
Moment里必须有1.User对象2.Comment数组  {    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          …        },        “Comment”:[          …        ]      },      {        “id”:301,        “content”:”xxx”,        …,        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}
1.高灵活，可任意组合2.低耦合，逻辑很清晰{    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          …        },        “Comment[]”:[          …        ]      },      {        “Moment”:{          “id”:301,          “content”:”xxx”,          …        },        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}


User发布的Moment列表，每个Moment包括发布者User和前3条Comment
1.大量重复User，浪费流量和服务器性能2.优化很繁琐，需要后端扩展接口、写好文档，前端&#x2F;前端再配合优化{    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:470,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:511,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:595,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      …    ],    “code”:200,    “msg”:”success”}
以上不同请求方式的结果: ① 常规请求  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ② 省去重复的User  {    “User”:{      “id”:38710,      “name”:”Tommy”,      …    },    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ③ 不查询已获取到的User  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”}


1.base_url指基地址，一般是顶级域名，其它分支url都是在base_url后扩展。如base_url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F; ，对应的GET分支url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F;get&#x2F; 。下同。2.请求中的key或value任意一个为null值时，这个 key:value键值对 被视为无效。下同。3.请求中的 &#x2F; 需要转义。JSONRequest.java已经用URLEncoder.encode转义，不需要再写；但如果是浏览器或Postman等直接输入url&#x2F;request，需要把request中的所有 &#x2F; 都改成 %252F 。下同。4.code，指返回结果中的状态码，200表示成功，其它都是错误码，值全部都是HTTP标准状态码。下同。5.msg，指返回结果中的状态信息，对成功结果或错误原因的详细说明。下同。6.code和msg总是在返回结果的同一层级成对出现。对所有请求的返回结果都会在最外层有一对总结式code和msg。下同。7.id等字段对应的值仅供说明，不一定是数据库里存在的，请求里用的是真实存在的值。下同。



3.设计规范3.1 操作方法


方法及说明
URL
Request
Response



GET:  普通获取数据， 可用浏览器调试
base_url&#x2F;get&#x2F;
{    TableName:{      …     }}  {…}内为限制条件 例如获取一个 id &#x3D; 235 的 Moment： {    “Moment”:{      “id”:235    }}  后端校验通过后自动解析为 SQL 并执行：SELECT * FROM Moment WHERE id&#x3D;235 LIMIT 1
{    TableName:{      …    },    “code”:200,    “msg”:”success”}例如{    “Moment”:{      “id”:235,      “userId”:38710,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “code”:200,    “msg”:”success” }


HEAD:  普通获取数量， 可用浏览器调试
base_url&#x2F;head&#x2F;
{    TableName:{      …    } }  {…}内为限制条件  例如获取一个 id &#x3D; 38710 的 User 所发布的 Moment 总数： {    “Moment”:{      “userId”:38710    }}  后端校验通过后自动解析为 SQL 并执行：SELECT count(*) FROM Moment WHERE userId&#x3D;38710 LIMIT 1
{    TableName:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,    “msg”:”success”}  例如{    “Moment”:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,     “msg”:”success”}


GETS:  安全&#x2F;私密获取数据， 用于获取钱包等对安全性要求高的数据
base_url&#x2F;gets&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Privacy”，其它同GET
同GET


HEADS:  安全&#x2F;私密获取数量， 用于获取银行卡数量等对安全性要求高的数据总数
base_url&#x2F;heads&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Verify”，其它同HEAD
同HEAD


POST:  新增数据
base_url&#x2F;post&#x2F;
单个：  {    TableName:{      …    },    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 38710 发布一个新 Comment：{    “Comment”:{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”     },    “tag”:”Comment”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(38710,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;)    批量：  {    TableName[]:[{        …      }, {        …      }      …    ],    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 82001 发布 2 个 Comment：{    “Comment[]”:[{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”      }, {      “momentId”:15,      “content”:”APIJSON is a JSON transmision protocol.”    }],    “tag”:”Comment:[]”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(82001,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;);INSERT INTO Comment(userId,momentId,content) VALUES(82001,15,&#39;APIJSON is a JSON transmision protocol.&#39;);
单个：  {    TableName:{      “code”:200,      “msg”:”success”,      “id”:38710    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “id”:120    },    “code”:200,    “msg”:”success”}   批量：  {    TableName:{      “code”:200,      “msg”:”success”,      “count”:5,      “id[]”:[1, 2, 3, 4, 5]    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “count”:2,      “id[]”:[1, 2]    },    “code”:200,    “msg”:”success”}


PUT:  修改数据， 只修改所传的字段
base_url&#x2F;put&#x2F;
{    TableName:{      “id”:id,      …    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个 例如当前登录用户 82001 修改 id &#x3D; 235 的 Moment 的 content：{    “Moment”:{      “id”:235,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “tag”:”Moment”}  后端校验通过后自动解析为 SQL 并执行：UPDATE Moment SET content&#x3D;&#39;APIJSON,let interfaces and documents go to hell !&#39; WHERE id&#x3D;235 AND userId&#x3D;82001 LIMIT 1  批量除了 id{}:[] 也可类似批量 POST，只是每个 {…} 里面都必须有 id。“tag”:”Comment[]” 对应对象 “Comment”:{“id{}”:[1,2,3]}，表示指定记录全部统一设置；“tag”:”Comment:[]” 多了冒号，对应数组 “Comment[]”:[{“id”:1},{“id”:2},{“id”:3}]，表示每项单独设置
同POST


DELETE:  删除数据
base_url&#x2F;delete&#x2F;
{    TableName:{      “id”:id    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个，一般只传 id 或 id{} 例如当前登录用户 82001 批量删除 id &#x3D; 100,110,120 的 Comment：{    “Comment”:{      “id{}”:[100,110,120]    },    “tag”:”Comment[]”}  后端校验通过后自动解析为 SQL 并执行：DELETE FROM Comment WHERE id IN(100,110,120) AND userId&#x3D;82001 LIMIT 3
{    TableName:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120]      “count”:3    },    “code”:200,    “msg”:”success”}例如{   “Comment”:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120],      “count”:3   },   “code”:200,   “msg”:”success”}


以上接口的简单形式:  base_url&#x2F;{method}&#x2F;{tag}
GET: 普通获取数据  base_url&#x2F;get&#x2F;{tag}  HEAD: 普通获取数量  base_url&#x2F;head&#x2F;{tag}  GETS: 安全&#x2F;私密获取数据   base_url&#x2F;gets&#x2F;{tag}  HEADS: 安全&#x2F;私密获取数量  base_url&#x2F;heads&#x2F;{tag}  POST: 新增数据   base_url&#x2F;post&#x2F;{tag}  PUT: 修改数据  base_url&#x2F;put&#x2F;{tag}  DELETE: 删除数据  base_url&#x2F;delete&#x2F;{tag}
例如安全&#x2F;私密获取一个 id &#x3D; 82001 的 Privacy： base_url&#x2F;gets&#x2F;Privacy&#x2F;  {“id”:82001}  相当于  base_url&#x2F;gets&#x2F; {“tag”:”Privacy”, “Privacy”:{“id”:82001}}   例如批量修改 id &#x3D; 114, 124 的 Comment 的 content：base_url&#x2F;put&#x2F;Comemnt[]&#x2F;  {    “id{}”:[114,124],    “content”:”test multi put”}  相当于  base_url&#x2F;put&#x2F;  {    “tag”:”Comment[]”,     “Comment”:{      “id{}”:[114,124],      “content”:”test multi put”    }}
同以上对应的方法


1.TableName指要查询的数据库表Table的名称字符串。第一个字符为大写字母，剩下的字符要符合英语字母、数字、下划线中的任何一种。对应的值的类型为JSONObject，结构是 {…}，里面放的是Table的字段(列名)。下同。2.”tag”:tag 后面的tag是非GET、HEAD请求中匹配请求的JSON结构的标识，一般是要查询的Table的名称，由后端Request表中指定。下同。3.GET、HEAD请求是开放请求，可任意组合任意嵌套。其它请求为受限制的安全&#x2F;私密请求，对应的 方法（method）, 标识（tag）, 版本（version）, 结构（structure） 都必须和 后端Request表中所指定的 一一对应，否则请求将不被通过。version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本。下同。4.GETS与GET、HEADS与HEAD分别为同一类型的操作方法，请求稍有不同但返回结果相同。下同。5.在HTTP通信中，自动化接口(get,gets,head,heads,post,put,delete) 全用HTTP POST请求。下同。6.所有JSONObject都视为容器(或者文件夹)，结构为 {…} ，里面可以放普通对象或子容器。下同。7.每个对象都有一个唯一的路径(或者叫地址)，假设对象名为refKey，则用 key0&#x2F;key1&#x2F;…&#x2F;refKey 表示。下同。


3.2 功能符


功能
键值对格式
使用示例



查询数组
“key[]”:{}，后面是JSONObject，key可省略。当key和里面的Table名相同时，Table会被提取出来，即 {Table:{Content}} 会被转化为 {Content}
{“User[]”:{“User”:{}}}，查询一个User数组。这里key和Table名都是User，User会被提取出来，即 {“User”:{“id”, …}} 会被转化为 {“id”, …}，如果要进一步提取User中的id，可以把User[]改为User-id[]


匹配选项范围
“key{}”:[]，后面是JSONArray，作为key可取的值的选项
“id{}”:[38710,82001,70793]，对应SQL是id IN(38710,82001,70793)，查询id符合38710,82001,70793中任意一个的一个User数组


匹配条件范围
“key{}”:”条件0,条件1…”，条件为SQL表达式字符串，可进行数字比较运算等
“id{}”:”&lt;&#x3D;80000,&gt;90000”，对应SQL是id&lt;&#x3D;80000 OR id&gt;90000，查询id符合id&lt;&#x3D;80000 | id&gt;90000的一个User数组


包含选项范围
“key&lt;&gt;“:Object  &#x3D;&gt;  “key&lt;&gt;“:[Object]，key对应值的类型必须为JSONArray，Object类型不能为JSON
“contactIdList&lt;&gt;“:38710，对应SQL是json_contains(contactIdList,38710)，查询contactIdList包含38710的一个User数组


判断是否存在
“key}{@”:{    “from”:”Table”,    “Table”:{ … }}其中：}{ 表示 EXISTS； key 用来标识是哪个判断； @ 后面是 子查询 对象，具体见下方 子查询 的说明。
“id}{@”:{    “from”:”Comment”,    “Comment”:{        “momentId”:15     }} WHERE EXISTS(SELECT * FROM Comment WHERE momentId&#x3D;15)


远程调用函数
“key()”:”函数表达式”，函数表达式为 function(key0,key1…)，会调用后端对应的函数 function(JSONObject request, String key0, String key1…)，实现 参数校验、数值计算、数据同步、消息推送、字段拼接、结构变换 等特定的业务逻辑处理，可使用 - 和 + 表示优先级，解析 key-() &gt; 解析当前对象 &gt; 解析 key() &gt; 解析子对象 &gt; 解析 key+()
“isPraised()”:”isContain(praiseUserIdList,userId)”，会调用远程函数 boolean isContain(JSONObject request, String array, String value) ，然后变为 “isPraised”:true 这种（假设点赞用户id列表包含了userId，即这个User点了赞）


存储过程
“@key()”:”SQL函数表达式”，函数表达式为   function(key0,key1…)  会调用后端数据库对应的存储过程 SQL函数  function(String key0, String key1…)  除了参数会提前赋值，其它和 远程函数 一致
“@limit”:10,  “@offset”:0,  “@procedure()”:”getCommentByUserId(id,@limit,@offset)”  会转为  getCommentByUserId(38710,10,0)  来调用存储过程 SQL 函数  getCommentByUserId(IN id bigint, IN limit int, IN offset int)  然后变为 “procedure”:{    “count”:-1,     “update”:false,     “list”:[]  }  其中 count 是指写操作影响记录行数，-1 表示不是写操作；update 是指是否为写操作（增删改）；list 为返回结果集


引用赋值
“key@”:”key0&#x2F;key1&#x2F;…&#x2F;refKey”，引用路径为用&#x2F;分隔的字符串。以&#x2F;开头的是缺省引用路径，从声明key所处容器的父容器路径开始；其它是完整引用路径，从最外层开始。 被引用的refKey必须在声明key的上面。如果对refKey的容器指定了返回字段，则被引用的refKey必须写在@column对应的值内，例如 “@column”:”refKey,key1,…”
“Moment”:{    “userId”:38710},“User”:{    “id@”:”&#x2F;Moment&#x2F;userId”} User内的id引用了与User同级的Moment内的userId，即User.id &#x3D; Moment.userId，请求完成后 “id@”:”&#x2F;Moment&#x2F;userId” 会变成 “id”:38710


子查询
“key@”:{    “range”:”ALL”,     “from”:”Table”,    “Table”:{ … }}其中：range 可为 ALL,ANY；from 为目标表 Table 的名称；@ 后面的对象类似数组对象，可使用 count 和 join 等功能。
“id@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&#x3D;(SELECT min(userId) FROM Comment)


模糊搜索
&quot;key$&quot;:&quot;SQL搜索表达式&quot;  &#x3D;&gt;  &quot;key$&quot;:[&quot;SQL搜索表达式&quot;]，任意SQL搜索表达式字符串，如 %key%(包含key), key%(以key开始), %k%e%y%(包含字母k,e,y) 等，%表示任意字符
“name$”:”%m%”，对应SQL是name LIKE &#39;%m%&#39;，查询name包含”m”的一个User数组


正则匹配
“key“:”正则表达式”  &#x3D;&gt;  “key“:[“正则表达式”]，任意正则表达式字符串，如 ^[0-9]+$ ，*~ 忽略大小写，可用于高级搜索
“name~”:”^[0-9]+$”，对应SQL是name REGEXP &#39;^[0-9]+$&#39;，查询name中字符全为数字的一个User数组


连续范围
“key%”:”start,end”  &#x3D;&gt;  “key%”:[“start,end”]，其中 start 和 end 都只能为 Boolean, Number, String 中的一种，如 “2017-01-01,2019-01-01” ，[“1,90000”, “82001,100000”] ，可用于连续范围内的筛选
“date%”:”2017-10-01,2018-10-01”，对应SQL是date BETWEEN &#39;2017-10-01&#39; AND &#39;2018-10-01&#39;，查询在2017-10-01和2018-10-01期间注册的用户的一个User数组


新建别名
“name:alias”，name映射为alias，用alias替代name。可用于 column,Table,SQL函数 等。只用于GET类型、HEAD类型的请求
“@column”:”toId:parentId”，对应SQL是toId AS parentId，将查询的字段toId变为parentId返回


增加 或 扩展
“key+”:Object，Object的类型由key指定，且类型为Number,String,JSONArray中的一种。如 82001,”apijson”,[“url0”,”url1”] 等。只用于PUT请求
“praiseUserIdList+”:[82001]，对应SQL是json_insert(praiseUserIdList,82001)，添加一个点赞用户id，即这个用户点了赞


减少 或 去除
“key-“:Object，与”key+”相反
“balance-“:100.00，对应SQL是balance &#x3D; balance - 100.00，余额减少100.00，即花费了100元


比较运算
&gt;, &lt;, &gt;&#x3D;, &lt;&#x3D; 比较运算符，用于 ① 提供 “id{}”:”&lt;&#x3D;90000” 这种条件范围的简化写法 ② 实现子查询相关比较运算不支持 “key&#x3D;”:Object 和 “key!&#x3D;”:Object 这两种写法，直接用更简单的 “key”:Object 和 “key!”:Object 替代。
① “id&lt;&#x3D;”:90000，对应SQL是id&lt;&#x3D;90000，查询符合id&lt;&#x3D;90000的一个User数组 ② “id&gt;@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&gt;(SELECT min(userId) FROM Comment)


逻辑运算
&amp;, |, ! 逻辑运算符，对应数据库 SQL 中的 AND, OR, NOT。 横或纵与：同一键值对的值内条件默认 | 或连接，可以在 key 后加逻辑运算符来具体指定；不同键值对的条件默认 &amp; 与连接，可以用下面说明的对象关键词 @combine 来具体指定。 ① &amp; 可用于”key&amp;{}”:”条件”等② | 可用于”key|{}”:”条件”, “key|{}”:[]等，一般可省略③ ! 可单独使用，如”key!”:Object，也可像&amp;,|一样配合其他功能符使用  “key!”:null 无效，null 值会导致整个键值对被忽略解析，可以用 “key{}”:”!&#x3D;null” 替代，“key”:null 同理，用 “key{}”:”&#x3D;null” 替代。
① “id&amp;{}”:”&gt;80000,&lt;&#x3D;90000”，对应SQL是id&gt;80000 AND id&lt;&#x3D;90000，即id满足id&gt;80000 &amp; id&lt;&#x3D;90000 ② “id|{}”:”&gt;90000,&lt;&#x3D;80000”，同”id{}”:”&gt;90000,&lt;&#x3D;80000”，对应SQL是id&gt;80000 OR id&lt;&#x3D;90000，即id满足id&gt;90000 | id&lt;&#x3D;80000 ③ “id!{}”:[82001,38710]，对应SQL是id NOT IN(82001,38710)，即id满足 ! (id&#x3D;82001 | id&#x3D;38710)，可过滤黑名单的消息


数组关键词，可自定义
“key”:Object，key为 “[]”:{} 中{}内的关键词，Object的类型由key指定① “count”:Integer，查询数量，0 表示最大值，默认最大值为100 ② “page”:Integer，查询页码，从0开始，默认最大值为100，一般和count一起用③ “query”:Integer，查询内容0-对象，1-总数和分页详情，2-数据、总数和分页详情总数关键词为 total，分页详情关键词为 info， 它们都和 query 同级，通过引用赋值得到，例如  “total@”:”&#x2F;[]&#x2F;total”, “info@”:”&#x2F;[]&#x2F;info” 这里query及total仅为GET类型的请求提供方便， 一般可直接用HEAD类型的请求获取总数④ “join”:”&amp;&#x2F;Table0,&lt;&#x2F;Table1&#x2F;key1@” 或 “join”:{    “&amp;&#x2F;Table0”:{},  &#x2F;&#x2F; 支持 ON 多个字段关联,    “&lt;&#x2F;Table1&#x2F;key1@”:{  &#x2F;&#x2F; ON 只允许指定的 key1 关联      “key0”:value0,  &#x2F;&#x2F; 其它ON条件       “key2”:value2,      …       “@combine”:”…”,  &#x2F;&#x2F; 其它ON条件的组合方式       “@column”:”…”,  &#x2F;&#x2F; 外层 SELECT       “@group”:”…”,  &#x2F;&#x2F; 外层 GROUP BY       “@having”:”…”  &#x2F;&#x2F; 外层 HAVING     }}多表连接方式：  “@” - APP JOIN  “&lt;“ - LEFT JOIN  “&gt;” - RIGHT JOIN  “&amp;” - INNER JOIN  “|” - FULL JOIN   “!” - OUTER JOIN   “*” - CROSS JOIN   “^” - SIDE JOIN   “(“ - ANTI JOIN   “)” - FOREIGN JOIN 其中 @ APP JOIN 为应用层连表，会从已查出的主表里取得所有副表 key@ 关联的主表内的 refKey 作为一个数组 refKeys: [value0, value1…]，然后把原来副表 count 次查询 key&#x3D;$refKey 的 SQL 用 key IN($refKeys) 的方式合并为一条 SQL 来优化性能； 其它 JOIN 都是 SQL JOIN，具体功能和 MySQL,PostgreSQL 等数据库的 JOIN 一一对应 &quot;join&quot;:&quot;&lt;&#x2F;ViceTable&#x2F;key@&quot;,&quot;MainTable&quot;:{},&quot;ViceTable&quot;:{&quot;key@&quot;:&quot;&#x2F;MainTable&#x2F;refKey&quot;}会对应生成 MainTable LEFT JOIN ViceTable ON ViceTable.key&#x3D;MainTable.refKey AND 其它ON条件  除了 &#x3D; 等价关联，也支持 ! 不等关联、&gt; &lt; &gt;&#x3D; &lt;&#x3D; 等比较关联和 $ ~ {} &lt;&gt; 等其它复杂关联方式 ⑤ “otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 查询User数组，最多5个：“count”:5对应SQL是LIMIT 5  ② 查询第3页的User数组，每页5个：“count”:5,“page”:3对应SQL是LIMIT 5 OFFSET 15  ③ 查询User数组和对应的User总数：“[]”:{    “query”:2,    “User”:{}},“total@”:”&#x2F;[]&#x2F;total”,“info@”:”&#x2F;[]&#x2F;info” 返回的数据中，总数及分页详情结构为：   “total”:139,  &#x2F;&#x2F;总数  “info”:{  &#x2F;&#x2F;分页详情     “total”:139,  &#x2F;&#x2F;总数     “count”:5,  &#x2F;&#x2F;每页数量     “page”:0,  &#x2F;&#x2F;当前页码     “max”:27,  &#x2F;&#x2F;最大页码     “more”:true,  &#x2F;&#x2F;是否还有更多     “first”:true,  &#x2F;&#x2F;是否为首页     “last”:false  &#x2F;&#x2F;是否为尾页 }  ④ Moment INNER JOIN User LEFT JOIN Comment：“[]”:{    “join”:”&amp;&#x2F;User&#x2F;id@,&lt;&#x2F;Comment”,    “Moment”:{     “@group”:”id”  &#x2F;&#x2F;主副表不是一对一，要去除重复数据   },    “User”:{      “name~”:”t”,      “id@”:”&#x2F;Moment&#x2F;userId”    },    “Comment”:{      “momentId@”:”&#x2F;Moment&#x2F;id”    }} ⑤ 每一层都加当前用户名：“User”:{},“[]”:{    “name@”:”User&#x2F;name”, &#x2F;&#x2F;自定义关键词    “Moment”:{}}


对象关键词，可自定义
“@key”:Object，@key为 Table:{} 中{}内的关键词，Object的类型由@key指定① “@combine”:”key0 | (key1 &amp; (key2 | !key3))…”，条件组合方式，最终按  (其它key条件 AND 连接) AND (key0条件 OR (key1条件 AND (key2条件 OR (NOT key3条件)))) 这种方式连接，其中 “其它key” 是指与 @combine 在同一对象，且未被它声明的条件 key，默认都是 &amp; 连接。注意不要缺少或多余任何一个空格。 ② “@column”:”column;function(arg)…”，返回字段③ “@order”:”column0+,column1-…”，排序方式④ “@group”:”column0,column1…”，分组方式。如果@column里声明了Table的id，则id也必须在@group中声明；其它情况下必须满足至少一个条件:1.分组的key在@column里声明2.Table主键在@group中声明 ⑤ “@having”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…” &#x2F;&#x2F; OR 连接，或 “@having&amp;”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…”  &#x2F;&#x2F; AND 连接，或 “@having”:{   “h0”:”function0(…)?value0”,   “h1”:function1(…)?value1”,   “h2”:function2(…)?value2…”,   “@combine”:”h0 &amp; (h1 | !h2)”  &#x2F;&#x2F; 任意组合，非必传}SQL函数条件，一般和@group一起用，函数一般在@column里声明⑥ “@schema”:”sys”，集合空间(数据库名&#x2F;模式)，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑦ “@database”:”POSTGRESQL”，数据库类型，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑧ “@datasource”:”DRUID”，跨数据源，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑨ “@json”:”key0,key1…”，转为 JSON 格式返回，符合 JSONObject 则转为 {…}，符合 JSONArray 则转为 […] ⑩ “@role”:”OWNER”，来访角色，包括UNKNOWN,LOGIN,CONTACT,CIRCLE,OWNER,ADMIN，可以在最外层作为全局默认配置，可自定义其它角色并重写 Verifier.verify 等相关方法来自定义校验 ⑪ “@explain”:true，性能分析，可以在最外层作为全局默认配置 ⑫ “@raw”:”key0,key1…”，其中 key0, key1 都对应有键值对 “key0”:”SQL片段或SQL片段的别名”,  “key1”:”SQL片段或SQL片段的别名”  自定义原始SQL片段，可扩展嵌套SQL函数等复杂语句，必须是后端已配置的，只有其它功能符都做不到才考虑，谨慎使用，注意防SQL注入⑬ “@otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 搜索name或tag任何一个字段包含字符a的User列表： “name“:”a”,“tag“:”a”,“@combine”:”name~ | tag~” 对应SQL是name REGEXP &#39;a&#39; OR tag REGEXP &#39;a&#39;  ② 只查询id,sex,name这几列并且请求结果也按照这个顺序：“@column”:”id,sex,name”对应SQL是SELECT id,sex,name  ③ 查询按 name降序、id默认顺序 排序的User数组：“@order”:”name-,id”对应SQL是ORDER BY name DESC,id  ④ 查询按userId分组的Moment数组：“@group”:”userId,id”对应SQL是GROUP BY userId,id  ⑤ 查询 按userId分组、id最大值&gt;&#x3D;100 的Moment数组：“@column”:”userId;max(id)”,“@group”:”userId”,“@having”:”max(id)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) ... GROUP BY userId HAVING max(id)&gt;&#x3D;100 还可以指定函数返回名：“@column”:”userId;max(id):maxId”,“@group”:”userId”,“@having”:”(maxId)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) AS maxId ... GROUP BY userId HAVING (maxId)&gt;&#x3D;100  ⑥ 查询 sys 内的 User 表：“@schema”:”sys”对应SQL是FROM sys.User  ⑦ 查询 PostgreSQL 数据库的 User 表：“@database”:”POSTGRESQL” ⑧ 使用 Druid 连接池查询 User 表：“@datasource”:”DRUID” ⑨ 将 VARCHAR 字符串字段 get 转为 JSONArray 返回：“@json”:”get” ⑩ 查询当前用户的动态：“@role”:”OWNER” ⑪ 开启性能分析：“@explain”:true对应SQL是EXPLAIN  ⑫ 统计最近一周偶数userId的数量“@column”:”date;left(date,10):day;sum(if(userId%2&#x3D;0,1,0))”,“@group”:”day”,“@having”:”to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7”,“@raw”:”@column,@having”对应SQL是SELECT date, left(date,10) AS day, sum(if(userId%2&#x3D;0,1,0)) ... GROUP BY day HAVING to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7  ⑬ 从pictureList获取第0张图片：“@position”:0, &#x2F;&#x2F;自定义关键词“firstPicture()”:”getFromArray(pictureList,@position)”


全局关键词
为最外层对象 {} 内的关键词。其中 @database，@schema, @datasource, @role, @explain 基本同对象关键词，见上方说明，区别是全局关键词会每个表对象中没有时自动放入，作为默认值。 ① “tag”:String，后面的 tag 是非 GET、HEAD 请求中匹配请求的 JSON 结构的标识，一般是要查询的 Table 的名称或该名称对应的数组 Table[] 或 Table:[]，由后端 Request 表中指定。 ② “version”:Integer，接口版本，version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本，由后端 Request 表中指定。③ “format”:Boolean，格式化返回 Response JSON 的 key，一般是将 TableName 转为 tableName, TableName[] 转为 tableNameList, Table:alias 转为 alias, TableName-key[] 转为 tableNameKeyList 等小驼峰格式。
①  查隐私信息：[{“tag”:”Privacy”,”Privacy”:{“id”:82001}}](http:&#x2F;&#x2F;apijson.cn&#x2F;api?url&#x3D;http%3A%2F%2Fapijson.cn%3A8080%2Fgets&amp;type&#x3D;JSON&amp;json&#x3D;


</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2"><span class="toc-number">1.5.</span> <span class="toc-text">2.对比传统RESTful方式2.1 开发流程


开发流程
传统方式
APIJSON



接口传输
等后端编辑接口，然后更新文档，前端再按照文档编辑请求和解析代码
前端按照自己的需求编辑请求和解析代码。没有接口，更不需要文档！前端再也不用和后端沟通接口或文档问题了！


兼容旧版
后端增加新接口，用v2表示第2版接口，然后更新文档
什么都不用做！


 
 
2.2 前端请求


前端请求
传统方式
APIJSON



要求
前端按照文档在对应URL后面拼接键值对
前端按照自己的需求在固定URL后拼接JSON


URL
不同的请求对应不同的URL，基本上有多少个不同的请求就得有多少个接口URL
相同的操作方法(增删改查)都用同一个URL，大部分请求都用7个通用接口URL的其中一个


键值对
key&#x3D;value
key:value


结构
同一个URL内table_name只能有一个  base_url&#x2F;get&#x2F;table_name?key0&#x3D;value0&amp;key1&#x3D;value1…
同一个URL后TableName可传任意数量个  base_url&#x2F;get&#x2F;{    TableName0:{      key0:value0,      key1:value1,      …    },    TableName1:{      …    }    … }


 
 
2.3 后端操作


后端操作
传统方式
APIJSON



解析和返回
取出键值对，把键值对作为条件用预设的的方式去查询数据库，最后封装JSON并返回给前端
把Parser#parse方法的返回值返回给前端就行


返回JSON结构的设定方式
由后端设定，前端不能修改
由前端设定，后端不能修改


 
 
2.4 前端解析


前端解析
传统方式
APIJSON



查看方式
查文档或问后端，或等请求成功后看日志
看请求就行，所求即所得，不用查、不用问、不用等。也可以等请求成功后看日志


解析方法
用JSON解析器来解析JSONObject
可以用JSONResponse解析JSONObject，或使用传统方式


 
 
2.5 前端对应不同需求的请求


前端的请求
传统方式
APIJSON



User
base_url&#x2F;get&#x2F;user?id&#x3D;38710
base_url&#x2F;get&#x2F;{    “User”:{      “id”:38710    }}


Moment和对应的User
分两次请求Moment:  base_url&#x2F;get&#x2F;moment?userId&#x3D;38710User:  base_url&#x2F;get&#x2F;user?id&#x3D;38710
base_url&#x2F;get&#x2F;{    “Moment”:{      “userId”:38710    },     “User”:{      “id”:38710    }}


User列表
base_url&#x2F;get&#x2F;user&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;sex&#x3D;0
base_url&#x2F;get&#x2F;{    “User[]”:{      “page”:0,       “count”:3,       “User”:{        “sex”:0      }    }}


Moment列表，每个Moment包括1.发布者User2.前3条Comment
Moment里必须有1.User对象2.Comment数组 base_url&#x2F;get&#x2F;moment&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;commentCount&#x3D;3
base_url&#x2F;get&#x2F;{    “[]”:{      “page”:0,       “count”:3,       “Moment”:{},       “User”:{        “id@”:”&#x2F;Moment&#x2F;userId”      },      “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }}


User发布的Moment列表， 每个Moment包括 1.发布者User 2.前3条Comment
1.Moment里必须有User对象和Comment数组 2.字段名必须查接口文档，例如评论数量字段名可能是 commentCount,comment_count或者简写cmt_count等各种奇葩写法…  base_url&#x2F;get&#x2F;moment&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;commentCount&#x3D;3&amp;userId&#x3D;38710
有以下几种方式: ① 把以上请求里的“Moment”:{}, “User”:{“id@”:”&#x2F;Moment&#x2F;userId”}改为“Moment”:{“userId”:38710}, “User”:{“id”:38710}  ② 或把User放在上面的最外层省去重复的Userbase_url&#x2F;get&#x2F;{    “User”:{      “id”:38710    },    “[]”:{      “page”:0,      “count”:3,       “Moment”:{        “userId”:38710      },       “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }} ③ 如果User之前已经获取到了，还可以不传User来节省请求和返回数据的流量并提升速度base_url&#x2F;get&#x2F;{    “[]”:{      “page”:0,      “count”:3,       “Moment”:{        “userId”:38710      },      “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }}


 
 
2.6 后端对应不同请求的返回结果


后端的返回结果
传统方式
APIJSON



User
{    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
{    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


Moment和对应的User
分别返回两次请求的结果，获取到Moment后取出userId作为User的id条件去查询User  Moment:  {    “data”:{      “id”:235,      “content”:”xxx”,      …    },    “code”:200,    “msg”:”success”}  User:  {    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
一次性返回，没有传统方式导致的 长时间等待结果、两次结果间关联、线程多次切换 等问题  {    “Moment”:{      “id”:235,      “content”:”xxx”,      …    },    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


User列表
{    “data”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}
{    “User[]”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}


Moment列表，每个Moment包括发布者User和前3条Comment
Moment里必须有1.User对象2.Comment数组  {    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          …        },        “Comment”:[          …        ]      },      {        “id”:301,        “content”:”xxx”,        …,        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}
1.高灵活，可任意组合2.低耦合，逻辑很清晰{    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          …        },        “Comment[]”:[          …        ]      },      {        “Moment”:{          “id”:301,          “content”:”xxx”,          …        },        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}


User发布的Moment列表，每个Moment包括发布者User和前3条Comment
1.大量重复User，浪费流量和服务器性能2.优化很繁琐，需要后端扩展接口、写好文档，前端&#x2F;前端再配合优化{    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:470,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:511,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:595,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      …    ],    “code”:200,    “msg”:”success”}
以上不同请求方式的结果: ① 常规请求  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ② 省去重复的User  {    “User”:{      “id”:38710,      “name”:”Tommy”,      …    },    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ③ 不查询已获取到的User  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”}


1.base_url指基地址，一般是顶级域名，其它分支url都是在base_url后扩展。如base_url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F; ，对应的GET分支url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F;get&#x2F; 。下同。2.请求中的key或value任意一个为null值时，这个 key:value键值对 被视为无效。下同。3.请求中的 &#x2F; 需要转义。JSONRequest.java已经用URLEncoder.encode转义，不需要再写；但如果是浏览器或Postman等直接输入url&#x2F;request，需要把request中的所有 &#x2F; 都改成 %252F 。下同。4.code，指返回结果中的状态码，200表示成功，其它都是错误码，值全部都是HTTP标准状态码。下同。5.msg，指返回结果中的状态信息，对成功结果或错误原因的详细说明。下同。6.code和msg总是在返回结果的同一层级成对出现。对所有请求的返回结果都会在最外层有一对总结式code和msg。下同。7.id等字段对应的值仅供说明，不一定是数据库里存在的，请求里用的是真实存在的值。下同。



3.设计规范3.1 操作方法


方法及说明
URL
Request
Response



GET:  普通获取数据， 可用浏览器调试
base_url&#x2F;get&#x2F;
{    TableName:{      …     }}  {…}内为限制条件 例如获取一个 id &#x3D; 235 的 Moment： {    “Moment”:{      “id”:235    }}  后端校验通过后自动解析为 SQL 并执行：SELECT * FROM Moment WHERE id&#x3D;235 LIMIT 1
{    TableName:{      …    },    “code”:200,    “msg”:”success”}例如{    “Moment”:{      “id”:235,      “userId”:38710,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “code”:200,    “msg”:”success” }


HEAD:  普通获取数量， 可用浏览器调试
base_url&#x2F;head&#x2F;
{    TableName:{      …    } }  {…}内为限制条件  例如获取一个 id &#x3D; 38710 的 User 所发布的 Moment 总数： {    “Moment”:{      “userId”:38710    }}  后端校验通过后自动解析为 SQL 并执行：SELECT count(*) FROM Moment WHERE userId&#x3D;38710 LIMIT 1
{    TableName:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,    “msg”:”success”}  例如{    “Moment”:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,     “msg”:”success”}


GETS:  安全&#x2F;私密获取数据， 用于获取钱包等对安全性要求高的数据
base_url&#x2F;gets&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Privacy”，其它同GET
同GET


HEADS:  安全&#x2F;私密获取数量， 用于获取银行卡数量等对安全性要求高的数据总数
base_url&#x2F;heads&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Verify”，其它同HEAD
同HEAD


POST:  新增数据
base_url&#x2F;post&#x2F;
单个：  {    TableName:{      …    },    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 38710 发布一个新 Comment：{    “Comment”:{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”     },    “tag”:”Comment”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(38710,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;)    批量：  {    TableName[]:[{        …      }, {        …      }      …    ],    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 82001 发布 2 个 Comment：{    “Comment[]”:[{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”      }, {      “momentId”:15,      “content”:”APIJSON is a JSON transmision protocol.”    }],    “tag”:”Comment:[]”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(82001,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;);INSERT INTO Comment(userId,momentId,content) VALUES(82001,15,&#39;APIJSON is a JSON transmision protocol.&#39;);
单个：  {    TableName:{      “code”:200,      “msg”:”success”,      “id”:38710    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “id”:120    },    “code”:200,    “msg”:”success”}   批量：  {    TableName:{      “code”:200,      “msg”:”success”,      “count”:5,      “id[]”:[1, 2, 3, 4, 5]    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “count”:2,      “id[]”:[1, 2]    },    “code”:200,    “msg”:”success”}


PUT:  修改数据， 只修改所传的字段
base_url&#x2F;put&#x2F;
{    TableName:{      “id”:id,      …    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个 例如当前登录用户 82001 修改 id &#x3D; 235 的 Moment 的 content：{    “Moment”:{      “id”:235,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “tag”:”Moment”}  后端校验通过后自动解析为 SQL 并执行：UPDATE Moment SET content&#x3D;&#39;APIJSON,let interfaces and documents go to hell !&#39; WHERE id&#x3D;235 AND userId&#x3D;82001 LIMIT 1  批量除了 id{}:[] 也可类似批量 POST，只是每个 {…} 里面都必须有 id。“tag”:”Comment[]” 对应对象 “Comment”:{“id{}”:[1,2,3]}，表示指定记录全部统一设置；“tag”:”Comment:[]” 多了冒号，对应数组 “Comment[]”:[{“id”:1},{“id”:2},{“id”:3}]，表示每项单独设置
同POST


DELETE:  删除数据
base_url&#x2F;delete&#x2F;
{    TableName:{      “id”:id    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个，一般只传 id 或 id{} 例如当前登录用户 82001 批量删除 id &#x3D; 100,110,120 的 Comment：{    “Comment”:{      “id{}”:[100,110,120]    },    “tag”:”Comment[]”}  后端校验通过后自动解析为 SQL 并执行：DELETE FROM Comment WHERE id IN(100,110,120) AND userId&#x3D;82001 LIMIT 3
{    TableName:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120]      “count”:3    },    “code”:200,    “msg”:”success”}例如{   “Comment”:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120],      “count”:3   },   “code”:200,   “msg”:”success”}


以上接口的简单形式:  base_url&#x2F;{method}&#x2F;{tag}
GET: 普通获取数据  base_url&#x2F;get&#x2F;{tag}  HEAD: 普通获取数量  base_url&#x2F;head&#x2F;{tag}  GETS: 安全&#x2F;私密获取数据   base_url&#x2F;gets&#x2F;{tag}  HEADS: 安全&#x2F;私密获取数量  base_url&#x2F;heads&#x2F;{tag}  POST: 新增数据   base_url&#x2F;post&#x2F;{tag}  PUT: 修改数据  base_url&#x2F;put&#x2F;{tag}  DELETE: 删除数据  base_url&#x2F;delete&#x2F;{tag}
例如安全&#x2F;私密获取一个 id &#x3D; 82001 的 Privacy： base_url&#x2F;gets&#x2F;Privacy&#x2F;  {“id”:82001}  相当于  base_url&#x2F;gets&#x2F; {“tag”:”Privacy”, “Privacy”:{“id”:82001}}   例如批量修改 id &#x3D; 114, 124 的 Comment 的 content：base_url&#x2F;put&#x2F;Comemnt[]&#x2F;  {    “id{}”:[114,124],    “content”:”test multi put”}  相当于  base_url&#x2F;put&#x2F;  {    “tag”:”Comment[]”,     “Comment”:{      “id{}”:[114,124],      “content”:”test multi put”    }}
同以上对应的方法


1.TableName指要查询的数据库表Table的名称字符串。第一个字符为大写字母，剩下的字符要符合英语字母、数字、下划线中的任何一种。对应的值的类型为JSONObject，结构是 {…}，里面放的是Table的字段(列名)。下同。2.”tag”:tag 后面的tag是非GET、HEAD请求中匹配请求的JSON结构的标识，一般是要查询的Table的名称，由后端Request表中指定。下同。3.GET、HEAD请求是开放请求，可任意组合任意嵌套。其它请求为受限制的安全&#x2F;私密请求，对应的 方法（method）, 标识（tag）, 版本（version）, 结构（structure） 都必须和 后端Request表中所指定的 一一对应，否则请求将不被通过。version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本。下同。4.GETS与GET、HEADS与HEAD分别为同一类型的操作方法，请求稍有不同但返回结果相同。下同。5.在HTTP通信中，自动化接口(get,gets,head,heads,post,put,delete) 全用HTTP POST请求。下同。6.所有JSONObject都视为容器(或者文件夹)，结构为 {…} ，里面可以放普通对象或子容器。下同。7.每个对象都有一个唯一的路径(或者叫地址)，假设对象名为refKey，则用 key0&#x2F;key1&#x2F;…&#x2F;refKey 表示。下同。


3.2 功能符


功能
键值对格式
使用示例



查询数组
“key[]”:{}，后面是JSONObject，key可省略。当key和里面的Table名相同时，Table会被提取出来，即 {Table:{Content}} 会被转化为 {Content}
{“User[]”:{“User”:{}}}，查询一个User数组。这里key和Table名都是User，User会被提取出来，即 {“User”:{“id”, …}} 会被转化为 {“id”, …}，如果要进一步提取User中的id，可以把User[]改为User-id[]


匹配选项范围
“key{}”:[]，后面是JSONArray，作为key可取的值的选项
“id{}”:[38710,82001,70793]，对应SQL是id IN(38710,82001,70793)，查询id符合38710,82001,70793中任意一个的一个User数组


匹配条件范围
“key{}”:”条件0,条件1…”，条件为SQL表达式字符串，可进行数字比较运算等
“id{}”:”&lt;&#x3D;80000,&gt;90000”，对应SQL是id&lt;&#x3D;80000 OR id&gt;90000，查询id符合id&lt;&#x3D;80000 | id&gt;90000的一个User数组


包含选项范围
“key&lt;&gt;“:Object  &#x3D;&gt;  “key&lt;&gt;“:[Object]，key对应值的类型必须为JSONArray，Object类型不能为JSON
“contactIdList&lt;&gt;“:38710，对应SQL是json_contains(contactIdList,38710)，查询contactIdList包含38710的一个User数组


判断是否存在
“key}{@”:{    “from”:”Table”,    “Table”:{ … }}其中：}{ 表示 EXISTS； key 用来标识是哪个判断； @ 后面是 子查询 对象，具体见下方 子查询 的说明。
“id}{@”:{    “from”:”Comment”,    “Comment”:{        “momentId”:15     }} WHERE EXISTS(SELECT * FROM Comment WHERE momentId&#x3D;15)


远程调用函数
“key()”:”函数表达式”，函数表达式为 function(key0,key1…)，会调用后端对应的函数 function(JSONObject request, String key0, String key1…)，实现 参数校验、数值计算、数据同步、消息推送、字段拼接、结构变换 等特定的业务逻辑处理，可使用 - 和 + 表示优先级，解析 key-() &gt; 解析当前对象 &gt; 解析 key() &gt; 解析子对象 &gt; 解析 key+()
“isPraised()”:”isContain(praiseUserIdList,userId)”，会调用远程函数 boolean isContain(JSONObject request, String array, String value) ，然后变为 “isPraised”:true 这种（假设点赞用户id列表包含了userId，即这个User点了赞）


存储过程
“@key()”:”SQL函数表达式”，函数表达式为   function(key0,key1…)  会调用后端数据库对应的存储过程 SQL函数  function(String key0, String key1…)  除了参数会提前赋值，其它和 远程函数 一致
“@limit”:10,  “@offset”:0,  “@procedure()”:”getCommentByUserId(id,@limit,@offset)”  会转为  getCommentByUserId(38710,10,0)  来调用存储过程 SQL 函数  getCommentByUserId(IN id bigint, IN limit int, IN offset int)  然后变为 “procedure”:{    “count”:-1,     “update”:false,     “list”:[]  }  其中 count 是指写操作影响记录行数，-1 表示不是写操作；update 是指是否为写操作（增删改）；list 为返回结果集


引用赋值
“key@”:”key0&#x2F;key1&#x2F;…&#x2F;refKey”，引用路径为用&#x2F;分隔的字符串。以&#x2F;开头的是缺省引用路径，从声明key所处容器的父容器路径开始；其它是完整引用路径，从最外层开始。 被引用的refKey必须在声明key的上面。如果对refKey的容器指定了返回字段，则被引用的refKey必须写在@column对应的值内，例如 “@column”:”refKey,key1,…”
“Moment”:{    “userId”:38710},“User”:{    “id@”:”&#x2F;Moment&#x2F;userId”} User内的id引用了与User同级的Moment内的userId，即User.id &#x3D; Moment.userId，请求完成后 “id@”:”&#x2F;Moment&#x2F;userId” 会变成 “id”:38710


子查询
“key@”:{    “range”:”ALL”,     “from”:”Table”,    “Table”:{ … }}其中：range 可为 ALL,ANY；from 为目标表 Table 的名称；@ 后面的对象类似数组对象，可使用 count 和 join 等功能。
“id@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&#x3D;(SELECT min(userId) FROM Comment)


模糊搜索
&quot;key$&quot;:&quot;SQL搜索表达式&quot;  &#x3D;&gt;  &quot;key$&quot;:[&quot;SQL搜索表达式&quot;]，任意SQL搜索表达式字符串，如 %key%(包含key), key%(以key开始), %k%e%y%(包含字母k,e,y) 等，%表示任意字符
“name$”:”%m%”，对应SQL是name LIKE &#39;%m%&#39;，查询name包含”m”的一个User数组


正则匹配
“key“:”正则表达式”  &#x3D;&gt;  “key“:[“正则表达式”]，任意正则表达式字符串，如 ^[0-9]+$ ，*~ 忽略大小写，可用于高级搜索
“name~”:”^[0-9]+$”，对应SQL是name REGEXP &#39;^[0-9]+$&#39;，查询name中字符全为数字的一个User数组


连续范围
“key%”:”start,end”  &#x3D;&gt;  “key%”:[“start,end”]，其中 start 和 end 都只能为 Boolean, Number, String 中的一种，如 “2017-01-01,2019-01-01” ，[“1,90000”, “82001,100000”] ，可用于连续范围内的筛选
“date%”:”2017-10-01,2018-10-01”，对应SQL是date BETWEEN &#39;2017-10-01&#39; AND &#39;2018-10-01&#39;，查询在2017-10-01和2018-10-01期间注册的用户的一个User数组


新建别名
“name:alias”，name映射为alias，用alias替代name。可用于 column,Table,SQL函数 等。只用于GET类型、HEAD类型的请求
“@column”:”toId:parentId”，对应SQL是toId AS parentId，将查询的字段toId变为parentId返回


增加 或 扩展
“key+”:Object，Object的类型由key指定，且类型为Number,String,JSONArray中的一种。如 82001,”apijson”,[“url0”,”url1”] 等。只用于PUT请求
“praiseUserIdList+”:[82001]，对应SQL是json_insert(praiseUserIdList,82001)，添加一个点赞用户id，即这个用户点了赞


减少 或 去除
“key-“:Object，与”key+”相反
“balance-“:100.00，对应SQL是balance &#x3D; balance - 100.00，余额减少100.00，即花费了100元


比较运算
&gt;, &lt;, &gt;&#x3D;, &lt;&#x3D; 比较运算符，用于 ① 提供 “id{}”:”&lt;&#x3D;90000” 这种条件范围的简化写法 ② 实现子查询相关比较运算不支持 “key&#x3D;”:Object 和 “key!&#x3D;”:Object 这两种写法，直接用更简单的 “key”:Object 和 “key!”:Object 替代。
① “id&lt;&#x3D;”:90000，对应SQL是id&lt;&#x3D;90000，查询符合id&lt;&#x3D;90000的一个User数组 ② “id&gt;@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&gt;(SELECT min(userId) FROM Comment)


逻辑运算
&amp;, |, ! 逻辑运算符，对应数据库 SQL 中的 AND, OR, NOT。 横或纵与：同一键值对的值内条件默认 | 或连接，可以在 key 后加逻辑运算符来具体指定；不同键值对的条件默认 &amp; 与连接，可以用下面说明的对象关键词 @combine 来具体指定。 ① &amp; 可用于”key&amp;{}”:”条件”等② | 可用于”key|{}”:”条件”, “key|{}”:[]等，一般可省略③ ! 可单独使用，如”key!”:Object，也可像&amp;,|一样配合其他功能符使用  “key!”:null 无效，null 值会导致整个键值对被忽略解析，可以用 “key{}”:”!&#x3D;null” 替代，“key”:null 同理，用 “key{}”:”&#x3D;null” 替代。
① “id&amp;{}”:”&gt;80000,&lt;&#x3D;90000”，对应SQL是id&gt;80000 AND id&lt;&#x3D;90000，即id满足id&gt;80000 &amp; id&lt;&#x3D;90000 ② “id|{}”:”&gt;90000,&lt;&#x3D;80000”，同”id{}”:”&gt;90000,&lt;&#x3D;80000”，对应SQL是id&gt;80000 OR id&lt;&#x3D;90000，即id满足id&gt;90000 | id&lt;&#x3D;80000 ③ “id!{}”:[82001,38710]，对应SQL是id NOT IN(82001,38710)，即id满足 ! (id&#x3D;82001 | id&#x3D;38710)，可过滤黑名单的消息


数组关键词，可自定义
“key”:Object，key为 “[]”:{} 中{}内的关键词，Object的类型由key指定① “count”:Integer，查询数量，0 表示最大值，默认最大值为100 ② “page”:Integer，查询页码，从0开始，默认最大值为100，一般和count一起用③ “query”:Integer，查询内容0-对象，1-总数和分页详情，2-数据、总数和分页详情总数关键词为 total，分页详情关键词为 info， 它们都和 query 同级，通过引用赋值得到，例如  “total@”:”&#x2F;[]&#x2F;total”, “info@”:”&#x2F;[]&#x2F;info” 这里query及total仅为GET类型的请求提供方便， 一般可直接用HEAD类型的请求获取总数④ “join”:”&amp;&#x2F;Table0,&lt;&#x2F;Table1&#x2F;key1@” 或 “join”:{    “&amp;&#x2F;Table0”:{},  &#x2F;&#x2F; 支持 ON 多个字段关联,    “&lt;&#x2F;Table1&#x2F;key1@”:{  &#x2F;&#x2F; ON 只允许指定的 key1 关联      “key0”:value0,  &#x2F;&#x2F; 其它ON条件       “key2”:value2,      …       “@combine”:”…”,  &#x2F;&#x2F; 其它ON条件的组合方式       “@column”:”…”,  &#x2F;&#x2F; 外层 SELECT       “@group”:”…”,  &#x2F;&#x2F; 外层 GROUP BY       “@having”:”…”  &#x2F;&#x2F; 外层 HAVING     }}多表连接方式：  “@” - APP JOIN  “&lt;“ - LEFT JOIN  “&gt;” - RIGHT JOIN  “&amp;” - INNER JOIN  “|” - FULL JOIN   “!” - OUTER JOIN   “*” - CROSS JOIN   “^” - SIDE JOIN   “(“ - ANTI JOIN   “)” - FOREIGN JOIN 其中 @ APP JOIN 为应用层连表，会从已查出的主表里取得所有副表 key@ 关联的主表内的 refKey 作为一个数组 refKeys: [value0, value1…]，然后把原来副表 count 次查询 key&#x3D;$refKey 的 SQL 用 key IN($refKeys) 的方式合并为一条 SQL 来优化性能； 其它 JOIN 都是 SQL JOIN，具体功能和 MySQL,PostgreSQL 等数据库的 JOIN 一一对应 &quot;join&quot;:&quot;&lt;&#x2F;ViceTable&#x2F;key@&quot;,&quot;MainTable&quot;:{},&quot;ViceTable&quot;:{&quot;key@&quot;:&quot;&#x2F;MainTable&#x2F;refKey&quot;}会对应生成 MainTable LEFT JOIN ViceTable ON ViceTable.key&#x3D;MainTable.refKey AND 其它ON条件  除了 &#x3D; 等价关联，也支持 ! 不等关联、&gt; &lt; &gt;&#x3D; &lt;&#x3D; 等比较关联和 $ ~ {} &lt;&gt; 等其它复杂关联方式 ⑤ “otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 查询User数组，最多5个：“count”:5对应SQL是LIMIT 5  ② 查询第3页的User数组，每页5个：“count”:5,“page”:3对应SQL是LIMIT 5 OFFSET 15  ③ 查询User数组和对应的User总数：“[]”:{    “query”:2,    “User”:{}},“total@”:”&#x2F;[]&#x2F;total”,“info@”:”&#x2F;[]&#x2F;info” 返回的数据中，总数及分页详情结构为：   “total”:139,  &#x2F;&#x2F;总数  “info”:{  &#x2F;&#x2F;分页详情     “total”:139,  &#x2F;&#x2F;总数     “count”:5,  &#x2F;&#x2F;每页数量     “page”:0,  &#x2F;&#x2F;当前页码     “max”:27,  &#x2F;&#x2F;最大页码     “more”:true,  &#x2F;&#x2F;是否还有更多     “first”:true,  &#x2F;&#x2F;是否为首页     “last”:false  &#x2F;&#x2F;是否为尾页 }  ④ Moment INNER JOIN User LEFT JOIN Comment：“[]”:{    “join”:”&amp;&#x2F;User&#x2F;id@,&lt;&#x2F;Comment”,    “Moment”:{     “@group”:”id”  &#x2F;&#x2F;主副表不是一对一，要去除重复数据   },    “User”:{      “name~”:”t”,      “id@”:”&#x2F;Moment&#x2F;userId”    },    “Comment”:{      “momentId@”:”&#x2F;Moment&#x2F;id”    }} ⑤ 每一层都加当前用户名：“User”:{},“[]”:{    “name@”:”User&#x2F;name”, &#x2F;&#x2F;自定义关键词    “Moment”:{}}


对象关键词，可自定义
“@key”:Object，@key为 Table:{} 中{}内的关键词，Object的类型由@key指定① “@combine”:”key0 | (key1 &amp; (key2 | !key3))…”，条件组合方式，最终按  (其它key条件 AND 连接) AND (key0条件 OR (key1条件 AND (key2条件 OR (NOT key3条件)))) 这种方式连接，其中 “其它key” 是指与 @combine 在同一对象，且未被它声明的条件 key，默认都是 &amp; 连接。注意不要缺少或多余任何一个空格。 ② “@column”:”column;function(arg)…”，返回字段③ “@order”:”column0+,column1-…”，排序方式④ “@group”:”column0,column1…”，分组方式。如果@column里声明了Table的id，则id也必须在@group中声明；其它情况下必须满足至少一个条件:1.分组的key在@column里声明2.Table主键在@group中声明 ⑤ “@having”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…” &#x2F;&#x2F; OR 连接，或 “@having&amp;”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…”  &#x2F;&#x2F; AND 连接，或 “@having”:{   “h0”:”function0(…)?value0”,   “h1”:function1(…)?value1”,   “h2”:function2(…)?value2…”,   “@combine”:”h0 &amp; (h1 | !h2)”  &#x2F;&#x2F; 任意组合，非必传}SQL函数条件，一般和@group一起用，函数一般在@column里声明⑥ “@schema”:”sys”，集合空间(数据库名&#x2F;模式)，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑦ “@database”:”POSTGRESQL”，数据库类型，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑧ “@datasource”:”DRUID”，跨数据源，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑨ “@json”:”key0,key1…”，转为 JSON 格式返回，符合 JSONObject 则转为 {…}，符合 JSONArray 则转为 […] ⑩ “@role”:”OWNER”，来访角色，包括UNKNOWN,LOGIN,CONTACT,CIRCLE,OWNER,ADMIN，可以在最外层作为全局默认配置，可自定义其它角色并重写 Verifier.verify 等相关方法来自定义校验 ⑪ “@explain”:true，性能分析，可以在最外层作为全局默认配置 ⑫ “@raw”:”key0,key1…”，其中 key0, key1 都对应有键值对 “key0”:”SQL片段或SQL片段的别名”,  “key1”:”SQL片段或SQL片段的别名”  自定义原始SQL片段，可扩展嵌套SQL函数等复杂语句，必须是后端已配置的，只有其它功能符都做不到才考虑，谨慎使用，注意防SQL注入⑬ “@otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 搜索name或tag任何一个字段包含字符a的User列表： “name“:”a”,“tag“:”a”,“@combine”:”name~ | tag~” 对应SQL是name REGEXP &#39;a&#39; OR tag REGEXP &#39;a&#39;  ② 只查询id,sex,name这几列并且请求结果也按照这个顺序：“@column”:”id,sex,name”对应SQL是SELECT id,sex,name  ③ 查询按 name降序、id默认顺序 排序的User数组：“@order”:”name-,id”对应SQL是ORDER BY name DESC,id  ④ 查询按userId分组的Moment数组：“@group”:”userId,id”对应SQL是GROUP BY userId,id  ⑤ 查询 按userId分组、id最大值&gt;&#x3D;100 的Moment数组：“@column”:”userId;max(id)”,“@group”:”userId”,“@having”:”max(id)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) ... GROUP BY userId HAVING max(id)&gt;&#x3D;100 还可以指定函数返回名：“@column”:”userId;max(id):maxId”,“@group”:”userId”,“@having”:”(maxId)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) AS maxId ... GROUP BY userId HAVING (maxId)&gt;&#x3D;100  ⑥ 查询 sys 内的 User 表：“@schema”:”sys”对应SQL是FROM sys.User  ⑦ 查询 PostgreSQL 数据库的 User 表：“@database”:”POSTGRESQL” ⑧ 使用 Druid 连接池查询 User 表：“@datasource”:”DRUID” ⑨ 将 VARCHAR 字符串字段 get 转为 JSONArray 返回：“@json”:”get” ⑩ 查询当前用户的动态：“@role”:”OWNER” ⑪ 开启性能分析：“@explain”:true对应SQL是EXPLAIN  ⑫ 统计最近一周偶数userId的数量“@column”:”date;left(date,10):day;sum(if(userId%2&#x3D;0,1,0))”,“@group”:”day”,“@having”:”to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7”,“@raw”:”@column,@having”对应SQL是SELECT date, left(date,10) AS day, sum(if(userId%2&#x3D;0,1,0)) ... GROUP BY day HAVING to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7  ⑬ 从pictureList获取第0张图片：“@position”:0, &#x2F;&#x2F;自定义关键词“firstPicture()”:”getFromArray(pictureList,@position)”


全局关键词
为最外层对象 {} 内的关键词。其中 @database，@schema, @datasource, @role, @explain 基本同对象关键词，见上方说明，区别是全局关键词会每个表对象中没有时自动放入，作为默认值。 ① “tag”:String，后面的 tag 是非 GET、HEAD 请求中匹配请求的 JSON 结构的标识，一般是要查询的 Table 的名称或该名称对应的数组 Table[] 或 Table:[]，由后端 Request 表中指定。 ② “version”:Integer，接口版本，version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本，由后端 Request 表中指定。③ “format”:Boolean，格式化返回 Response JSON 的 key，一般是将 TableName 转为 tableName, TableName[] 转为 tableNameList, Table:alias 转为 alias, TableName-key[] 转为 tableNameKeyList 等小驼峰格式。
①  查隐私信息：[{“tag”:”Privacy”,”Privacy”:{“id”:82001}}](http:&#x2F;&#x2F;apijson.cn&#x2F;api?url&#x3D;http%3A%2F%2Fapijson.cn%3A8080%2Fgets&amp;type&#x3D;JSON&amp;json&#x3D;


</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2"><span class="toc-number">1.6.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="toc-number">1.6.1.</span> <span class="toc-text">2.1 开发流程


开发流程
传统方式
APIJSON



接口传输
等后端编辑接口，然后更新文档，前端再按照文档编辑请求和解析代码
前端按照自己的需求编辑请求和解析代码。没有接口，更不需要文档！前端再也不用和后端沟通接口或文档问题了！


兼容旧版
后端增加新接口，用v2表示第2版接口，然后更新文档
什么都不用做！


 
 
2.2 前端请求


前端请求
传统方式
APIJSON



要求
前端按照文档在对应URL后面拼接键值对
前端按照自己的需求在固定URL后拼接JSON


URL
不同的请求对应不同的URL，基本上有多少个不同的请求就得有多少个接口URL
相同的操作方法(增删改查)都用同一个URL，大部分请求都用7个通用接口URL的其中一个


键值对
key&#x3D;value
key:value


结构
同一个URL内table_name只能有一个  base_url&#x2F;get&#x2F;table_name?key0&#x3D;value0&amp;key1&#x3D;value1…
同一个URL后TableName可传任意数量个  base_url&#x2F;get&#x2F;{    TableName0:{      key0:value0,      key1:value1,      …    },    TableName1:{      …    }    … }


 
 
2.3 后端操作


后端操作
传统方式
APIJSON



解析和返回
取出键值对，把键值对作为条件用预设的的方式去查询数据库，最后封装JSON并返回给前端
把Parser#parse方法的返回值返回给前端就行


返回JSON结构的设定方式
由后端设定，前端不能修改
由前端设定，后端不能修改


 
 
2.4 前端解析


前端解析
传统方式
APIJSON



查看方式
查文档或问后端，或等请求成功后看日志
看请求就行，所求即所得，不用查、不用问、不用等。也可以等请求成功后看日志


解析方法
用JSON解析器来解析JSONObject
可以用JSONResponse解析JSONObject，或使用传统方式


 
 
2.5 前端对应不同需求的请求


前端的请求
传统方式
APIJSON



User
base_url&#x2F;get&#x2F;user?id&#x3D;38710
base_url&#x2F;get&#x2F;{    “User”:{      “id”:38710    }}


Moment和对应的User
分两次请求Moment:  base_url&#x2F;get&#x2F;moment?userId&#x3D;38710User:  base_url&#x2F;get&#x2F;user?id&#x3D;38710
base_url&#x2F;get&#x2F;{    “Moment”:{      “userId”:38710    },     “User”:{      “id”:38710    }}


User列表
base_url&#x2F;get&#x2F;user&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;sex&#x3D;0
base_url&#x2F;get&#x2F;{    “User[]”:{      “page”:0,       “count”:3,       “User”:{        “sex”:0      }    }}


Moment列表，每个Moment包括1.发布者User2.前3条Comment
Moment里必须有1.User对象2.Comment数组 base_url&#x2F;get&#x2F;moment&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;commentCount&#x3D;3
base_url&#x2F;get&#x2F;{    “[]”:{      “page”:0,       “count”:3,       “Moment”:{},       “User”:{        “id@”:”&#x2F;Moment&#x2F;userId”      },      “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }}


User发布的Moment列表， 每个Moment包括 1.发布者User 2.前3条Comment
1.Moment里必须有User对象和Comment数组 2.字段名必须查接口文档，例如评论数量字段名可能是 commentCount,comment_count或者简写cmt_count等各种奇葩写法…  base_url&#x2F;get&#x2F;moment&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;commentCount&#x3D;3&amp;userId&#x3D;38710
有以下几种方式: ① 把以上请求里的“Moment”:{}, “User”:{“id@”:”&#x2F;Moment&#x2F;userId”}改为“Moment”:{“userId”:38710}, “User”:{“id”:38710}  ② 或把User放在上面的最外层省去重复的Userbase_url&#x2F;get&#x2F;{    “User”:{      “id”:38710    },    “[]”:{      “page”:0,      “count”:3,       “Moment”:{        “userId”:38710      },       “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }} ③ 如果User之前已经获取到了，还可以不传User来节省请求和返回数据的流量并提升速度base_url&#x2F;get&#x2F;{    “[]”:{      “page”:0,      “count”:3,       “Moment”:{        “userId”:38710      },      “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }}


 
 
2.6 后端对应不同请求的返回结果


后端的返回结果
传统方式
APIJSON



User
{    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
{    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


Moment和对应的User
分别返回两次请求的结果，获取到Moment后取出userId作为User的id条件去查询User  Moment:  {    “data”:{      “id”:235,      “content”:”xxx”,      …    },    “code”:200,    “msg”:”success”}  User:  {    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
一次性返回，没有传统方式导致的 长时间等待结果、两次结果间关联、线程多次切换 等问题  {    “Moment”:{      “id”:235,      “content”:”xxx”,      …    },    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


User列表
{    “data”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}
{    “User[]”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}


Moment列表，每个Moment包括发布者User和前3条Comment
Moment里必须有1.User对象2.Comment数组  {    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          …        },        “Comment”:[          …        ]      },      {        “id”:301,        “content”:”xxx”,        …,        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}
1.高灵活，可任意组合2.低耦合，逻辑很清晰{    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          …        },        “Comment[]”:[          …        ]      },      {        “Moment”:{          “id”:301,          “content”:”xxx”,          …        },        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}


User发布的Moment列表，每个Moment包括发布者User和前3条Comment
1.大量重复User，浪费流量和服务器性能2.优化很繁琐，需要后端扩展接口、写好文档，前端&#x2F;前端再配合优化{    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:470,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:511,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:595,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      …    ],    “code”:200,    “msg”:”success”}
以上不同请求方式的结果: ① 常规请求  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ② 省去重复的User  {    “User”:{      “id”:38710,      “name”:”Tommy”,      …    },    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ③ 不查询已获取到的User  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”}


1.base_url指基地址，一般是顶级域名，其它分支url都是在base_url后扩展。如base_url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F; ，对应的GET分支url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F;get&#x2F; 。下同。2.请求中的key或value任意一个为null值时，这个 key:value键值对 被视为无效。下同。3.请求中的 &#x2F; 需要转义。JSONRequest.java已经用URLEncoder.encode转义，不需要再写；但如果是浏览器或Postman等直接输入url&#x2F;request，需要把request中的所有 &#x2F; 都改成 %252F 。下同。4.code，指返回结果中的状态码，200表示成功，其它都是错误码，值全部都是HTTP标准状态码。下同。5.msg，指返回结果中的状态信息，对成功结果或错误原因的详细说明。下同。6.code和msg总是在返回结果的同一层级成对出现。对所有请求的返回结果都会在最外层有一对总结式code和msg。下同。7.id等字段对应的值仅供说明，不一定是数据库里存在的，请求里用的是真实存在的值。下同。



3.设计规范3.1 操作方法


方法及说明
URL
Request
Response



GET:  普通获取数据， 可用浏览器调试
base_url&#x2F;get&#x2F;
{    TableName:{      …     }}  {…}内为限制条件 例如获取一个 id &#x3D; 235 的 Moment： {    “Moment”:{      “id”:235    }}  后端校验通过后自动解析为 SQL 并执行：SELECT * FROM Moment WHERE id&#x3D;235 LIMIT 1
{    TableName:{      …    },    “code”:200,    “msg”:”success”}例如{    “Moment”:{      “id”:235,      “userId”:38710,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “code”:200,    “msg”:”success” }


HEAD:  普通获取数量， 可用浏览器调试
base_url&#x2F;head&#x2F;
{    TableName:{      …    } }  {…}内为限制条件  例如获取一个 id &#x3D; 38710 的 User 所发布的 Moment 总数： {    “Moment”:{      “userId”:38710    }}  后端校验通过后自动解析为 SQL 并执行：SELECT count(*) FROM Moment WHERE userId&#x3D;38710 LIMIT 1
{    TableName:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,    “msg”:”success”}  例如{    “Moment”:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,     “msg”:”success”}


GETS:  安全&#x2F;私密获取数据， 用于获取钱包等对安全性要求高的数据
base_url&#x2F;gets&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Privacy”，其它同GET
同GET


HEADS:  安全&#x2F;私密获取数量， 用于获取银行卡数量等对安全性要求高的数据总数
base_url&#x2F;heads&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Verify”，其它同HEAD
同HEAD


POST:  新增数据
base_url&#x2F;post&#x2F;
单个：  {    TableName:{      …    },    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 38710 发布一个新 Comment：{    “Comment”:{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”     },    “tag”:”Comment”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(38710,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;)    批量：  {    TableName[]:[{        …      }, {        …      }      …    ],    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 82001 发布 2 个 Comment：{    “Comment[]”:[{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”      }, {      “momentId”:15,      “content”:”APIJSON is a JSON transmision protocol.”    }],    “tag”:”Comment:[]”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(82001,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;);INSERT INTO Comment(userId,momentId,content) VALUES(82001,15,&#39;APIJSON is a JSON transmision protocol.&#39;);
单个：  {    TableName:{      “code”:200,      “msg”:”success”,      “id”:38710    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “id”:120    },    “code”:200,    “msg”:”success”}   批量：  {    TableName:{      “code”:200,      “msg”:”success”,      “count”:5,      “id[]”:[1, 2, 3, 4, 5]    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “count”:2,      “id[]”:[1, 2]    },    “code”:200,    “msg”:”success”}


PUT:  修改数据， 只修改所传的字段
base_url&#x2F;put&#x2F;
{    TableName:{      “id”:id,      …    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个 例如当前登录用户 82001 修改 id &#x3D; 235 的 Moment 的 content：{    “Moment”:{      “id”:235,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “tag”:”Moment”}  后端校验通过后自动解析为 SQL 并执行：UPDATE Moment SET content&#x3D;&#39;APIJSON,let interfaces and documents go to hell !&#39; WHERE id&#x3D;235 AND userId&#x3D;82001 LIMIT 1  批量除了 id{}:[] 也可类似批量 POST，只是每个 {…} 里面都必须有 id。“tag”:”Comment[]” 对应对象 “Comment”:{“id{}”:[1,2,3]}，表示指定记录全部统一设置；“tag”:”Comment:[]” 多了冒号，对应数组 “Comment[]”:[{“id”:1},{“id”:2},{“id”:3}]，表示每项单独设置
同POST


DELETE:  删除数据
base_url&#x2F;delete&#x2F;
{    TableName:{      “id”:id    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个，一般只传 id 或 id{} 例如当前登录用户 82001 批量删除 id &#x3D; 100,110,120 的 Comment：{    “Comment”:{      “id{}”:[100,110,120]    },    “tag”:”Comment[]”}  后端校验通过后自动解析为 SQL 并执行：DELETE FROM Comment WHERE id IN(100,110,120) AND userId&#x3D;82001 LIMIT 3
{    TableName:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120]      “count”:3    },    “code”:200,    “msg”:”success”}例如{   “Comment”:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120],      “count”:3   },   “code”:200,   “msg”:”success”}


以上接口的简单形式:  base_url&#x2F;{method}&#x2F;{tag}
GET: 普通获取数据  base_url&#x2F;get&#x2F;{tag}  HEAD: 普通获取数量  base_url&#x2F;head&#x2F;{tag}  GETS: 安全&#x2F;私密获取数据   base_url&#x2F;gets&#x2F;{tag}  HEADS: 安全&#x2F;私密获取数量  base_url&#x2F;heads&#x2F;{tag}  POST: 新增数据   base_url&#x2F;post&#x2F;{tag}  PUT: 修改数据  base_url&#x2F;put&#x2F;{tag}  DELETE: 删除数据  base_url&#x2F;delete&#x2F;{tag}
例如安全&#x2F;私密获取一个 id &#x3D; 82001 的 Privacy： base_url&#x2F;gets&#x2F;Privacy&#x2F;  {“id”:82001}  相当于  base_url&#x2F;gets&#x2F; {“tag”:”Privacy”, “Privacy”:{“id”:82001}}   例如批量修改 id &#x3D; 114, 124 的 Comment 的 content：base_url&#x2F;put&#x2F;Comemnt[]&#x2F;  {    “id{}”:[114,124],    “content”:”test multi put”}  相当于  base_url&#x2F;put&#x2F;  {    “tag”:”Comment[]”,     “Comment”:{      “id{}”:[114,124],      “content”:”test multi put”    }}
同以上对应的方法


1.TableName指要查询的数据库表Table的名称字符串。第一个字符为大写字母，剩下的字符要符合英语字母、数字、下划线中的任何一种。对应的值的类型为JSONObject，结构是 {…}，里面放的是Table的字段(列名)。下同。2.”tag”:tag 后面的tag是非GET、HEAD请求中匹配请求的JSON结构的标识，一般是要查询的Table的名称，由后端Request表中指定。下同。3.GET、HEAD请求是开放请求，可任意组合任意嵌套。其它请求为受限制的安全&#x2F;私密请求，对应的 方法（method）, 标识（tag）, 版本（version）, 结构（structure） 都必须和 后端Request表中所指定的 一一对应，否则请求将不被通过。version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本。下同。4.GETS与GET、HEADS与HEAD分别为同一类型的操作方法，请求稍有不同但返回结果相同。下同。5.在HTTP通信中，自动化接口(get,gets,head,heads,post,put,delete) 全用HTTP POST请求。下同。6.所有JSONObject都视为容器(或者文件夹)，结构为 {…} ，里面可以放普通对象或子容器。下同。7.每个对象都有一个唯一的路径(或者叫地址)，假设对象名为refKey，则用 key0&#x2F;key1&#x2F;…&#x2F;refKey 表示。下同。


3.2 功能符


功能
键值对格式
使用示例



查询数组
“key[]”:{}，后面是JSONObject，key可省略。当key和里面的Table名相同时，Table会被提取出来，即 {Table:{Content}} 会被转化为 {Content}
{“User[]”:{“User”:{}}}，查询一个User数组。这里key和Table名都是User，User会被提取出来，即 {“User”:{“id”, …}} 会被转化为 {“id”, …}，如果要进一步提取User中的id，可以把User[]改为User-id[]


匹配选项范围
“key{}”:[]，后面是JSONArray，作为key可取的值的选项
“id{}”:[38710,82001,70793]，对应SQL是id IN(38710,82001,70793)，查询id符合38710,82001,70793中任意一个的一个User数组


匹配条件范围
“key{}”:”条件0,条件1…”，条件为SQL表达式字符串，可进行数字比较运算等
“id{}”:”&lt;&#x3D;80000,&gt;90000”，对应SQL是id&lt;&#x3D;80000 OR id&gt;90000，查询id符合id&lt;&#x3D;80000 | id&gt;90000的一个User数组


包含选项范围
“key&lt;&gt;“:Object  &#x3D;&gt;  “key&lt;&gt;“:[Object]，key对应值的类型必须为JSONArray，Object类型不能为JSON
“contactIdList&lt;&gt;“:38710，对应SQL是json_contains(contactIdList,38710)，查询contactIdList包含38710的一个User数组


判断是否存在
“key}{@”:{    “from”:”Table”,    “Table”:{ … }}其中：}{ 表示 EXISTS； key 用来标识是哪个判断； @ 后面是 子查询 对象，具体见下方 子查询 的说明。
“id}{@”:{    “from”:”Comment”,    “Comment”:{        “momentId”:15     }} WHERE EXISTS(SELECT * FROM Comment WHERE momentId&#x3D;15)


远程调用函数
“key()”:”函数表达式”，函数表达式为 function(key0,key1…)，会调用后端对应的函数 function(JSONObject request, String key0, String key1…)，实现 参数校验、数值计算、数据同步、消息推送、字段拼接、结构变换 等特定的业务逻辑处理，可使用 - 和 + 表示优先级，解析 key-() &gt; 解析当前对象 &gt; 解析 key() &gt; 解析子对象 &gt; 解析 key+()
“isPraised()”:”isContain(praiseUserIdList,userId)”，会调用远程函数 boolean isContain(JSONObject request, String array, String value) ，然后变为 “isPraised”:true 这种（假设点赞用户id列表包含了userId，即这个User点了赞）


存储过程
“@key()”:”SQL函数表达式”，函数表达式为   function(key0,key1…)  会调用后端数据库对应的存储过程 SQL函数  function(String key0, String key1…)  除了参数会提前赋值，其它和 远程函数 一致
“@limit”:10,  “@offset”:0,  “@procedure()”:”getCommentByUserId(id,@limit,@offset)”  会转为  getCommentByUserId(38710,10,0)  来调用存储过程 SQL 函数  getCommentByUserId(IN id bigint, IN limit int, IN offset int)  然后变为 “procedure”:{    “count”:-1,     “update”:false,     “list”:[]  }  其中 count 是指写操作影响记录行数，-1 表示不是写操作；update 是指是否为写操作（增删改）；list 为返回结果集


引用赋值
“key@”:”key0&#x2F;key1&#x2F;…&#x2F;refKey”，引用路径为用&#x2F;分隔的字符串。以&#x2F;开头的是缺省引用路径，从声明key所处容器的父容器路径开始；其它是完整引用路径，从最外层开始。 被引用的refKey必须在声明key的上面。如果对refKey的容器指定了返回字段，则被引用的refKey必须写在@column对应的值内，例如 “@column”:”refKey,key1,…”
“Moment”:{    “userId”:38710},“User”:{    “id@”:”&#x2F;Moment&#x2F;userId”} User内的id引用了与User同级的Moment内的userId，即User.id &#x3D; Moment.userId，请求完成后 “id@”:”&#x2F;Moment&#x2F;userId” 会变成 “id”:38710


子查询
“key@”:{    “range”:”ALL”,     “from”:”Table”,    “Table”:{ … }}其中：range 可为 ALL,ANY；from 为目标表 Table 的名称；@ 后面的对象类似数组对象，可使用 count 和 join 等功能。
“id@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&#x3D;(SELECT min(userId) FROM Comment)


模糊搜索
&quot;key$&quot;:&quot;SQL搜索表达式&quot;  &#x3D;&gt;  &quot;key$&quot;:[&quot;SQL搜索表达式&quot;]，任意SQL搜索表达式字符串，如 %key%(包含key), key%(以key开始), %k%e%y%(包含字母k,e,y) 等，%表示任意字符
“name$”:”%m%”，对应SQL是name LIKE &#39;%m%&#39;，查询name包含”m”的一个User数组


正则匹配
“key“:”正则表达式”  &#x3D;&gt;  “key“:[“正则表达式”]，任意正则表达式字符串，如 ^[0-9]+$ ，*~ 忽略大小写，可用于高级搜索
“name~”:”^[0-9]+$”，对应SQL是name REGEXP &#39;^[0-9]+$&#39;，查询name中字符全为数字的一个User数组


连续范围
“key%”:”start,end”  &#x3D;&gt;  “key%”:[“start,end”]，其中 start 和 end 都只能为 Boolean, Number, String 中的一种，如 “2017-01-01,2019-01-01” ，[“1,90000”, “82001,100000”] ，可用于连续范围内的筛选
“date%”:”2017-10-01,2018-10-01”，对应SQL是date BETWEEN &#39;2017-10-01&#39; AND &#39;2018-10-01&#39;，查询在2017-10-01和2018-10-01期间注册的用户的一个User数组


新建别名
“name:alias”，name映射为alias，用alias替代name。可用于 column,Table,SQL函数 等。只用于GET类型、HEAD类型的请求
“@column”:”toId:parentId”，对应SQL是toId AS parentId，将查询的字段toId变为parentId返回


增加 或 扩展
“key+”:Object，Object的类型由key指定，且类型为Number,String,JSONArray中的一种。如 82001,”apijson”,[“url0”,”url1”] 等。只用于PUT请求
“praiseUserIdList+”:[82001]，对应SQL是json_insert(praiseUserIdList,82001)，添加一个点赞用户id，即这个用户点了赞


减少 或 去除
“key-“:Object，与”key+”相反
“balance-“:100.00，对应SQL是balance &#x3D; balance - 100.00，余额减少100.00，即花费了100元


比较运算
&gt;, &lt;, &gt;&#x3D;, &lt;&#x3D; 比较运算符，用于 ① 提供 “id{}”:”&lt;&#x3D;90000” 这种条件范围的简化写法 ② 实现子查询相关比较运算不支持 “key&#x3D;”:Object 和 “key!&#x3D;”:Object 这两种写法，直接用更简单的 “key”:Object 和 “key!”:Object 替代。
① “id&lt;&#x3D;”:90000，对应SQL是id&lt;&#x3D;90000，查询符合id&lt;&#x3D;90000的一个User数组 ② “id&gt;@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&gt;(SELECT min(userId) FROM Comment)


逻辑运算
&amp;, |, ! 逻辑运算符，对应数据库 SQL 中的 AND, OR, NOT。 横或纵与：同一键值对的值内条件默认 | 或连接，可以在 key 后加逻辑运算符来具体指定；不同键值对的条件默认 &amp; 与连接，可以用下面说明的对象关键词 @combine 来具体指定。 ① &amp; 可用于”key&amp;{}”:”条件”等② | 可用于”key|{}”:”条件”, “key|{}”:[]等，一般可省略③ ! 可单独使用，如”key!”:Object，也可像&amp;,|一样配合其他功能符使用  “key!”:null 无效，null 值会导致整个键值对被忽略解析，可以用 “key{}”:”!&#x3D;null” 替代，“key”:null 同理，用 “key{}”:”&#x3D;null” 替代。
① “id&amp;{}”:”&gt;80000,&lt;&#x3D;90000”，对应SQL是id&gt;80000 AND id&lt;&#x3D;90000，即id满足id&gt;80000 &amp; id&lt;&#x3D;90000 ② “id|{}”:”&gt;90000,&lt;&#x3D;80000”，同”id{}”:”&gt;90000,&lt;&#x3D;80000”，对应SQL是id&gt;80000 OR id&lt;&#x3D;90000，即id满足id&gt;90000 | id&lt;&#x3D;80000 ③ “id!{}”:[82001,38710]，对应SQL是id NOT IN(82001,38710)，即id满足 ! (id&#x3D;82001 | id&#x3D;38710)，可过滤黑名单的消息


数组关键词，可自定义
“key”:Object，key为 “[]”:{} 中{}内的关键词，Object的类型由key指定① “count”:Integer，查询数量，0 表示最大值，默认最大值为100 ② “page”:Integer，查询页码，从0开始，默认最大值为100，一般和count一起用③ “query”:Integer，查询内容0-对象，1-总数和分页详情，2-数据、总数和分页详情总数关键词为 total，分页详情关键词为 info， 它们都和 query 同级，通过引用赋值得到，例如  “total@”:”&#x2F;[]&#x2F;total”, “info@”:”&#x2F;[]&#x2F;info” 这里query及total仅为GET类型的请求提供方便， 一般可直接用HEAD类型的请求获取总数④ “join”:”&amp;&#x2F;Table0,&lt;&#x2F;Table1&#x2F;key1@” 或 “join”:{    “&amp;&#x2F;Table0”:{},  &#x2F;&#x2F; 支持 ON 多个字段关联,    “&lt;&#x2F;Table1&#x2F;key1@”:{  &#x2F;&#x2F; ON 只允许指定的 key1 关联      “key0”:value0,  &#x2F;&#x2F; 其它ON条件       “key2”:value2,      …       “@combine”:”…”,  &#x2F;&#x2F; 其它ON条件的组合方式       “@column”:”…”,  &#x2F;&#x2F; 外层 SELECT       “@group”:”…”,  &#x2F;&#x2F; 外层 GROUP BY       “@having”:”…”  &#x2F;&#x2F; 外层 HAVING     }}多表连接方式：  “@” - APP JOIN  “&lt;“ - LEFT JOIN  “&gt;” - RIGHT JOIN  “&amp;” - INNER JOIN  “|” - FULL JOIN   “!” - OUTER JOIN   “*” - CROSS JOIN   “^” - SIDE JOIN   “(“ - ANTI JOIN   “)” - FOREIGN JOIN 其中 @ APP JOIN 为应用层连表，会从已查出的主表里取得所有副表 key@ 关联的主表内的 refKey 作为一个数组 refKeys: [value0, value1…]，然后把原来副表 count 次查询 key&#x3D;$refKey 的 SQL 用 key IN($refKeys) 的方式合并为一条 SQL 来优化性能； 其它 JOIN 都是 SQL JOIN，具体功能和 MySQL,PostgreSQL 等数据库的 JOIN 一一对应 &quot;join&quot;:&quot;&lt;&#x2F;ViceTable&#x2F;key@&quot;,&quot;MainTable&quot;:{},&quot;ViceTable&quot;:{&quot;key@&quot;:&quot;&#x2F;MainTable&#x2F;refKey&quot;}会对应生成 MainTable LEFT JOIN ViceTable ON ViceTable.key&#x3D;MainTable.refKey AND 其它ON条件  除了 &#x3D; 等价关联，也支持 ! 不等关联、&gt; &lt; &gt;&#x3D; &lt;&#x3D; 等比较关联和 $ ~ {} &lt;&gt; 等其它复杂关联方式 ⑤ “otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 查询User数组，最多5个：“count”:5对应SQL是LIMIT 5  ② 查询第3页的User数组，每页5个：“count”:5,“page”:3对应SQL是LIMIT 5 OFFSET 15  ③ 查询User数组和对应的User总数：“[]”:{    “query”:2,    “User”:{}},“total@”:”&#x2F;[]&#x2F;total”,“info@”:”&#x2F;[]&#x2F;info” 返回的数据中，总数及分页详情结构为：   “total”:139,  &#x2F;&#x2F;总数  “info”:{  &#x2F;&#x2F;分页详情     “total”:139,  &#x2F;&#x2F;总数     “count”:5,  &#x2F;&#x2F;每页数量     “page”:0,  &#x2F;&#x2F;当前页码     “max”:27,  &#x2F;&#x2F;最大页码     “more”:true,  &#x2F;&#x2F;是否还有更多     “first”:true,  &#x2F;&#x2F;是否为首页     “last”:false  &#x2F;&#x2F;是否为尾页 }  ④ Moment INNER JOIN User LEFT JOIN Comment：“[]”:{    “join”:”&amp;&#x2F;User&#x2F;id@,&lt;&#x2F;Comment”,    “Moment”:{     “@group”:”id”  &#x2F;&#x2F;主副表不是一对一，要去除重复数据   },    “User”:{      “name~”:”t”,      “id@”:”&#x2F;Moment&#x2F;userId”    },    “Comment”:{      “momentId@”:”&#x2F;Moment&#x2F;id”    }} ⑤ 每一层都加当前用户名：“User”:{},“[]”:{    “name@”:”User&#x2F;name”, &#x2F;&#x2F;自定义关键词    “Moment”:{}}


对象关键词，可自定义
“@key”:Object，@key为 Table:{} 中{}内的关键词，Object的类型由@key指定① “@combine”:”key0 | (key1 &amp; (key2 | !key3))…”，条件组合方式，最终按  (其它key条件 AND 连接) AND (key0条件 OR (key1条件 AND (key2条件 OR (NOT key3条件)))) 这种方式连接，其中 “其它key” 是指与 @combine 在同一对象，且未被它声明的条件 key，默认都是 &amp; 连接。注意不要缺少或多余任何一个空格。 ② “@column”:”column;function(arg)…”，返回字段③ “@order”:”column0+,column1-…”，排序方式④ “@group”:”column0,column1…”，分组方式。如果@column里声明了Table的id，则id也必须在@group中声明；其它情况下必须满足至少一个条件:1.分组的key在@column里声明2.Table主键在@group中声明 ⑤ “@having”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…” &#x2F;&#x2F; OR 连接，或 “@having&amp;”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…”  &#x2F;&#x2F; AND 连接，或 “@having”:{   “h0”:”function0(…)?value0”,   “h1”:function1(…)?value1”,   “h2”:function2(…)?value2…”,   “@combine”:”h0 &amp; (h1 | !h2)”  &#x2F;&#x2F; 任意组合，非必传}SQL函数条件，一般和@group一起用，函数一般在@column里声明⑥ “@schema”:”sys”，集合空间(数据库名&#x2F;模式)，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑦ “@database”:”POSTGRESQL”，数据库类型，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑧ “@datasource”:”DRUID”，跨数据源，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑨ “@json”:”key0,key1…”，转为 JSON 格式返回，符合 JSONObject 则转为 {…}，符合 JSONArray 则转为 […] ⑩ “@role”:”OWNER”，来访角色，包括UNKNOWN,LOGIN,CONTACT,CIRCLE,OWNER,ADMIN，可以在最外层作为全局默认配置，可自定义其它角色并重写 Verifier.verify 等相关方法来自定义校验 ⑪ “@explain”:true，性能分析，可以在最外层作为全局默认配置 ⑫ “@raw”:”key0,key1…”，其中 key0, key1 都对应有键值对 “key0”:”SQL片段或SQL片段的别名”,  “key1”:”SQL片段或SQL片段的别名”  自定义原始SQL片段，可扩展嵌套SQL函数等复杂语句，必须是后端已配置的，只有其它功能符都做不到才考虑，谨慎使用，注意防SQL注入⑬ “@otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 搜索name或tag任何一个字段包含字符a的User列表： “name“:”a”,“tag“:”a”,“@combine”:”name~ | tag~” 对应SQL是name REGEXP &#39;a&#39; OR tag REGEXP &#39;a&#39;  ② 只查询id,sex,name这几列并且请求结果也按照这个顺序：“@column”:”id,sex,name”对应SQL是SELECT id,sex,name  ③ 查询按 name降序、id默认顺序 排序的User数组：“@order”:”name-,id”对应SQL是ORDER BY name DESC,id  ④ 查询按userId分组的Moment数组：“@group”:”userId,id”对应SQL是GROUP BY userId,id  ⑤ 查询 按userId分组、id最大值&gt;&#x3D;100 的Moment数组：“@column”:”userId;max(id)”,“@group”:”userId”,“@having”:”max(id)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) ... GROUP BY userId HAVING max(id)&gt;&#x3D;100 还可以指定函数返回名：“@column”:”userId;max(id):maxId”,“@group”:”userId”,“@having”:”(maxId)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) AS maxId ... GROUP BY userId HAVING (maxId)&gt;&#x3D;100  ⑥ 查询 sys 内的 User 表：“@schema”:”sys”对应SQL是FROM sys.User  ⑦ 查询 PostgreSQL 数据库的 User 表：“@database”:”POSTGRESQL” ⑧ 使用 Druid 连接池查询 User 表：“@datasource”:”DRUID” ⑨ 将 VARCHAR 字符串字段 get 转为 JSONArray 返回：“@json”:”get” ⑩ 查询当前用户的动态：“@role”:”OWNER” ⑪ 开启性能分析：“@explain”:true对应SQL是EXPLAIN  ⑫ 统计最近一周偶数userId的数量“@column”:”date;left(date,10):day;sum(if(userId%2&#x3D;0,1,0))”,“@group”:”day”,“@having”:”to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7”,“@raw”:”@column,@having”对应SQL是SELECT date, left(date,10) AS day, sum(if(userId%2&#x3D;0,1,0)) ... GROUP BY day HAVING to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7  ⑬ 从pictureList获取第0张图片：“@position”:0, &#x2F;&#x2F;自定义关键词“firstPicture()”:”getFromArray(pictureList,@position)”


全局关键词
为最外层对象 {} 内的关键词。其中 @database，@schema, @datasource, @role, @explain 基本同对象关键词，见上方说明，区别是全局关键词会每个表对象中没有时自动放入，作为默认值。 ① “tag”:String，后面的 tag 是非 GET、HEAD 请求中匹配请求的 JSON 结构的标识，一般是要查询的 Table 的名称或该名称对应的数组 Table[] 或 Table:[]，由后端 Request 表中指定。 ② “version”:Integer，接口版本，version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本，由后端 Request 表中指定。③ “format”:Boolean，格式化返回 Response JSON 的 key，一般是将 TableName 转为 tableName, TableName[] 转为 tableNameList, Table:alias 转为 alias, TableName-key[] 转为 tableNameKeyList 等小驼峰格式。
①  查隐私信息：[{“tag”:”Privacy”,”Privacy”:{“id”:82001}}](http:&#x2F;&#x2F;apijson.cn&#x2F;api?url&#x3D;http%3A%2F%2Fapijson.cn%3A8080%2Fgets&amp;type&#x3D;JSON&amp;json&#x3D;


</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2.1"><span class="toc-number">1.6.2.</span> <span class="toc-text">2.1 开发流程


开发流程
传统方式
APIJSON



接口传输
等后端编辑接口，然后更新文档，前端再按照文档编辑请求和解析代码
前端按照自己的需求编辑请求和解析代码。没有接口，更不需要文档！前端再也不用和后端沟通接口或文档问题了！


兼容旧版
后端增加新接口，用v2表示第2版接口，然后更新文档
什么都不用做！


 
 
2.2 前端请求


前端请求
传统方式
APIJSON



要求
前端按照文档在对应URL后面拼接键值对
前端按照自己的需求在固定URL后拼接JSON


URL
不同的请求对应不同的URL，基本上有多少个不同的请求就得有多少个接口URL
相同的操作方法(增删改查)都用同一个URL，大部分请求都用7个通用接口URL的其中一个


键值对
key&#x3D;value
key:value


结构
同一个URL内table_name只能有一个  base_url&#x2F;get&#x2F;table_name?key0&#x3D;value0&amp;key1&#x3D;value1…
同一个URL后TableName可传任意数量个  base_url&#x2F;get&#x2F;{    TableName0:{      key0:value0,      key1:value1,      …    },    TableName1:{      …    }    … }


 
 
2.3 后端操作


后端操作
传统方式
APIJSON



解析和返回
取出键值对，把键值对作为条件用预设的的方式去查询数据库，最后封装JSON并返回给前端
把Parser#parse方法的返回值返回给前端就行


返回JSON结构的设定方式
由后端设定，前端不能修改
由前端设定，后端不能修改


 
 
2.4 前端解析


前端解析
传统方式
APIJSON



查看方式
查文档或问后端，或等请求成功后看日志
看请求就行，所求即所得，不用查、不用问、不用等。也可以等请求成功后看日志


解析方法
用JSON解析器来解析JSONObject
可以用JSONResponse解析JSONObject，或使用传统方式


 
 
2.5 前端对应不同需求的请求


前端的请求
传统方式
APIJSON



User
base_url&#x2F;get&#x2F;user?id&#x3D;38710
base_url&#x2F;get&#x2F;{    “User”:{      “id”:38710    }}


Moment和对应的User
分两次请求Moment:  base_url&#x2F;get&#x2F;moment?userId&#x3D;38710User:  base_url&#x2F;get&#x2F;user?id&#x3D;38710
base_url&#x2F;get&#x2F;{    “Moment”:{      “userId”:38710    },     “User”:{      “id”:38710    }}


User列表
base_url&#x2F;get&#x2F;user&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;sex&#x3D;0
base_url&#x2F;get&#x2F;{    “User[]”:{      “page”:0,       “count”:3,       “User”:{        “sex”:0      }    }}


Moment列表，每个Moment包括1.发布者User2.前3条Comment
Moment里必须有1.User对象2.Comment数组 base_url&#x2F;get&#x2F;moment&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;commentCount&#x3D;3
base_url&#x2F;get&#x2F;{    “[]”:{      “page”:0,       “count”:3,       “Moment”:{},       “User”:{        “id@”:”&#x2F;Moment&#x2F;userId”      },      “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }}


User发布的Moment列表， 每个Moment包括 1.发布者User 2.前3条Comment
1.Moment里必须有User对象和Comment数组 2.字段名必须查接口文档，例如评论数量字段名可能是 commentCount,comment_count或者简写cmt_count等各种奇葩写法…  base_url&#x2F;get&#x2F;moment&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;commentCount&#x3D;3&amp;userId&#x3D;38710
有以下几种方式: ① 把以上请求里的“Moment”:{}, “User”:{“id@”:”&#x2F;Moment&#x2F;userId”}改为“Moment”:{“userId”:38710}, “User”:{“id”:38710}  ② 或把User放在上面的最外层省去重复的Userbase_url&#x2F;get&#x2F;{    “User”:{      “id”:38710    },    “[]”:{      “page”:0,      “count”:3,       “Moment”:{        “userId”:38710      },       “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }} ③ 如果User之前已经获取到了，还可以不传User来节省请求和返回数据的流量并提升速度base_url&#x2F;get&#x2F;{    “[]”:{      “page”:0,      “count”:3,       “Moment”:{        “userId”:38710      },      “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }}


 
 
2.6 后端对应不同请求的返回结果


后端的返回结果
传统方式
APIJSON



User
{    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
{    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


Moment和对应的User
分别返回两次请求的结果，获取到Moment后取出userId作为User的id条件去查询User  Moment:  {    “data”:{      “id”:235,      “content”:”xxx”,      …    },    “code”:200,    “msg”:”success”}  User:  {    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
一次性返回，没有传统方式导致的 长时间等待结果、两次结果间关联、线程多次切换 等问题  {    “Moment”:{      “id”:235,      “content”:”xxx”,      …    },    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


User列表
{    “data”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}
{    “User[]”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}


Moment列表，每个Moment包括发布者User和前3条Comment
Moment里必须有1.User对象2.Comment数组  {    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          …        },        “Comment”:[          …        ]      },      {        “id”:301,        “content”:”xxx”,        …,        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}
1.高灵活，可任意组合2.低耦合，逻辑很清晰{    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          …        },        “Comment[]”:[          …        ]      },      {        “Moment”:{          “id”:301,          “content”:”xxx”,          …        },        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}


User发布的Moment列表，每个Moment包括发布者User和前3条Comment
1.大量重复User，浪费流量和服务器性能2.优化很繁琐，需要后端扩展接口、写好文档，前端&#x2F;前端再配合优化{    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:470,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:511,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:595,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      …    ],    “code”:200,    “msg”:”success”}
以上不同请求方式的结果: ① 常规请求  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ② 省去重复的User  {    “User”:{      “id”:38710,      “name”:”Tommy”,      …    },    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ③ 不查询已获取到的User  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”}


1.base_url指基地址，一般是顶级域名，其它分支url都是在base_url后扩展。如base_url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F; ，对应的GET分支url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F;get&#x2F; 。下同。2.请求中的key或value任意一个为null值时，这个 key:value键值对 被视为无效。下同。3.请求中的 &#x2F; 需要转义。JSONRequest.java已经用URLEncoder.encode转义，不需要再写；但如果是浏览器或Postman等直接输入url&#x2F;request，需要把request中的所有 &#x2F; 都改成 %252F 。下同。4.code，指返回结果中的状态码，200表示成功，其它都是错误码，值全部都是HTTP标准状态码。下同。5.msg，指返回结果中的状态信息，对成功结果或错误原因的详细说明。下同。6.code和msg总是在返回结果的同一层级成对出现。对所有请求的返回结果都会在最外层有一对总结式code和msg。下同。7.id等字段对应的值仅供说明，不一定是数据库里存在的，请求里用的是真实存在的值。下同。



3.设计规范3.1 操作方法


方法及说明
URL
Request
Response



GET:  普通获取数据， 可用浏览器调试
base_url&#x2F;get&#x2F;
{    TableName:{      …     }}  {…}内为限制条件 例如获取一个 id &#x3D; 235 的 Moment： {    “Moment”:{      “id”:235    }}  后端校验通过后自动解析为 SQL 并执行：SELECT * FROM Moment WHERE id&#x3D;235 LIMIT 1
{    TableName:{      …    },    “code”:200,    “msg”:”success”}例如{    “Moment”:{      “id”:235,      “userId”:38710,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “code”:200,    “msg”:”success” }


HEAD:  普通获取数量， 可用浏览器调试
base_url&#x2F;head&#x2F;
{    TableName:{      …    } }  {…}内为限制条件  例如获取一个 id &#x3D; 38710 的 User 所发布的 Moment 总数： {    “Moment”:{      “userId”:38710    }}  后端校验通过后自动解析为 SQL 并执行：SELECT count(*) FROM Moment WHERE userId&#x3D;38710 LIMIT 1
{    TableName:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,    “msg”:”success”}  例如{    “Moment”:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,     “msg”:”success”}


GETS:  安全&#x2F;私密获取数据， 用于获取钱包等对安全性要求高的数据
base_url&#x2F;gets&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Privacy”，其它同GET
同GET


HEADS:  安全&#x2F;私密获取数量， 用于获取银行卡数量等对安全性要求高的数据总数
base_url&#x2F;heads&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Verify”，其它同HEAD
同HEAD


POST:  新增数据
base_url&#x2F;post&#x2F;
单个：  {    TableName:{      …    },    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 38710 发布一个新 Comment：{    “Comment”:{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”     },    “tag”:”Comment”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(38710,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;)    批量：  {    TableName[]:[{        …      }, {        …      }      …    ],    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 82001 发布 2 个 Comment：{    “Comment[]”:[{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”      }, {      “momentId”:15,      “content”:”APIJSON is a JSON transmision protocol.”    }],    “tag”:”Comment:[]”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(82001,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;);INSERT INTO Comment(userId,momentId,content) VALUES(82001,15,&#39;APIJSON is a JSON transmision protocol.&#39;);
单个：  {    TableName:{      “code”:200,      “msg”:”success”,      “id”:38710    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “id”:120    },    “code”:200,    “msg”:”success”}   批量：  {    TableName:{      “code”:200,      “msg”:”success”,      “count”:5,      “id[]”:[1, 2, 3, 4, 5]    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “count”:2,      “id[]”:[1, 2]    },    “code”:200,    “msg”:”success”}


PUT:  修改数据， 只修改所传的字段
base_url&#x2F;put&#x2F;
{    TableName:{      “id”:id,      …    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个 例如当前登录用户 82001 修改 id &#x3D; 235 的 Moment 的 content：{    “Moment”:{      “id”:235,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “tag”:”Moment”}  后端校验通过后自动解析为 SQL 并执行：UPDATE Moment SET content&#x3D;&#39;APIJSON,let interfaces and documents go to hell !&#39; WHERE id&#x3D;235 AND userId&#x3D;82001 LIMIT 1  批量除了 id{}:[] 也可类似批量 POST，只是每个 {…} 里面都必须有 id。“tag”:”Comment[]” 对应对象 “Comment”:{“id{}”:[1,2,3]}，表示指定记录全部统一设置；“tag”:”Comment:[]” 多了冒号，对应数组 “Comment[]”:[{“id”:1},{“id”:2},{“id”:3}]，表示每项单独设置
同POST


DELETE:  删除数据
base_url&#x2F;delete&#x2F;
{    TableName:{      “id”:id    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个，一般只传 id 或 id{} 例如当前登录用户 82001 批量删除 id &#x3D; 100,110,120 的 Comment：{    “Comment”:{      “id{}”:[100,110,120]    },    “tag”:”Comment[]”}  后端校验通过后自动解析为 SQL 并执行：DELETE FROM Comment WHERE id IN(100,110,120) AND userId&#x3D;82001 LIMIT 3
{    TableName:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120]      “count”:3    },    “code”:200,    “msg”:”success”}例如{   “Comment”:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120],      “count”:3   },   “code”:200,   “msg”:”success”}


以上接口的简单形式:  base_url&#x2F;{method}&#x2F;{tag}
GET: 普通获取数据  base_url&#x2F;get&#x2F;{tag}  HEAD: 普通获取数量  base_url&#x2F;head&#x2F;{tag}  GETS: 安全&#x2F;私密获取数据   base_url&#x2F;gets&#x2F;{tag}  HEADS: 安全&#x2F;私密获取数量  base_url&#x2F;heads&#x2F;{tag}  POST: 新增数据   base_url&#x2F;post&#x2F;{tag}  PUT: 修改数据  base_url&#x2F;put&#x2F;{tag}  DELETE: 删除数据  base_url&#x2F;delete&#x2F;{tag}
例如安全&#x2F;私密获取一个 id &#x3D; 82001 的 Privacy： base_url&#x2F;gets&#x2F;Privacy&#x2F;  {“id”:82001}  相当于  base_url&#x2F;gets&#x2F; {“tag”:”Privacy”, “Privacy”:{“id”:82001}}   例如批量修改 id &#x3D; 114, 124 的 Comment 的 content：base_url&#x2F;put&#x2F;Comemnt[]&#x2F;  {    “id{}”:[114,124],    “content”:”test multi put”}  相当于  base_url&#x2F;put&#x2F;  {    “tag”:”Comment[]”,     “Comment”:{      “id{}”:[114,124],      “content”:”test multi put”    }}
同以上对应的方法


1.TableName指要查询的数据库表Table的名称字符串。第一个字符为大写字母，剩下的字符要符合英语字母、数字、下划线中的任何一种。对应的值的类型为JSONObject，结构是 {…}，里面放的是Table的字段(列名)。下同。2.”tag”:tag 后面的tag是非GET、HEAD请求中匹配请求的JSON结构的标识，一般是要查询的Table的名称，由后端Request表中指定。下同。3.GET、HEAD请求是开放请求，可任意组合任意嵌套。其它请求为受限制的安全&#x2F;私密请求，对应的 方法（method）, 标识（tag）, 版本（version）, 结构（structure） 都必须和 后端Request表中所指定的 一一对应，否则请求将不被通过。version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本。下同。4.GETS与GET、HEADS与HEAD分别为同一类型的操作方法，请求稍有不同但返回结果相同。下同。5.在HTTP通信中，自动化接口(get,gets,head,heads,post,put,delete) 全用HTTP POST请求。下同。6.所有JSONObject都视为容器(或者文件夹)，结构为 {…} ，里面可以放普通对象或子容器。下同。7.每个对象都有一个唯一的路径(或者叫地址)，假设对象名为refKey，则用 key0&#x2F;key1&#x2F;…&#x2F;refKey 表示。下同。


3.2 功能符


功能
键值对格式
使用示例



查询数组
“key[]”:{}，后面是JSONObject，key可省略。当key和里面的Table名相同时，Table会被提取出来，即 {Table:{Content}} 会被转化为 {Content}
{“User[]”:{“User”:{}}}，查询一个User数组。这里key和Table名都是User，User会被提取出来，即 {“User”:{“id”, …}} 会被转化为 {“id”, …}，如果要进一步提取User中的id，可以把User[]改为User-id[]


匹配选项范围
“key{}”:[]，后面是JSONArray，作为key可取的值的选项
“id{}”:[38710,82001,70793]，对应SQL是id IN(38710,82001,70793)，查询id符合38710,82001,70793中任意一个的一个User数组


匹配条件范围
“key{}”:”条件0,条件1…”，条件为SQL表达式字符串，可进行数字比较运算等
“id{}”:”&lt;&#x3D;80000,&gt;90000”，对应SQL是id&lt;&#x3D;80000 OR id&gt;90000，查询id符合id&lt;&#x3D;80000 | id&gt;90000的一个User数组


包含选项范围
“key&lt;&gt;“:Object  &#x3D;&gt;  “key&lt;&gt;“:[Object]，key对应值的类型必须为JSONArray，Object类型不能为JSON
“contactIdList&lt;&gt;“:38710，对应SQL是json_contains(contactIdList,38710)，查询contactIdList包含38710的一个User数组


判断是否存在
“key}{@”:{    “from”:”Table”,    “Table”:{ … }}其中：}{ 表示 EXISTS； key 用来标识是哪个判断； @ 后面是 子查询 对象，具体见下方 子查询 的说明。
“id}{@”:{    “from”:”Comment”,    “Comment”:{        “momentId”:15     }} WHERE EXISTS(SELECT * FROM Comment WHERE momentId&#x3D;15)


远程调用函数
“key()”:”函数表达式”，函数表达式为 function(key0,key1…)，会调用后端对应的函数 function(JSONObject request, String key0, String key1…)，实现 参数校验、数值计算、数据同步、消息推送、字段拼接、结构变换 等特定的业务逻辑处理，可使用 - 和 + 表示优先级，解析 key-() &gt; 解析当前对象 &gt; 解析 key() &gt; 解析子对象 &gt; 解析 key+()
“isPraised()”:”isContain(praiseUserIdList,userId)”，会调用远程函数 boolean isContain(JSONObject request, String array, String value) ，然后变为 “isPraised”:true 这种（假设点赞用户id列表包含了userId，即这个User点了赞）


存储过程
“@key()”:”SQL函数表达式”，函数表达式为   function(key0,key1…)  会调用后端数据库对应的存储过程 SQL函数  function(String key0, String key1…)  除了参数会提前赋值，其它和 远程函数 一致
“@limit”:10,  “@offset”:0,  “@procedure()”:”getCommentByUserId(id,@limit,@offset)”  会转为  getCommentByUserId(38710,10,0)  来调用存储过程 SQL 函数  getCommentByUserId(IN id bigint, IN limit int, IN offset int)  然后变为 “procedure”:{    “count”:-1,     “update”:false,     “list”:[]  }  其中 count 是指写操作影响记录行数，-1 表示不是写操作；update 是指是否为写操作（增删改）；list 为返回结果集


引用赋值
“key@”:”key0&#x2F;key1&#x2F;…&#x2F;refKey”，引用路径为用&#x2F;分隔的字符串。以&#x2F;开头的是缺省引用路径，从声明key所处容器的父容器路径开始；其它是完整引用路径，从最外层开始。 被引用的refKey必须在声明key的上面。如果对refKey的容器指定了返回字段，则被引用的refKey必须写在@column对应的值内，例如 “@column”:”refKey,key1,…”
“Moment”:{    “userId”:38710},“User”:{    “id@”:”&#x2F;Moment&#x2F;userId”} User内的id引用了与User同级的Moment内的userId，即User.id &#x3D; Moment.userId，请求完成后 “id@”:”&#x2F;Moment&#x2F;userId” 会变成 “id”:38710


子查询
“key@”:{    “range”:”ALL”,     “from”:”Table”,    “Table”:{ … }}其中：range 可为 ALL,ANY；from 为目标表 Table 的名称；@ 后面的对象类似数组对象，可使用 count 和 join 等功能。
“id@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&#x3D;(SELECT min(userId) FROM Comment)


模糊搜索
&quot;key$&quot;:&quot;SQL搜索表达式&quot;  &#x3D;&gt;  &quot;key$&quot;:[&quot;SQL搜索表达式&quot;]，任意SQL搜索表达式字符串，如 %key%(包含key), key%(以key开始), %k%e%y%(包含字母k,e,y) 等，%表示任意字符
“name$”:”%m%”，对应SQL是name LIKE &#39;%m%&#39;，查询name包含”m”的一个User数组


正则匹配
“key“:”正则表达式”  &#x3D;&gt;  “key“:[“正则表达式”]，任意正则表达式字符串，如 ^[0-9]+$ ，*~ 忽略大小写，可用于高级搜索
“name~”:”^[0-9]+$”，对应SQL是name REGEXP &#39;^[0-9]+$&#39;，查询name中字符全为数字的一个User数组


连续范围
“key%”:”start,end”  &#x3D;&gt;  “key%”:[“start,end”]，其中 start 和 end 都只能为 Boolean, Number, String 中的一种，如 “2017-01-01,2019-01-01” ，[“1,90000”, “82001,100000”] ，可用于连续范围内的筛选
“date%”:”2017-10-01,2018-10-01”，对应SQL是date BETWEEN &#39;2017-10-01&#39; AND &#39;2018-10-01&#39;，查询在2017-10-01和2018-10-01期间注册的用户的一个User数组


新建别名
“name:alias”，name映射为alias，用alias替代name。可用于 column,Table,SQL函数 等。只用于GET类型、HEAD类型的请求
“@column”:”toId:parentId”，对应SQL是toId AS parentId，将查询的字段toId变为parentId返回


增加 或 扩展
“key+”:Object，Object的类型由key指定，且类型为Number,String,JSONArray中的一种。如 82001,”apijson”,[“url0”,”url1”] 等。只用于PUT请求
“praiseUserIdList+”:[82001]，对应SQL是json_insert(praiseUserIdList,82001)，添加一个点赞用户id，即这个用户点了赞


减少 或 去除
“key-“:Object，与”key+”相反
“balance-“:100.00，对应SQL是balance &#x3D; balance - 100.00，余额减少100.00，即花费了100元


比较运算
&gt;, &lt;, &gt;&#x3D;, &lt;&#x3D; 比较运算符，用于 ① 提供 “id{}”:”&lt;&#x3D;90000” 这种条件范围的简化写法 ② 实现子查询相关比较运算不支持 “key&#x3D;”:Object 和 “key!&#x3D;”:Object 这两种写法，直接用更简单的 “key”:Object 和 “key!”:Object 替代。
① “id&lt;&#x3D;”:90000，对应SQL是id&lt;&#x3D;90000，查询符合id&lt;&#x3D;90000的一个User数组 ② “id&gt;@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&gt;(SELECT min(userId) FROM Comment)


逻辑运算
&amp;, |, ! 逻辑运算符，对应数据库 SQL 中的 AND, OR, NOT。 横或纵与：同一键值对的值内条件默认 | 或连接，可以在 key 后加逻辑运算符来具体指定；不同键值对的条件默认 &amp; 与连接，可以用下面说明的对象关键词 @combine 来具体指定。 ① &amp; 可用于”key&amp;{}”:”条件”等② | 可用于”key|{}”:”条件”, “key|{}”:[]等，一般可省略③ ! 可单独使用，如”key!”:Object，也可像&amp;,|一样配合其他功能符使用  “key!”:null 无效，null 值会导致整个键值对被忽略解析，可以用 “key{}”:”!&#x3D;null” 替代，“key”:null 同理，用 “key{}”:”&#x3D;null” 替代。
① “id&amp;{}”:”&gt;80000,&lt;&#x3D;90000”，对应SQL是id&gt;80000 AND id&lt;&#x3D;90000，即id满足id&gt;80000 &amp; id&lt;&#x3D;90000 ② “id|{}”:”&gt;90000,&lt;&#x3D;80000”，同”id{}”:”&gt;90000,&lt;&#x3D;80000”，对应SQL是id&gt;80000 OR id&lt;&#x3D;90000，即id满足id&gt;90000 | id&lt;&#x3D;80000 ③ “id!{}”:[82001,38710]，对应SQL是id NOT IN(82001,38710)，即id满足 ! (id&#x3D;82001 | id&#x3D;38710)，可过滤黑名单的消息


数组关键词，可自定义
“key”:Object，key为 “[]”:{} 中{}内的关键词，Object的类型由key指定① “count”:Integer，查询数量，0 表示最大值，默认最大值为100 ② “page”:Integer，查询页码，从0开始，默认最大值为100，一般和count一起用③ “query”:Integer，查询内容0-对象，1-总数和分页详情，2-数据、总数和分页详情总数关键词为 total，分页详情关键词为 info， 它们都和 query 同级，通过引用赋值得到，例如  “total@”:”&#x2F;[]&#x2F;total”, “info@”:”&#x2F;[]&#x2F;info” 这里query及total仅为GET类型的请求提供方便， 一般可直接用HEAD类型的请求获取总数④ “join”:”&amp;&#x2F;Table0,&lt;&#x2F;Table1&#x2F;key1@” 或 “join”:{    “&amp;&#x2F;Table0”:{},  &#x2F;&#x2F; 支持 ON 多个字段关联,    “&lt;&#x2F;Table1&#x2F;key1@”:{  &#x2F;&#x2F; ON 只允许指定的 key1 关联      “key0”:value0,  &#x2F;&#x2F; 其它ON条件       “key2”:value2,      …       “@combine”:”…”,  &#x2F;&#x2F; 其它ON条件的组合方式       “@column”:”…”,  &#x2F;&#x2F; 外层 SELECT       “@group”:”…”,  &#x2F;&#x2F; 外层 GROUP BY       “@having”:”…”  &#x2F;&#x2F; 外层 HAVING     }}多表连接方式：  “@” - APP JOIN  “&lt;“ - LEFT JOIN  “&gt;” - RIGHT JOIN  “&amp;” - INNER JOIN  “|” - FULL JOIN   “!” - OUTER JOIN   “*” - CROSS JOIN   “^” - SIDE JOIN   “(“ - ANTI JOIN   “)” - FOREIGN JOIN 其中 @ APP JOIN 为应用层连表，会从已查出的主表里取得所有副表 key@ 关联的主表内的 refKey 作为一个数组 refKeys: [value0, value1…]，然后把原来副表 count 次查询 key&#x3D;$refKey 的 SQL 用 key IN($refKeys) 的方式合并为一条 SQL 来优化性能； 其它 JOIN 都是 SQL JOIN，具体功能和 MySQL,PostgreSQL 等数据库的 JOIN 一一对应 &quot;join&quot;:&quot;&lt;&#x2F;ViceTable&#x2F;key@&quot;,&quot;MainTable&quot;:{},&quot;ViceTable&quot;:{&quot;key@&quot;:&quot;&#x2F;MainTable&#x2F;refKey&quot;}会对应生成 MainTable LEFT JOIN ViceTable ON ViceTable.key&#x3D;MainTable.refKey AND 其它ON条件  除了 &#x3D; 等价关联，也支持 ! 不等关联、&gt; &lt; &gt;&#x3D; &lt;&#x3D; 等比较关联和 $ ~ {} &lt;&gt; 等其它复杂关联方式 ⑤ “otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 查询User数组，最多5个：“count”:5对应SQL是LIMIT 5  ② 查询第3页的User数组，每页5个：“count”:5,“page”:3对应SQL是LIMIT 5 OFFSET 15  ③ 查询User数组和对应的User总数：“[]”:{    “query”:2,    “User”:{}},“total@”:”&#x2F;[]&#x2F;total”,“info@”:”&#x2F;[]&#x2F;info” 返回的数据中，总数及分页详情结构为：   “total”:139,  &#x2F;&#x2F;总数  “info”:{  &#x2F;&#x2F;分页详情     “total”:139,  &#x2F;&#x2F;总数     “count”:5,  &#x2F;&#x2F;每页数量     “page”:0,  &#x2F;&#x2F;当前页码     “max”:27,  &#x2F;&#x2F;最大页码     “more”:true,  &#x2F;&#x2F;是否还有更多     “first”:true,  &#x2F;&#x2F;是否为首页     “last”:false  &#x2F;&#x2F;是否为尾页 }  ④ Moment INNER JOIN User LEFT JOIN Comment：“[]”:{    “join”:”&amp;&#x2F;User&#x2F;id@,&lt;&#x2F;Comment”,    “Moment”:{     “@group”:”id”  &#x2F;&#x2F;主副表不是一对一，要去除重复数据   },    “User”:{      “name~”:”t”,      “id@”:”&#x2F;Moment&#x2F;userId”    },    “Comment”:{      “momentId@”:”&#x2F;Moment&#x2F;id”    }} ⑤ 每一层都加当前用户名：“User”:{},“[]”:{    “name@”:”User&#x2F;name”, &#x2F;&#x2F;自定义关键词    “Moment”:{}}


对象关键词，可自定义
“@key”:Object，@key为 Table:{} 中{}内的关键词，Object的类型由@key指定① “@combine”:”key0 | (key1 &amp; (key2 | !key3))…”，条件组合方式，最终按  (其它key条件 AND 连接) AND (key0条件 OR (key1条件 AND (key2条件 OR (NOT key3条件)))) 这种方式连接，其中 “其它key” 是指与 @combine 在同一对象，且未被它声明的条件 key，默认都是 &amp; 连接。注意不要缺少或多余任何一个空格。 ② “@column”:”column;function(arg)…”，返回字段③ “@order”:”column0+,column1-…”，排序方式④ “@group”:”column0,column1…”，分组方式。如果@column里声明了Table的id，则id也必须在@group中声明；其它情况下必须满足至少一个条件:1.分组的key在@column里声明2.Table主键在@group中声明 ⑤ “@having”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…” &#x2F;&#x2F; OR 连接，或 “@having&amp;”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…”  &#x2F;&#x2F; AND 连接，或 “@having”:{   “h0”:”function0(…)?value0”,   “h1”:function1(…)?value1”,   “h2”:function2(…)?value2…”,   “@combine”:”h0 &amp; (h1 | !h2)”  &#x2F;&#x2F; 任意组合，非必传}SQL函数条件，一般和@group一起用，函数一般在@column里声明⑥ “@schema”:”sys”，集合空间(数据库名&#x2F;模式)，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑦ “@database”:”POSTGRESQL”，数据库类型，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑧ “@datasource”:”DRUID”，跨数据源，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑨ “@json”:”key0,key1…”，转为 JSON 格式返回，符合 JSONObject 则转为 {…}，符合 JSONArray 则转为 […] ⑩ “@role”:”OWNER”，来访角色，包括UNKNOWN,LOGIN,CONTACT,CIRCLE,OWNER,ADMIN，可以在最外层作为全局默认配置，可自定义其它角色并重写 Verifier.verify 等相关方法来自定义校验 ⑪ “@explain”:true，性能分析，可以在最外层作为全局默认配置 ⑫ “@raw”:”key0,key1…”，其中 key0, key1 都对应有键值对 “key0”:”SQL片段或SQL片段的别名”,  “key1”:”SQL片段或SQL片段的别名”  自定义原始SQL片段，可扩展嵌套SQL函数等复杂语句，必须是后端已配置的，只有其它功能符都做不到才考虑，谨慎使用，注意防SQL注入⑬ “@otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 搜索name或tag任何一个字段包含字符a的User列表： “name“:”a”,“tag“:”a”,“@combine”:”name~ | tag~” 对应SQL是name REGEXP &#39;a&#39; OR tag REGEXP &#39;a&#39;  ② 只查询id,sex,name这几列并且请求结果也按照这个顺序：“@column”:”id,sex,name”对应SQL是SELECT id,sex,name  ③ 查询按 name降序、id默认顺序 排序的User数组：“@order”:”name-,id”对应SQL是ORDER BY name DESC,id  ④ 查询按userId分组的Moment数组：“@group”:”userId,id”对应SQL是GROUP BY userId,id  ⑤ 查询 按userId分组、id最大值&gt;&#x3D;100 的Moment数组：“@column”:”userId;max(id)”,“@group”:”userId”,“@having”:”max(id)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) ... GROUP BY userId HAVING max(id)&gt;&#x3D;100 还可以指定函数返回名：“@column”:”userId;max(id):maxId”,“@group”:”userId”,“@having”:”(maxId)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) AS maxId ... GROUP BY userId HAVING (maxId)&gt;&#x3D;100  ⑥ 查询 sys 内的 User 表：“@schema”:”sys”对应SQL是FROM sys.User  ⑦ 查询 PostgreSQL 数据库的 User 表：“@database”:”POSTGRESQL” ⑧ 使用 Druid 连接池查询 User 表：“@datasource”:”DRUID” ⑨ 将 VARCHAR 字符串字段 get 转为 JSONArray 返回：“@json”:”get” ⑩ 查询当前用户的动态：“@role”:”OWNER” ⑪ 开启性能分析：“@explain”:true对应SQL是EXPLAIN  ⑫ 统计最近一周偶数userId的数量“@column”:”date;left(date,10):day;sum(if(userId%2&#x3D;0,1,0))”,“@group”:”day”,“@having”:”to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7”,“@raw”:”@column,@having”对应SQL是SELECT date, left(date,10) AS day, sum(if(userId%2&#x3D;0,1,0)) ... GROUP BY day HAVING to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7  ⑬ 从pictureList获取第0张图片：“@position”:0, &#x2F;&#x2F;自定义关键词“firstPicture()”:”getFromArray(pictureList,@position)”


全局关键词
为最外层对象 {} 内的关键词。其中 @database，@schema, @datasource, @role, @explain 基本同对象关键词，见上方说明，区别是全局关键词会每个表对象中没有时自动放入，作为默认值。 ① “tag”:String，后面的 tag 是非 GET、HEAD 请求中匹配请求的 JSON 结构的标识，一般是要查询的 Table 的名称或该名称对应的数组 Table[] 或 Table:[]，由后端 Request 表中指定。 ② “version”:Integer，接口版本，version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本，由后端 Request 表中指定。③ “format”:Boolean，格式化返回 Response JSON 的 key，一般是将 TableName 转为 tableName, TableName[] 转为 tableNameList, Table:alias 转为 alias, TableName-key[] 转为 tableNameKeyList 等小驼峰格式。
①  查隐私信息：[{“tag”:”Privacy”,”Privacy”:{“id”:82001}}](http:&#x2F;&#x2F;apijson.cn&#x2F;api?url&#x3D;http%3A%2F%2Fapijson.cn%3A8080%2Fgets&amp;type&#x3D;JSON&amp;json&#x3D;


</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2.1"><span class="toc-number">1.6.3.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%89%8D%E7%AB%AF%E8%AF%B7%E6%B1%82"><span class="toc-number">1.6.4.</span> <span class="toc-text">2.2 前端请求


前端请求
传统方式
APIJSON



要求
前端按照文档在对应URL后面拼接键值对
前端按照自己的需求在固定URL后拼接JSON


URL
不同的请求对应不同的URL，基本上有多少个不同的请求就得有多少个接口URL
相同的操作方法(增删改查)都用同一个URL，大部分请求都用7个通用接口URL的其中一个


键值对
key&#x3D;value
key:value


结构
同一个URL内table_name只能有一个  base_url&#x2F;get&#x2F;table_name?key0&#x3D;value0&amp;key1&#x3D;value1…
同一个URL后TableName可传任意数量个  base_url&#x2F;get&#x2F;{    TableName0:{      key0:value0,      key1:value1,      …    },    TableName1:{      …    }    … }


 
 
2.3 后端操作


后端操作
传统方式
APIJSON



解析和返回
取出键值对，把键值对作为条件用预设的的方式去查询数据库，最后封装JSON并返回给前端
把Parser#parse方法的返回值返回给前端就行


返回JSON结构的设定方式
由后端设定，前端不能修改
由前端设定，后端不能修改


 
 
2.4 前端解析


前端解析
传统方式
APIJSON



查看方式
查文档或问后端，或等请求成功后看日志
看请求就行，所求即所得，不用查、不用问、不用等。也可以等请求成功后看日志


解析方法
用JSON解析器来解析JSONObject
可以用JSONResponse解析JSONObject，或使用传统方式


 
 
2.5 前端对应不同需求的请求


前端的请求
传统方式
APIJSON



User
base_url&#x2F;get&#x2F;user?id&#x3D;38710
base_url&#x2F;get&#x2F;{    “User”:{      “id”:38710    }}


Moment和对应的User
分两次请求Moment:  base_url&#x2F;get&#x2F;moment?userId&#x3D;38710User:  base_url&#x2F;get&#x2F;user?id&#x3D;38710
base_url&#x2F;get&#x2F;{    “Moment”:{      “userId”:38710    },     “User”:{      “id”:38710    }}


User列表
base_url&#x2F;get&#x2F;user&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;sex&#x3D;0
base_url&#x2F;get&#x2F;{    “User[]”:{      “page”:0,       “count”:3,       “User”:{        “sex”:0      }    }}


Moment列表，每个Moment包括1.发布者User2.前3条Comment
Moment里必须有1.User对象2.Comment数组 base_url&#x2F;get&#x2F;moment&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;commentCount&#x3D;3
base_url&#x2F;get&#x2F;{    “[]”:{      “page”:0,       “count”:3,       “Moment”:{},       “User”:{        “id@”:”&#x2F;Moment&#x2F;userId”      },      “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }}


User发布的Moment列表， 每个Moment包括 1.发布者User 2.前3条Comment
1.Moment里必须有User对象和Comment数组 2.字段名必须查接口文档，例如评论数量字段名可能是 commentCount,comment_count或者简写cmt_count等各种奇葩写法…  base_url&#x2F;get&#x2F;moment&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;commentCount&#x3D;3&amp;userId&#x3D;38710
有以下几种方式: ① 把以上请求里的“Moment”:{}, “User”:{“id@”:”&#x2F;Moment&#x2F;userId”}改为“Moment”:{“userId”:38710}, “User”:{“id”:38710}  ② 或把User放在上面的最外层省去重复的Userbase_url&#x2F;get&#x2F;{    “User”:{      “id”:38710    },    “[]”:{      “page”:0,      “count”:3,       “Moment”:{        “userId”:38710      },       “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }} ③ 如果User之前已经获取到了，还可以不传User来节省请求和返回数据的流量并提升速度base_url&#x2F;get&#x2F;{    “[]”:{      “page”:0,      “count”:3,       “Moment”:{        “userId”:38710      },      “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }}


 
 
2.6 后端对应不同请求的返回结果


后端的返回结果
传统方式
APIJSON



User
{    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
{    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


Moment和对应的User
分别返回两次请求的结果，获取到Moment后取出userId作为User的id条件去查询User  Moment:  {    “data”:{      “id”:235,      “content”:”xxx”,      …    },    “code”:200,    “msg”:”success”}  User:  {    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
一次性返回，没有传统方式导致的 长时间等待结果、两次结果间关联、线程多次切换 等问题  {    “Moment”:{      “id”:235,      “content”:”xxx”,      …    },    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


User列表
{    “data”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}
{    “User[]”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}


Moment列表，每个Moment包括发布者User和前3条Comment
Moment里必须有1.User对象2.Comment数组  {    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          …        },        “Comment”:[          …        ]      },      {        “id”:301,        “content”:”xxx”,        …,        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}
1.高灵活，可任意组合2.低耦合，逻辑很清晰{    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          …        },        “Comment[]”:[          …        ]      },      {        “Moment”:{          “id”:301,          “content”:”xxx”,          …        },        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}


User发布的Moment列表，每个Moment包括发布者User和前3条Comment
1.大量重复User，浪费流量和服务器性能2.优化很繁琐，需要后端扩展接口、写好文档，前端&#x2F;前端再配合优化{    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:470,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:511,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:595,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      …    ],    “code”:200,    “msg”:”success”}
以上不同请求方式的结果: ① 常规请求  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ② 省去重复的User  {    “User”:{      “id”:38710,      “name”:”Tommy”,      …    },    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ③ 不查询已获取到的User  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”}


1.base_url指基地址，一般是顶级域名，其它分支url都是在base_url后扩展。如base_url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F; ，对应的GET分支url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F;get&#x2F; 。下同。2.请求中的key或value任意一个为null值时，这个 key:value键值对 被视为无效。下同。3.请求中的 &#x2F; 需要转义。JSONRequest.java已经用URLEncoder.encode转义，不需要再写；但如果是浏览器或Postman等直接输入url&#x2F;request，需要把request中的所有 &#x2F; 都改成 %252F 。下同。4.code，指返回结果中的状态码，200表示成功，其它都是错误码，值全部都是HTTP标准状态码。下同。5.msg，指返回结果中的状态信息，对成功结果或错误原因的详细说明。下同。6.code和msg总是在返回结果的同一层级成对出现。对所有请求的返回结果都会在最外层有一对总结式code和msg。下同。7.id等字段对应的值仅供说明，不一定是数据库里存在的，请求里用的是真实存在的值。下同。



3.设计规范3.1 操作方法


方法及说明
URL
Request
Response



GET:  普通获取数据， 可用浏览器调试
base_url&#x2F;get&#x2F;
{    TableName:{      …     }}  {…}内为限制条件 例如获取一个 id &#x3D; 235 的 Moment： {    “Moment”:{      “id”:235    }}  后端校验通过后自动解析为 SQL 并执行：SELECT * FROM Moment WHERE id&#x3D;235 LIMIT 1
{    TableName:{      …    },    “code”:200,    “msg”:”success”}例如{    “Moment”:{      “id”:235,      “userId”:38710,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “code”:200,    “msg”:”success” }


HEAD:  普通获取数量， 可用浏览器调试
base_url&#x2F;head&#x2F;
{    TableName:{      …    } }  {…}内为限制条件  例如获取一个 id &#x3D; 38710 的 User 所发布的 Moment 总数： {    “Moment”:{      “userId”:38710    }}  后端校验通过后自动解析为 SQL 并执行：SELECT count(*) FROM Moment WHERE userId&#x3D;38710 LIMIT 1
{    TableName:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,    “msg”:”success”}  例如{    “Moment”:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,     “msg”:”success”}


GETS:  安全&#x2F;私密获取数据， 用于获取钱包等对安全性要求高的数据
base_url&#x2F;gets&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Privacy”，其它同GET
同GET


HEADS:  安全&#x2F;私密获取数量， 用于获取银行卡数量等对安全性要求高的数据总数
base_url&#x2F;heads&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Verify”，其它同HEAD
同HEAD


POST:  新增数据
base_url&#x2F;post&#x2F;
单个：  {    TableName:{      …    },    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 38710 发布一个新 Comment：{    “Comment”:{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”     },    “tag”:”Comment”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(38710,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;)    批量：  {    TableName[]:[{        …      }, {        …      }      …    ],    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 82001 发布 2 个 Comment：{    “Comment[]”:[{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”      }, {      “momentId”:15,      “content”:”APIJSON is a JSON transmision protocol.”    }],    “tag”:”Comment:[]”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(82001,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;);INSERT INTO Comment(userId,momentId,content) VALUES(82001,15,&#39;APIJSON is a JSON transmision protocol.&#39;);
单个：  {    TableName:{      “code”:200,      “msg”:”success”,      “id”:38710    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “id”:120    },    “code”:200,    “msg”:”success”}   批量：  {    TableName:{      “code”:200,      “msg”:”success”,      “count”:5,      “id[]”:[1, 2, 3, 4, 5]    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “count”:2,      “id[]”:[1, 2]    },    “code”:200,    “msg”:”success”}


PUT:  修改数据， 只修改所传的字段
base_url&#x2F;put&#x2F;
{    TableName:{      “id”:id,      …    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个 例如当前登录用户 82001 修改 id &#x3D; 235 的 Moment 的 content：{    “Moment”:{      “id”:235,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “tag”:”Moment”}  后端校验通过后自动解析为 SQL 并执行：UPDATE Moment SET content&#x3D;&#39;APIJSON,let interfaces and documents go to hell !&#39; WHERE id&#x3D;235 AND userId&#x3D;82001 LIMIT 1  批量除了 id{}:[] 也可类似批量 POST，只是每个 {…} 里面都必须有 id。“tag”:”Comment[]” 对应对象 “Comment”:{“id{}”:[1,2,3]}，表示指定记录全部统一设置；“tag”:”Comment:[]” 多了冒号，对应数组 “Comment[]”:[{“id”:1},{“id”:2},{“id”:3}]，表示每项单独设置
同POST


DELETE:  删除数据
base_url&#x2F;delete&#x2F;
{    TableName:{      “id”:id    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个，一般只传 id 或 id{} 例如当前登录用户 82001 批量删除 id &#x3D; 100,110,120 的 Comment：{    “Comment”:{      “id{}”:[100,110,120]    },    “tag”:”Comment[]”}  后端校验通过后自动解析为 SQL 并执行：DELETE FROM Comment WHERE id IN(100,110,120) AND userId&#x3D;82001 LIMIT 3
{    TableName:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120]      “count”:3    },    “code”:200,    “msg”:”success”}例如{   “Comment”:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120],      “count”:3   },   “code”:200,   “msg”:”success”}


以上接口的简单形式:  base_url&#x2F;{method}&#x2F;{tag}
GET: 普通获取数据  base_url&#x2F;get&#x2F;{tag}  HEAD: 普通获取数量  base_url&#x2F;head&#x2F;{tag}  GETS: 安全&#x2F;私密获取数据   base_url&#x2F;gets&#x2F;{tag}  HEADS: 安全&#x2F;私密获取数量  base_url&#x2F;heads&#x2F;{tag}  POST: 新增数据   base_url&#x2F;post&#x2F;{tag}  PUT: 修改数据  base_url&#x2F;put&#x2F;{tag}  DELETE: 删除数据  base_url&#x2F;delete&#x2F;{tag}
例如安全&#x2F;私密获取一个 id &#x3D; 82001 的 Privacy： base_url&#x2F;gets&#x2F;Privacy&#x2F;  {“id”:82001}  相当于  base_url&#x2F;gets&#x2F; {“tag”:”Privacy”, “Privacy”:{“id”:82001}}   例如批量修改 id &#x3D; 114, 124 的 Comment 的 content：base_url&#x2F;put&#x2F;Comemnt[]&#x2F;  {    “id{}”:[114,124],    “content”:”test multi put”}  相当于  base_url&#x2F;put&#x2F;  {    “tag”:”Comment[]”,     “Comment”:{      “id{}”:[114,124],      “content”:”test multi put”    }}
同以上对应的方法


1.TableName指要查询的数据库表Table的名称字符串。第一个字符为大写字母，剩下的字符要符合英语字母、数字、下划线中的任何一种。对应的值的类型为JSONObject，结构是 {…}，里面放的是Table的字段(列名)。下同。2.”tag”:tag 后面的tag是非GET、HEAD请求中匹配请求的JSON结构的标识，一般是要查询的Table的名称，由后端Request表中指定。下同。3.GET、HEAD请求是开放请求，可任意组合任意嵌套。其它请求为受限制的安全&#x2F;私密请求，对应的 方法（method）, 标识（tag）, 版本（version）, 结构（structure） 都必须和 后端Request表中所指定的 一一对应，否则请求将不被通过。version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本。下同。4.GETS与GET、HEADS与HEAD分别为同一类型的操作方法，请求稍有不同但返回结果相同。下同。5.在HTTP通信中，自动化接口(get,gets,head,heads,post,put,delete) 全用HTTP POST请求。下同。6.所有JSONObject都视为容器(或者文件夹)，结构为 {…} ，里面可以放普通对象或子容器。下同。7.每个对象都有一个唯一的路径(或者叫地址)，假设对象名为refKey，则用 key0&#x2F;key1&#x2F;…&#x2F;refKey 表示。下同。


3.2 功能符


功能
键值对格式
使用示例



查询数组
“key[]”:{}，后面是JSONObject，key可省略。当key和里面的Table名相同时，Table会被提取出来，即 {Table:{Content}} 会被转化为 {Content}
{“User[]”:{“User”:{}}}，查询一个User数组。这里key和Table名都是User，User会被提取出来，即 {“User”:{“id”, …}} 会被转化为 {“id”, …}，如果要进一步提取User中的id，可以把User[]改为User-id[]


匹配选项范围
“key{}”:[]，后面是JSONArray，作为key可取的值的选项
“id{}”:[38710,82001,70793]，对应SQL是id IN(38710,82001,70793)，查询id符合38710,82001,70793中任意一个的一个User数组


匹配条件范围
“key{}”:”条件0,条件1…”，条件为SQL表达式字符串，可进行数字比较运算等
“id{}”:”&lt;&#x3D;80000,&gt;90000”，对应SQL是id&lt;&#x3D;80000 OR id&gt;90000，查询id符合id&lt;&#x3D;80000 | id&gt;90000的一个User数组


包含选项范围
“key&lt;&gt;“:Object  &#x3D;&gt;  “key&lt;&gt;“:[Object]，key对应值的类型必须为JSONArray，Object类型不能为JSON
“contactIdList&lt;&gt;“:38710，对应SQL是json_contains(contactIdList,38710)，查询contactIdList包含38710的一个User数组


判断是否存在
“key}{@”:{    “from”:”Table”,    “Table”:{ … }}其中：}{ 表示 EXISTS； key 用来标识是哪个判断； @ 后面是 子查询 对象，具体见下方 子查询 的说明。
“id}{@”:{    “from”:”Comment”,    “Comment”:{        “momentId”:15     }} WHERE EXISTS(SELECT * FROM Comment WHERE momentId&#x3D;15)


远程调用函数
“key()”:”函数表达式”，函数表达式为 function(key0,key1…)，会调用后端对应的函数 function(JSONObject request, String key0, String key1…)，实现 参数校验、数值计算、数据同步、消息推送、字段拼接、结构变换 等特定的业务逻辑处理，可使用 - 和 + 表示优先级，解析 key-() &gt; 解析当前对象 &gt; 解析 key() &gt; 解析子对象 &gt; 解析 key+()
“isPraised()”:”isContain(praiseUserIdList,userId)”，会调用远程函数 boolean isContain(JSONObject request, String array, String value) ，然后变为 “isPraised”:true 这种（假设点赞用户id列表包含了userId，即这个User点了赞）


存储过程
“@key()”:”SQL函数表达式”，函数表达式为   function(key0,key1…)  会调用后端数据库对应的存储过程 SQL函数  function(String key0, String key1…)  除了参数会提前赋值，其它和 远程函数 一致
“@limit”:10,  “@offset”:0,  “@procedure()”:”getCommentByUserId(id,@limit,@offset)”  会转为  getCommentByUserId(38710,10,0)  来调用存储过程 SQL 函数  getCommentByUserId(IN id bigint, IN limit int, IN offset int)  然后变为 “procedure”:{    “count”:-1,     “update”:false,     “list”:[]  }  其中 count 是指写操作影响记录行数，-1 表示不是写操作；update 是指是否为写操作（增删改）；list 为返回结果集


引用赋值
“key@”:”key0&#x2F;key1&#x2F;…&#x2F;refKey”，引用路径为用&#x2F;分隔的字符串。以&#x2F;开头的是缺省引用路径，从声明key所处容器的父容器路径开始；其它是完整引用路径，从最外层开始。 被引用的refKey必须在声明key的上面。如果对refKey的容器指定了返回字段，则被引用的refKey必须写在@column对应的值内，例如 “@column”:”refKey,key1,…”
“Moment”:{    “userId”:38710},“User”:{    “id@”:”&#x2F;Moment&#x2F;userId”} User内的id引用了与User同级的Moment内的userId，即User.id &#x3D; Moment.userId，请求完成后 “id@”:”&#x2F;Moment&#x2F;userId” 会变成 “id”:38710


子查询
“key@”:{    “range”:”ALL”,     “from”:”Table”,    “Table”:{ … }}其中：range 可为 ALL,ANY；from 为目标表 Table 的名称；@ 后面的对象类似数组对象，可使用 count 和 join 等功能。
“id@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&#x3D;(SELECT min(userId) FROM Comment)


模糊搜索
&quot;key$&quot;:&quot;SQL搜索表达式&quot;  &#x3D;&gt;  &quot;key$&quot;:[&quot;SQL搜索表达式&quot;]，任意SQL搜索表达式字符串，如 %key%(包含key), key%(以key开始), %k%e%y%(包含字母k,e,y) 等，%表示任意字符
“name$”:”%m%”，对应SQL是name LIKE &#39;%m%&#39;，查询name包含”m”的一个User数组


正则匹配
“key“:”正则表达式”  &#x3D;&gt;  “key“:[“正则表达式”]，任意正则表达式字符串，如 ^[0-9]+$ ，*~ 忽略大小写，可用于高级搜索
“name~”:”^[0-9]+$”，对应SQL是name REGEXP &#39;^[0-9]+$&#39;，查询name中字符全为数字的一个User数组


连续范围
“key%”:”start,end”  &#x3D;&gt;  “key%”:[“start,end”]，其中 start 和 end 都只能为 Boolean, Number, String 中的一种，如 “2017-01-01,2019-01-01” ，[“1,90000”, “82001,100000”] ，可用于连续范围内的筛选
“date%”:”2017-10-01,2018-10-01”，对应SQL是date BETWEEN &#39;2017-10-01&#39; AND &#39;2018-10-01&#39;，查询在2017-10-01和2018-10-01期间注册的用户的一个User数组


新建别名
“name:alias”，name映射为alias，用alias替代name。可用于 column,Table,SQL函数 等。只用于GET类型、HEAD类型的请求
“@column”:”toId:parentId”，对应SQL是toId AS parentId，将查询的字段toId变为parentId返回


增加 或 扩展
“key+”:Object，Object的类型由key指定，且类型为Number,String,JSONArray中的一种。如 82001,”apijson”,[“url0”,”url1”] 等。只用于PUT请求
“praiseUserIdList+”:[82001]，对应SQL是json_insert(praiseUserIdList,82001)，添加一个点赞用户id，即这个用户点了赞


减少 或 去除
“key-“:Object，与”key+”相反
“balance-“:100.00，对应SQL是balance &#x3D; balance - 100.00，余额减少100.00，即花费了100元


比较运算
&gt;, &lt;, &gt;&#x3D;, &lt;&#x3D; 比较运算符，用于 ① 提供 “id{}”:”&lt;&#x3D;90000” 这种条件范围的简化写法 ② 实现子查询相关比较运算不支持 “key&#x3D;”:Object 和 “key!&#x3D;”:Object 这两种写法，直接用更简单的 “key”:Object 和 “key!”:Object 替代。
① “id&lt;&#x3D;”:90000，对应SQL是id&lt;&#x3D;90000，查询符合id&lt;&#x3D;90000的一个User数组 ② “id&gt;@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&gt;(SELECT min(userId) FROM Comment)


逻辑运算
&amp;, |, ! 逻辑运算符，对应数据库 SQL 中的 AND, OR, NOT。 横或纵与：同一键值对的值内条件默认 | 或连接，可以在 key 后加逻辑运算符来具体指定；不同键值对的条件默认 &amp; 与连接，可以用下面说明的对象关键词 @combine 来具体指定。 ① &amp; 可用于”key&amp;{}”:”条件”等② | 可用于”key|{}”:”条件”, “key|{}”:[]等，一般可省略③ ! 可单独使用，如”key!”:Object，也可像&amp;,|一样配合其他功能符使用  “key!”:null 无效，null 值会导致整个键值对被忽略解析，可以用 “key{}”:”!&#x3D;null” 替代，“key”:null 同理，用 “key{}”:”&#x3D;null” 替代。
① “id&amp;{}”:”&gt;80000,&lt;&#x3D;90000”，对应SQL是id&gt;80000 AND id&lt;&#x3D;90000，即id满足id&gt;80000 &amp; id&lt;&#x3D;90000 ② “id|{}”:”&gt;90000,&lt;&#x3D;80000”，同”id{}”:”&gt;90000,&lt;&#x3D;80000”，对应SQL是id&gt;80000 OR id&lt;&#x3D;90000，即id满足id&gt;90000 | id&lt;&#x3D;80000 ③ “id!{}”:[82001,38710]，对应SQL是id NOT IN(82001,38710)，即id满足 ! (id&#x3D;82001 | id&#x3D;38710)，可过滤黑名单的消息


数组关键词，可自定义
“key”:Object，key为 “[]”:{} 中{}内的关键词，Object的类型由key指定① “count”:Integer，查询数量，0 表示最大值，默认最大值为100 ② “page”:Integer，查询页码，从0开始，默认最大值为100，一般和count一起用③ “query”:Integer，查询内容0-对象，1-总数和分页详情，2-数据、总数和分页详情总数关键词为 total，分页详情关键词为 info， 它们都和 query 同级，通过引用赋值得到，例如  “total@”:”&#x2F;[]&#x2F;total”, “info@”:”&#x2F;[]&#x2F;info” 这里query及total仅为GET类型的请求提供方便， 一般可直接用HEAD类型的请求获取总数④ “join”:”&amp;&#x2F;Table0,&lt;&#x2F;Table1&#x2F;key1@” 或 “join”:{    “&amp;&#x2F;Table0”:{},  &#x2F;&#x2F; 支持 ON 多个字段关联,    “&lt;&#x2F;Table1&#x2F;key1@”:{  &#x2F;&#x2F; ON 只允许指定的 key1 关联      “key0”:value0,  &#x2F;&#x2F; 其它ON条件       “key2”:value2,      …       “@combine”:”…”,  &#x2F;&#x2F; 其它ON条件的组合方式       “@column”:”…”,  &#x2F;&#x2F; 外层 SELECT       “@group”:”…”,  &#x2F;&#x2F; 外层 GROUP BY       “@having”:”…”  &#x2F;&#x2F; 外层 HAVING     }}多表连接方式：  “@” - APP JOIN  “&lt;“ - LEFT JOIN  “&gt;” - RIGHT JOIN  “&amp;” - INNER JOIN  “|” - FULL JOIN   “!” - OUTER JOIN   “*” - CROSS JOIN   “^” - SIDE JOIN   “(“ - ANTI JOIN   “)” - FOREIGN JOIN 其中 @ APP JOIN 为应用层连表，会从已查出的主表里取得所有副表 key@ 关联的主表内的 refKey 作为一个数组 refKeys: [value0, value1…]，然后把原来副表 count 次查询 key&#x3D;$refKey 的 SQL 用 key IN($refKeys) 的方式合并为一条 SQL 来优化性能； 其它 JOIN 都是 SQL JOIN，具体功能和 MySQL,PostgreSQL 等数据库的 JOIN 一一对应 &quot;join&quot;:&quot;&lt;&#x2F;ViceTable&#x2F;key@&quot;,&quot;MainTable&quot;:{},&quot;ViceTable&quot;:{&quot;key@&quot;:&quot;&#x2F;MainTable&#x2F;refKey&quot;}会对应生成 MainTable LEFT JOIN ViceTable ON ViceTable.key&#x3D;MainTable.refKey AND 其它ON条件  除了 &#x3D; 等价关联，也支持 ! 不等关联、&gt; &lt; &gt;&#x3D; &lt;&#x3D; 等比较关联和 $ ~ {} &lt;&gt; 等其它复杂关联方式 ⑤ “otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 查询User数组，最多5个：“count”:5对应SQL是LIMIT 5  ② 查询第3页的User数组，每页5个：“count”:5,“page”:3对应SQL是LIMIT 5 OFFSET 15  ③ 查询User数组和对应的User总数：“[]”:{    “query”:2,    “User”:{}},“total@”:”&#x2F;[]&#x2F;total”,“info@”:”&#x2F;[]&#x2F;info” 返回的数据中，总数及分页详情结构为：   “total”:139,  &#x2F;&#x2F;总数  “info”:{  &#x2F;&#x2F;分页详情     “total”:139,  &#x2F;&#x2F;总数     “count”:5,  &#x2F;&#x2F;每页数量     “page”:0,  &#x2F;&#x2F;当前页码     “max”:27,  &#x2F;&#x2F;最大页码     “more”:true,  &#x2F;&#x2F;是否还有更多     “first”:true,  &#x2F;&#x2F;是否为首页     “last”:false  &#x2F;&#x2F;是否为尾页 }  ④ Moment INNER JOIN User LEFT JOIN Comment：“[]”:{    “join”:”&amp;&#x2F;User&#x2F;id@,&lt;&#x2F;Comment”,    “Moment”:{     “@group”:”id”  &#x2F;&#x2F;主副表不是一对一，要去除重复数据   },    “User”:{      “name~”:”t”,      “id@”:”&#x2F;Moment&#x2F;userId”    },    “Comment”:{      “momentId@”:”&#x2F;Moment&#x2F;id”    }} ⑤ 每一层都加当前用户名：“User”:{},“[]”:{    “name@”:”User&#x2F;name”, &#x2F;&#x2F;自定义关键词    “Moment”:{}}


对象关键词，可自定义
“@key”:Object，@key为 Table:{} 中{}内的关键词，Object的类型由@key指定① “@combine”:”key0 | (key1 &amp; (key2 | !key3))…”，条件组合方式，最终按  (其它key条件 AND 连接) AND (key0条件 OR (key1条件 AND (key2条件 OR (NOT key3条件)))) 这种方式连接，其中 “其它key” 是指与 @combine 在同一对象，且未被它声明的条件 key，默认都是 &amp; 连接。注意不要缺少或多余任何一个空格。 ② “@column”:”column;function(arg)…”，返回字段③ “@order”:”column0+,column1-…”，排序方式④ “@group”:”column0,column1…”，分组方式。如果@column里声明了Table的id，则id也必须在@group中声明；其它情况下必须满足至少一个条件:1.分组的key在@column里声明2.Table主键在@group中声明 ⑤ “@having”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…” &#x2F;&#x2F; OR 连接，或 “@having&amp;”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…”  &#x2F;&#x2F; AND 连接，或 “@having”:{   “h0”:”function0(…)?value0”,   “h1”:function1(…)?value1”,   “h2”:function2(…)?value2…”,   “@combine”:”h0 &amp; (h1 | !h2)”  &#x2F;&#x2F; 任意组合，非必传}SQL函数条件，一般和@group一起用，函数一般在@column里声明⑥ “@schema”:”sys”，集合空间(数据库名&#x2F;模式)，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑦ “@database”:”POSTGRESQL”，数据库类型，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑧ “@datasource”:”DRUID”，跨数据源，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑨ “@json”:”key0,key1…”，转为 JSON 格式返回，符合 JSONObject 则转为 {…}，符合 JSONArray 则转为 […] ⑩ “@role”:”OWNER”，来访角色，包括UNKNOWN,LOGIN,CONTACT,CIRCLE,OWNER,ADMIN，可以在最外层作为全局默认配置，可自定义其它角色并重写 Verifier.verify 等相关方法来自定义校验 ⑪ “@explain”:true，性能分析，可以在最外层作为全局默认配置 ⑫ “@raw”:”key0,key1…”，其中 key0, key1 都对应有键值对 “key0”:”SQL片段或SQL片段的别名”,  “key1”:”SQL片段或SQL片段的别名”  自定义原始SQL片段，可扩展嵌套SQL函数等复杂语句，必须是后端已配置的，只有其它功能符都做不到才考虑，谨慎使用，注意防SQL注入⑬ “@otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 搜索name或tag任何一个字段包含字符a的User列表： “name“:”a”,“tag“:”a”,“@combine”:”name~ | tag~” 对应SQL是name REGEXP &#39;a&#39; OR tag REGEXP &#39;a&#39;  ② 只查询id,sex,name这几列并且请求结果也按照这个顺序：“@column”:”id,sex,name”对应SQL是SELECT id,sex,name  ③ 查询按 name降序、id默认顺序 排序的User数组：“@order”:”name-,id”对应SQL是ORDER BY name DESC,id  ④ 查询按userId分组的Moment数组：“@group”:”userId,id”对应SQL是GROUP BY userId,id  ⑤ 查询 按userId分组、id最大值&gt;&#x3D;100 的Moment数组：“@column”:”userId;max(id)”,“@group”:”userId”,“@having”:”max(id)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) ... GROUP BY userId HAVING max(id)&gt;&#x3D;100 还可以指定函数返回名：“@column”:”userId;max(id):maxId”,“@group”:”userId”,“@having”:”(maxId)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) AS maxId ... GROUP BY userId HAVING (maxId)&gt;&#x3D;100  ⑥ 查询 sys 内的 User 表：“@schema”:”sys”对应SQL是FROM sys.User  ⑦ 查询 PostgreSQL 数据库的 User 表：“@database”:”POSTGRESQL” ⑧ 使用 Druid 连接池查询 User 表：“@datasource”:”DRUID” ⑨ 将 VARCHAR 字符串字段 get 转为 JSONArray 返回：“@json”:”get” ⑩ 查询当前用户的动态：“@role”:”OWNER” ⑪ 开启性能分析：“@explain”:true对应SQL是EXPLAIN  ⑫ 统计最近一周偶数userId的数量“@column”:”date;left(date,10):day;sum(if(userId%2&#x3D;0,1,0))”,“@group”:”day”,“@having”:”to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7”,“@raw”:”@column,@having”对应SQL是SELECT date, left(date,10) AS day, sum(if(userId%2&#x3D;0,1,0)) ... GROUP BY day HAVING to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7  ⑬ 从pictureList获取第0张图片：“@position”:0, &#x2F;&#x2F;自定义关键词“firstPicture()”:”getFromArray(pictureList,@position)”


全局关键词
为最外层对象 {} 内的关键词。其中 @database，@schema, @datasource, @role, @explain 基本同对象关键词，见上方说明，区别是全局关键词会每个表对象中没有时自动放入，作为默认值。 ① “tag”:String，后面的 tag 是非 GET、HEAD 请求中匹配请求的 JSON 结构的标识，一般是要查询的 Table 的名称或该名称对应的数组 Table[] 或 Table:[]，由后端 Request 表中指定。 ② “version”:Integer，接口版本，version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本，由后端 Request 表中指定。③ “format”:Boolean，格式化返回 Response JSON 的 key，一般是将 TableName 转为 tableName, TableName[] 转为 tableNameList, Table:alias 转为 alias, TableName-key[] 转为 tableNameKeyList 等小驼峰格式。
①  查隐私信息：[{“tag”:”Privacy”,”Privacy”:{“id”:82001}}](http:&#x2F;&#x2F;apijson.cn&#x2F;api?url&#x3D;http%3A%2F%2Fapijson.cn%3A8080%2Fgets&amp;type&#x3D;JSON&amp;json&#x3D;


</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2.2"><span class="toc-number">1.6.5.</span> <span class="toc-text">2.2 前端请求


前端请求
传统方式
APIJSON



要求
前端按照文档在对应URL后面拼接键值对
前端按照自己的需求在固定URL后拼接JSON


URL
不同的请求对应不同的URL，基本上有多少个不同的请求就得有多少个接口URL
相同的操作方法(增删改查)都用同一个URL，大部分请求都用7个通用接口URL的其中一个


键值对
key&#x3D;value
key:value


结构
同一个URL内table_name只能有一个  base_url&#x2F;get&#x2F;table_name?key0&#x3D;value0&amp;key1&#x3D;value1…
同一个URL后TableName可传任意数量个  base_url&#x2F;get&#x2F;{    TableName0:{      key0:value0,      key1:value1,      …    },    TableName1:{      …    }    … }


 
 
2.3 后端操作


后端操作
传统方式
APIJSON



解析和返回
取出键值对，把键值对作为条件用预设的的方式去查询数据库，最后封装JSON并返回给前端
把Parser#parse方法的返回值返回给前端就行


返回JSON结构的设定方式
由后端设定，前端不能修改
由前端设定，后端不能修改


 
 
2.4 前端解析


前端解析
传统方式
APIJSON



查看方式
查文档或问后端，或等请求成功后看日志
看请求就行，所求即所得，不用查、不用问、不用等。也可以等请求成功后看日志


解析方法
用JSON解析器来解析JSONObject
可以用JSONResponse解析JSONObject，或使用传统方式


 
 
2.5 前端对应不同需求的请求


前端的请求
传统方式
APIJSON



User
base_url&#x2F;get&#x2F;user?id&#x3D;38710
base_url&#x2F;get&#x2F;{    “User”:{      “id”:38710    }}


Moment和对应的User
分两次请求Moment:  base_url&#x2F;get&#x2F;moment?userId&#x3D;38710User:  base_url&#x2F;get&#x2F;user?id&#x3D;38710
base_url&#x2F;get&#x2F;{    “Moment”:{      “userId”:38710    },     “User”:{      “id”:38710    }}


User列表
base_url&#x2F;get&#x2F;user&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;sex&#x3D;0
base_url&#x2F;get&#x2F;{    “User[]”:{      “page”:0,       “count”:3,       “User”:{        “sex”:0      }    }}


Moment列表，每个Moment包括1.发布者User2.前3条Comment
Moment里必须有1.User对象2.Comment数组 base_url&#x2F;get&#x2F;moment&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;commentCount&#x3D;3
base_url&#x2F;get&#x2F;{    “[]”:{      “page”:0,       “count”:3,       “Moment”:{},       “User”:{        “id@”:”&#x2F;Moment&#x2F;userId”      },      “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }}


User发布的Moment列表， 每个Moment包括 1.发布者User 2.前3条Comment
1.Moment里必须有User对象和Comment数组 2.字段名必须查接口文档，例如评论数量字段名可能是 commentCount,comment_count或者简写cmt_count等各种奇葩写法…  base_url&#x2F;get&#x2F;moment&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;commentCount&#x3D;3&amp;userId&#x3D;38710
有以下几种方式: ① 把以上请求里的“Moment”:{}, “User”:{“id@”:”&#x2F;Moment&#x2F;userId”}改为“Moment”:{“userId”:38710}, “User”:{“id”:38710}  ② 或把User放在上面的最外层省去重复的Userbase_url&#x2F;get&#x2F;{    “User”:{      “id”:38710    },    “[]”:{      “page”:0,      “count”:3,       “Moment”:{        “userId”:38710      },       “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }} ③ 如果User之前已经获取到了，还可以不传User来节省请求和返回数据的流量并提升速度base_url&#x2F;get&#x2F;{    “[]”:{      “page”:0,      “count”:3,       “Moment”:{        “userId”:38710      },      “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }}


 
 
2.6 后端对应不同请求的返回结果


后端的返回结果
传统方式
APIJSON



User
{    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
{    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


Moment和对应的User
分别返回两次请求的结果，获取到Moment后取出userId作为User的id条件去查询User  Moment:  {    “data”:{      “id”:235,      “content”:”xxx”,      …    },    “code”:200,    “msg”:”success”}  User:  {    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
一次性返回，没有传统方式导致的 长时间等待结果、两次结果间关联、线程多次切换 等问题  {    “Moment”:{      “id”:235,      “content”:”xxx”,      …    },    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


User列表
{    “data”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}
{    “User[]”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}


Moment列表，每个Moment包括发布者User和前3条Comment
Moment里必须有1.User对象2.Comment数组  {    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          …        },        “Comment”:[          …        ]      },      {        “id”:301,        “content”:”xxx”,        …,        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}
1.高灵活，可任意组合2.低耦合，逻辑很清晰{    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          …        },        “Comment[]”:[          …        ]      },      {        “Moment”:{          “id”:301,          “content”:”xxx”,          …        },        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}


User发布的Moment列表，每个Moment包括发布者User和前3条Comment
1.大量重复User，浪费流量和服务器性能2.优化很繁琐，需要后端扩展接口、写好文档，前端&#x2F;前端再配合优化{    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:470,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:511,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:595,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      …    ],    “code”:200,    “msg”:”success”}
以上不同请求方式的结果: ① 常规请求  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ② 省去重复的User  {    “User”:{      “id”:38710,      “name”:”Tommy”,      …    },    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ③ 不查询已获取到的User  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”}


1.base_url指基地址，一般是顶级域名，其它分支url都是在base_url后扩展。如base_url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F; ，对应的GET分支url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F;get&#x2F; 。下同。2.请求中的key或value任意一个为null值时，这个 key:value键值对 被视为无效。下同。3.请求中的 &#x2F; 需要转义。JSONRequest.java已经用URLEncoder.encode转义，不需要再写；但如果是浏览器或Postman等直接输入url&#x2F;request，需要把request中的所有 &#x2F; 都改成 %252F 。下同。4.code，指返回结果中的状态码，200表示成功，其它都是错误码，值全部都是HTTP标准状态码。下同。5.msg，指返回结果中的状态信息，对成功结果或错误原因的详细说明。下同。6.code和msg总是在返回结果的同一层级成对出现。对所有请求的返回结果都会在最外层有一对总结式code和msg。下同。7.id等字段对应的值仅供说明，不一定是数据库里存在的，请求里用的是真实存在的值。下同。



3.设计规范3.1 操作方法


方法及说明
URL
Request
Response



GET:  普通获取数据， 可用浏览器调试
base_url&#x2F;get&#x2F;
{    TableName:{      …     }}  {…}内为限制条件 例如获取一个 id &#x3D; 235 的 Moment： {    “Moment”:{      “id”:235    }}  后端校验通过后自动解析为 SQL 并执行：SELECT * FROM Moment WHERE id&#x3D;235 LIMIT 1
{    TableName:{      …    },    “code”:200,    “msg”:”success”}例如{    “Moment”:{      “id”:235,      “userId”:38710,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “code”:200,    “msg”:”success” }


HEAD:  普通获取数量， 可用浏览器调试
base_url&#x2F;head&#x2F;
{    TableName:{      …    } }  {…}内为限制条件  例如获取一个 id &#x3D; 38710 的 User 所发布的 Moment 总数： {    “Moment”:{      “userId”:38710    }}  后端校验通过后自动解析为 SQL 并执行：SELECT count(*) FROM Moment WHERE userId&#x3D;38710 LIMIT 1
{    TableName:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,    “msg”:”success”}  例如{    “Moment”:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,     “msg”:”success”}


GETS:  安全&#x2F;私密获取数据， 用于获取钱包等对安全性要求高的数据
base_url&#x2F;gets&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Privacy”，其它同GET
同GET


HEADS:  安全&#x2F;私密获取数量， 用于获取银行卡数量等对安全性要求高的数据总数
base_url&#x2F;heads&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Verify”，其它同HEAD
同HEAD


POST:  新增数据
base_url&#x2F;post&#x2F;
单个：  {    TableName:{      …    },    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 38710 发布一个新 Comment：{    “Comment”:{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”     },    “tag”:”Comment”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(38710,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;)    批量：  {    TableName[]:[{        …      }, {        …      }      …    ],    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 82001 发布 2 个 Comment：{    “Comment[]”:[{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”      }, {      “momentId”:15,      “content”:”APIJSON is a JSON transmision protocol.”    }],    “tag”:”Comment:[]”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(82001,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;);INSERT INTO Comment(userId,momentId,content) VALUES(82001,15,&#39;APIJSON is a JSON transmision protocol.&#39;);
单个：  {    TableName:{      “code”:200,      “msg”:”success”,      “id”:38710    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “id”:120    },    “code”:200,    “msg”:”success”}   批量：  {    TableName:{      “code”:200,      “msg”:”success”,      “count”:5,      “id[]”:[1, 2, 3, 4, 5]    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “count”:2,      “id[]”:[1, 2]    },    “code”:200,    “msg”:”success”}


PUT:  修改数据， 只修改所传的字段
base_url&#x2F;put&#x2F;
{    TableName:{      “id”:id,      …    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个 例如当前登录用户 82001 修改 id &#x3D; 235 的 Moment 的 content：{    “Moment”:{      “id”:235,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “tag”:”Moment”}  后端校验通过后自动解析为 SQL 并执行：UPDATE Moment SET content&#x3D;&#39;APIJSON,let interfaces and documents go to hell !&#39; WHERE id&#x3D;235 AND userId&#x3D;82001 LIMIT 1  批量除了 id{}:[] 也可类似批量 POST，只是每个 {…} 里面都必须有 id。“tag”:”Comment[]” 对应对象 “Comment”:{“id{}”:[1,2,3]}，表示指定记录全部统一设置；“tag”:”Comment:[]” 多了冒号，对应数组 “Comment[]”:[{“id”:1},{“id”:2},{“id”:3}]，表示每项单独设置
同POST


DELETE:  删除数据
base_url&#x2F;delete&#x2F;
{    TableName:{      “id”:id    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个，一般只传 id 或 id{} 例如当前登录用户 82001 批量删除 id &#x3D; 100,110,120 的 Comment：{    “Comment”:{      “id{}”:[100,110,120]    },    “tag”:”Comment[]”}  后端校验通过后自动解析为 SQL 并执行：DELETE FROM Comment WHERE id IN(100,110,120) AND userId&#x3D;82001 LIMIT 3
{    TableName:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120]      “count”:3    },    “code”:200,    “msg”:”success”}例如{   “Comment”:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120],      “count”:3   },   “code”:200,   “msg”:”success”}


以上接口的简单形式:  base_url&#x2F;{method}&#x2F;{tag}
GET: 普通获取数据  base_url&#x2F;get&#x2F;{tag}  HEAD: 普通获取数量  base_url&#x2F;head&#x2F;{tag}  GETS: 安全&#x2F;私密获取数据   base_url&#x2F;gets&#x2F;{tag}  HEADS: 安全&#x2F;私密获取数量  base_url&#x2F;heads&#x2F;{tag}  POST: 新增数据   base_url&#x2F;post&#x2F;{tag}  PUT: 修改数据  base_url&#x2F;put&#x2F;{tag}  DELETE: 删除数据  base_url&#x2F;delete&#x2F;{tag}
例如安全&#x2F;私密获取一个 id &#x3D; 82001 的 Privacy： base_url&#x2F;gets&#x2F;Privacy&#x2F;  {“id”:82001}  相当于  base_url&#x2F;gets&#x2F; {“tag”:”Privacy”, “Privacy”:{“id”:82001}}   例如批量修改 id &#x3D; 114, 124 的 Comment 的 content：base_url&#x2F;put&#x2F;Comemnt[]&#x2F;  {    “id{}”:[114,124],    “content”:”test multi put”}  相当于  base_url&#x2F;put&#x2F;  {    “tag”:”Comment[]”,     “Comment”:{      “id{}”:[114,124],      “content”:”test multi put”    }}
同以上对应的方法


1.TableName指要查询的数据库表Table的名称字符串。第一个字符为大写字母，剩下的字符要符合英语字母、数字、下划线中的任何一种。对应的值的类型为JSONObject，结构是 {…}，里面放的是Table的字段(列名)。下同。2.”tag”:tag 后面的tag是非GET、HEAD请求中匹配请求的JSON结构的标识，一般是要查询的Table的名称，由后端Request表中指定。下同。3.GET、HEAD请求是开放请求，可任意组合任意嵌套。其它请求为受限制的安全&#x2F;私密请求，对应的 方法（method）, 标识（tag）, 版本（version）, 结构（structure） 都必须和 后端Request表中所指定的 一一对应，否则请求将不被通过。version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本。下同。4.GETS与GET、HEADS与HEAD分别为同一类型的操作方法，请求稍有不同但返回结果相同。下同。5.在HTTP通信中，自动化接口(get,gets,head,heads,post,put,delete) 全用HTTP POST请求。下同。6.所有JSONObject都视为容器(或者文件夹)，结构为 {…} ，里面可以放普通对象或子容器。下同。7.每个对象都有一个唯一的路径(或者叫地址)，假设对象名为refKey，则用 key0&#x2F;key1&#x2F;…&#x2F;refKey 表示。下同。


3.2 功能符


功能
键值对格式
使用示例



查询数组
“key[]”:{}，后面是JSONObject，key可省略。当key和里面的Table名相同时，Table会被提取出来，即 {Table:{Content}} 会被转化为 {Content}
{“User[]”:{“User”:{}}}，查询一个User数组。这里key和Table名都是User，User会被提取出来，即 {“User”:{“id”, …}} 会被转化为 {“id”, …}，如果要进一步提取User中的id，可以把User[]改为User-id[]


匹配选项范围
“key{}”:[]，后面是JSONArray，作为key可取的值的选项
“id{}”:[38710,82001,70793]，对应SQL是id IN(38710,82001,70793)，查询id符合38710,82001,70793中任意一个的一个User数组


匹配条件范围
“key{}”:”条件0,条件1…”，条件为SQL表达式字符串，可进行数字比较运算等
“id{}”:”&lt;&#x3D;80000,&gt;90000”，对应SQL是id&lt;&#x3D;80000 OR id&gt;90000，查询id符合id&lt;&#x3D;80000 | id&gt;90000的一个User数组


包含选项范围
“key&lt;&gt;“:Object  &#x3D;&gt;  “key&lt;&gt;“:[Object]，key对应值的类型必须为JSONArray，Object类型不能为JSON
“contactIdList&lt;&gt;“:38710，对应SQL是json_contains(contactIdList,38710)，查询contactIdList包含38710的一个User数组


判断是否存在
“key}{@”:{    “from”:”Table”,    “Table”:{ … }}其中：}{ 表示 EXISTS； key 用来标识是哪个判断； @ 后面是 子查询 对象，具体见下方 子查询 的说明。
“id}{@”:{    “from”:”Comment”,    “Comment”:{        “momentId”:15     }} WHERE EXISTS(SELECT * FROM Comment WHERE momentId&#x3D;15)


远程调用函数
“key()”:”函数表达式”，函数表达式为 function(key0,key1…)，会调用后端对应的函数 function(JSONObject request, String key0, String key1…)，实现 参数校验、数值计算、数据同步、消息推送、字段拼接、结构变换 等特定的业务逻辑处理，可使用 - 和 + 表示优先级，解析 key-() &gt; 解析当前对象 &gt; 解析 key() &gt; 解析子对象 &gt; 解析 key+()
“isPraised()”:”isContain(praiseUserIdList,userId)”，会调用远程函数 boolean isContain(JSONObject request, String array, String value) ，然后变为 “isPraised”:true 这种（假设点赞用户id列表包含了userId，即这个User点了赞）


存储过程
“@key()”:”SQL函数表达式”，函数表达式为   function(key0,key1…)  会调用后端数据库对应的存储过程 SQL函数  function(String key0, String key1…)  除了参数会提前赋值，其它和 远程函数 一致
“@limit”:10,  “@offset”:0,  “@procedure()”:”getCommentByUserId(id,@limit,@offset)”  会转为  getCommentByUserId(38710,10,0)  来调用存储过程 SQL 函数  getCommentByUserId(IN id bigint, IN limit int, IN offset int)  然后变为 “procedure”:{    “count”:-1,     “update”:false,     “list”:[]  }  其中 count 是指写操作影响记录行数，-1 表示不是写操作；update 是指是否为写操作（增删改）；list 为返回结果集


引用赋值
“key@”:”key0&#x2F;key1&#x2F;…&#x2F;refKey”，引用路径为用&#x2F;分隔的字符串。以&#x2F;开头的是缺省引用路径，从声明key所处容器的父容器路径开始；其它是完整引用路径，从最外层开始。 被引用的refKey必须在声明key的上面。如果对refKey的容器指定了返回字段，则被引用的refKey必须写在@column对应的值内，例如 “@column”:”refKey,key1,…”
“Moment”:{    “userId”:38710},“User”:{    “id@”:”&#x2F;Moment&#x2F;userId”} User内的id引用了与User同级的Moment内的userId，即User.id &#x3D; Moment.userId，请求完成后 “id@”:”&#x2F;Moment&#x2F;userId” 会变成 “id”:38710


子查询
“key@”:{    “range”:”ALL”,     “from”:”Table”,    “Table”:{ … }}其中：range 可为 ALL,ANY；from 为目标表 Table 的名称；@ 后面的对象类似数组对象，可使用 count 和 join 等功能。
“id@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&#x3D;(SELECT min(userId) FROM Comment)


模糊搜索
&quot;key$&quot;:&quot;SQL搜索表达式&quot;  &#x3D;&gt;  &quot;key$&quot;:[&quot;SQL搜索表达式&quot;]，任意SQL搜索表达式字符串，如 %key%(包含key), key%(以key开始), %k%e%y%(包含字母k,e,y) 等，%表示任意字符
“name$”:”%m%”，对应SQL是name LIKE &#39;%m%&#39;，查询name包含”m”的一个User数组


正则匹配
“key“:”正则表达式”  &#x3D;&gt;  “key“:[“正则表达式”]，任意正则表达式字符串，如 ^[0-9]+$ ，*~ 忽略大小写，可用于高级搜索
“name~”:”^[0-9]+$”，对应SQL是name REGEXP &#39;^[0-9]+$&#39;，查询name中字符全为数字的一个User数组


连续范围
“key%”:”start,end”  &#x3D;&gt;  “key%”:[“start,end”]，其中 start 和 end 都只能为 Boolean, Number, String 中的一种，如 “2017-01-01,2019-01-01” ，[“1,90000”, “82001,100000”] ，可用于连续范围内的筛选
“date%”:”2017-10-01,2018-10-01”，对应SQL是date BETWEEN &#39;2017-10-01&#39; AND &#39;2018-10-01&#39;，查询在2017-10-01和2018-10-01期间注册的用户的一个User数组


新建别名
“name:alias”，name映射为alias，用alias替代name。可用于 column,Table,SQL函数 等。只用于GET类型、HEAD类型的请求
“@column”:”toId:parentId”，对应SQL是toId AS parentId，将查询的字段toId变为parentId返回


增加 或 扩展
“key+”:Object，Object的类型由key指定，且类型为Number,String,JSONArray中的一种。如 82001,”apijson”,[“url0”,”url1”] 等。只用于PUT请求
“praiseUserIdList+”:[82001]，对应SQL是json_insert(praiseUserIdList,82001)，添加一个点赞用户id，即这个用户点了赞


减少 或 去除
“key-“:Object，与”key+”相反
“balance-“:100.00，对应SQL是balance &#x3D; balance - 100.00，余额减少100.00，即花费了100元


比较运算
&gt;, &lt;, &gt;&#x3D;, &lt;&#x3D; 比较运算符，用于 ① 提供 “id{}”:”&lt;&#x3D;90000” 这种条件范围的简化写法 ② 实现子查询相关比较运算不支持 “key&#x3D;”:Object 和 “key!&#x3D;”:Object 这两种写法，直接用更简单的 “key”:Object 和 “key!”:Object 替代。
① “id&lt;&#x3D;”:90000，对应SQL是id&lt;&#x3D;90000，查询符合id&lt;&#x3D;90000的一个User数组 ② “id&gt;@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&gt;(SELECT min(userId) FROM Comment)


逻辑运算
&amp;, |, ! 逻辑运算符，对应数据库 SQL 中的 AND, OR, NOT。 横或纵与：同一键值对的值内条件默认 | 或连接，可以在 key 后加逻辑运算符来具体指定；不同键值对的条件默认 &amp; 与连接，可以用下面说明的对象关键词 @combine 来具体指定。 ① &amp; 可用于”key&amp;{}”:”条件”等② | 可用于”key|{}”:”条件”, “key|{}”:[]等，一般可省略③ ! 可单独使用，如”key!”:Object，也可像&amp;,|一样配合其他功能符使用  “key!”:null 无效，null 值会导致整个键值对被忽略解析，可以用 “key{}”:”!&#x3D;null” 替代，“key”:null 同理，用 “key{}”:”&#x3D;null” 替代。
① “id&amp;{}”:”&gt;80000,&lt;&#x3D;90000”，对应SQL是id&gt;80000 AND id&lt;&#x3D;90000，即id满足id&gt;80000 &amp; id&lt;&#x3D;90000 ② “id|{}”:”&gt;90000,&lt;&#x3D;80000”，同”id{}”:”&gt;90000,&lt;&#x3D;80000”，对应SQL是id&gt;80000 OR id&lt;&#x3D;90000，即id满足id&gt;90000 | id&lt;&#x3D;80000 ③ “id!{}”:[82001,38710]，对应SQL是id NOT IN(82001,38710)，即id满足 ! (id&#x3D;82001 | id&#x3D;38710)，可过滤黑名单的消息


数组关键词，可自定义
“key”:Object，key为 “[]”:{} 中{}内的关键词，Object的类型由key指定① “count”:Integer，查询数量，0 表示最大值，默认最大值为100 ② “page”:Integer，查询页码，从0开始，默认最大值为100，一般和count一起用③ “query”:Integer，查询内容0-对象，1-总数和分页详情，2-数据、总数和分页详情总数关键词为 total，分页详情关键词为 info， 它们都和 query 同级，通过引用赋值得到，例如  “total@”:”&#x2F;[]&#x2F;total”, “info@”:”&#x2F;[]&#x2F;info” 这里query及total仅为GET类型的请求提供方便， 一般可直接用HEAD类型的请求获取总数④ “join”:”&amp;&#x2F;Table0,&lt;&#x2F;Table1&#x2F;key1@” 或 “join”:{    “&amp;&#x2F;Table0”:{},  &#x2F;&#x2F; 支持 ON 多个字段关联,    “&lt;&#x2F;Table1&#x2F;key1@”:{  &#x2F;&#x2F; ON 只允许指定的 key1 关联      “key0”:value0,  &#x2F;&#x2F; 其它ON条件       “key2”:value2,      …       “@combine”:”…”,  &#x2F;&#x2F; 其它ON条件的组合方式       “@column”:”…”,  &#x2F;&#x2F; 外层 SELECT       “@group”:”…”,  &#x2F;&#x2F; 外层 GROUP BY       “@having”:”…”  &#x2F;&#x2F; 外层 HAVING     }}多表连接方式：  “@” - APP JOIN  “&lt;“ - LEFT JOIN  “&gt;” - RIGHT JOIN  “&amp;” - INNER JOIN  “|” - FULL JOIN   “!” - OUTER JOIN   “*” - CROSS JOIN   “^” - SIDE JOIN   “(“ - ANTI JOIN   “)” - FOREIGN JOIN 其中 @ APP JOIN 为应用层连表，会从已查出的主表里取得所有副表 key@ 关联的主表内的 refKey 作为一个数组 refKeys: [value0, value1…]，然后把原来副表 count 次查询 key&#x3D;$refKey 的 SQL 用 key IN($refKeys) 的方式合并为一条 SQL 来优化性能； 其它 JOIN 都是 SQL JOIN，具体功能和 MySQL,PostgreSQL 等数据库的 JOIN 一一对应 &quot;join&quot;:&quot;&lt;&#x2F;ViceTable&#x2F;key@&quot;,&quot;MainTable&quot;:{},&quot;ViceTable&quot;:{&quot;key@&quot;:&quot;&#x2F;MainTable&#x2F;refKey&quot;}会对应生成 MainTable LEFT JOIN ViceTable ON ViceTable.key&#x3D;MainTable.refKey AND 其它ON条件  除了 &#x3D; 等价关联，也支持 ! 不等关联、&gt; &lt; &gt;&#x3D; &lt;&#x3D; 等比较关联和 $ ~ {} &lt;&gt; 等其它复杂关联方式 ⑤ “otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 查询User数组，最多5个：“count”:5对应SQL是LIMIT 5  ② 查询第3页的User数组，每页5个：“count”:5,“page”:3对应SQL是LIMIT 5 OFFSET 15  ③ 查询User数组和对应的User总数：“[]”:{    “query”:2,    “User”:{}},“total@”:”&#x2F;[]&#x2F;total”,“info@”:”&#x2F;[]&#x2F;info” 返回的数据中，总数及分页详情结构为：   “total”:139,  &#x2F;&#x2F;总数  “info”:{  &#x2F;&#x2F;分页详情     “total”:139,  &#x2F;&#x2F;总数     “count”:5,  &#x2F;&#x2F;每页数量     “page”:0,  &#x2F;&#x2F;当前页码     “max”:27,  &#x2F;&#x2F;最大页码     “more”:true,  &#x2F;&#x2F;是否还有更多     “first”:true,  &#x2F;&#x2F;是否为首页     “last”:false  &#x2F;&#x2F;是否为尾页 }  ④ Moment INNER JOIN User LEFT JOIN Comment：“[]”:{    “join”:”&amp;&#x2F;User&#x2F;id@,&lt;&#x2F;Comment”,    “Moment”:{     “@group”:”id”  &#x2F;&#x2F;主副表不是一对一，要去除重复数据   },    “User”:{      “name~”:”t”,      “id@”:”&#x2F;Moment&#x2F;userId”    },    “Comment”:{      “momentId@”:”&#x2F;Moment&#x2F;id”    }} ⑤ 每一层都加当前用户名：“User”:{},“[]”:{    “name@”:”User&#x2F;name”, &#x2F;&#x2F;自定义关键词    “Moment”:{}}


对象关键词，可自定义
“@key”:Object，@key为 Table:{} 中{}内的关键词，Object的类型由@key指定① “@combine”:”key0 | (key1 &amp; (key2 | !key3))…”，条件组合方式，最终按  (其它key条件 AND 连接) AND (key0条件 OR (key1条件 AND (key2条件 OR (NOT key3条件)))) 这种方式连接，其中 “其它key” 是指与 @combine 在同一对象，且未被它声明的条件 key，默认都是 &amp; 连接。注意不要缺少或多余任何一个空格。 ② “@column”:”column;function(arg)…”，返回字段③ “@order”:”column0+,column1-…”，排序方式④ “@group”:”column0,column1…”，分组方式。如果@column里声明了Table的id，则id也必须在@group中声明；其它情况下必须满足至少一个条件:1.分组的key在@column里声明2.Table主键在@group中声明 ⑤ “@having”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…” &#x2F;&#x2F; OR 连接，或 “@having&amp;”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…”  &#x2F;&#x2F; AND 连接，或 “@having”:{   “h0”:”function0(…)?value0”,   “h1”:function1(…)?value1”,   “h2”:function2(…)?value2…”,   “@combine”:”h0 &amp; (h1 | !h2)”  &#x2F;&#x2F; 任意组合，非必传}SQL函数条件，一般和@group一起用，函数一般在@column里声明⑥ “@schema”:”sys”，集合空间(数据库名&#x2F;模式)，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑦ “@database”:”POSTGRESQL”，数据库类型，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑧ “@datasource”:”DRUID”，跨数据源，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑨ “@json”:”key0,key1…”，转为 JSON 格式返回，符合 JSONObject 则转为 {…}，符合 JSONArray 则转为 […] ⑩ “@role”:”OWNER”，来访角色，包括UNKNOWN,LOGIN,CONTACT,CIRCLE,OWNER,ADMIN，可以在最外层作为全局默认配置，可自定义其它角色并重写 Verifier.verify 等相关方法来自定义校验 ⑪ “@explain”:true，性能分析，可以在最外层作为全局默认配置 ⑫ “@raw”:”key0,key1…”，其中 key0, key1 都对应有键值对 “key0”:”SQL片段或SQL片段的别名”,  “key1”:”SQL片段或SQL片段的别名”  自定义原始SQL片段，可扩展嵌套SQL函数等复杂语句，必须是后端已配置的，只有其它功能符都做不到才考虑，谨慎使用，注意防SQL注入⑬ “@otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 搜索name或tag任何一个字段包含字符a的User列表： “name“:”a”,“tag“:”a”,“@combine”:”name~ | tag~” 对应SQL是name REGEXP &#39;a&#39; OR tag REGEXP &#39;a&#39;  ② 只查询id,sex,name这几列并且请求结果也按照这个顺序：“@column”:”id,sex,name”对应SQL是SELECT id,sex,name  ③ 查询按 name降序、id默认顺序 排序的User数组：“@order”:”name-,id”对应SQL是ORDER BY name DESC,id  ④ 查询按userId分组的Moment数组：“@group”:”userId,id”对应SQL是GROUP BY userId,id  ⑤ 查询 按userId分组、id最大值&gt;&#x3D;100 的Moment数组：“@column”:”userId;max(id)”,“@group”:”userId”,“@having”:”max(id)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) ... GROUP BY userId HAVING max(id)&gt;&#x3D;100 还可以指定函数返回名：“@column”:”userId;max(id):maxId”,“@group”:”userId”,“@having”:”(maxId)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) AS maxId ... GROUP BY userId HAVING (maxId)&gt;&#x3D;100  ⑥ 查询 sys 内的 User 表：“@schema”:”sys”对应SQL是FROM sys.User  ⑦ 查询 PostgreSQL 数据库的 User 表：“@database”:”POSTGRESQL” ⑧ 使用 Druid 连接池查询 User 表：“@datasource”:”DRUID” ⑨ 将 VARCHAR 字符串字段 get 转为 JSONArray 返回：“@json”:”get” ⑩ 查询当前用户的动态：“@role”:”OWNER” ⑪ 开启性能分析：“@explain”:true对应SQL是EXPLAIN  ⑫ 统计最近一周偶数userId的数量“@column”:”date;left(date,10):day;sum(if(userId%2&#x3D;0,1,0))”,“@group”:”day”,“@having”:”to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7”,“@raw”:”@column,@having”对应SQL是SELECT date, left(date,10) AS day, sum(if(userId%2&#x3D;0,1,0)) ... GROUP BY day HAVING to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7  ⑬ 从pictureList获取第0张图片：“@position”:0, &#x2F;&#x2F;自定义关键词“firstPicture()”:”getFromArray(pictureList,@position)”


全局关键词
为最外层对象 {} 内的关键词。其中 @database，@schema, @datasource, @role, @explain 基本同对象关键词，见上方说明，区别是全局关键词会每个表对象中没有时自动放入，作为默认值。 ① “tag”:String，后面的 tag 是非 GET、HEAD 请求中匹配请求的 JSON 结构的标识，一般是要查询的 Table 的名称或该名称对应的数组 Table[] 或 Table:[]，由后端 Request 表中指定。 ② “version”:Integer，接口版本，version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本，由后端 Request 表中指定。③ “format”:Boolean，格式化返回 Response JSON 的 key，一般是将 TableName 转为 tableName, TableName[] 转为 tableNameList, Table:alias 转为 alias, TableName-key[] 转为 tableNameKeyList 等小驼峰格式。
①  查隐私信息：[{“tag”:”Privacy”,”Privacy”:{“id”:82001}}](http:&#x2F;&#x2F;apijson.cn&#x2F;api?url&#x3D;http%3A%2F%2Fapijson.cn%3A8080%2Fgets&amp;type&#x3D;JSON&amp;json&#x3D;


</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2.2"><span class="toc-number">1.6.6.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%90%8E%E7%AB%AF%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.7.</span> <span class="toc-text">2.3 后端操作


后端操作
传统方式
APIJSON



解析和返回
取出键值对，把键值对作为条件用预设的的方式去查询数据库，最后封装JSON并返回给前端
把Parser#parse方法的返回值返回给前端就行


返回JSON结构的设定方式
由后端设定，前端不能修改
由前端设定，后端不能修改


 
 
2.4 前端解析


前端解析
传统方式
APIJSON



查看方式
查文档或问后端，或等请求成功后看日志
看请求就行，所求即所得，不用查、不用问、不用等。也可以等请求成功后看日志


解析方法
用JSON解析器来解析JSONObject
可以用JSONResponse解析JSONObject，或使用传统方式


 
 
2.5 前端对应不同需求的请求


前端的请求
传统方式
APIJSON



User
base_url&#x2F;get&#x2F;user?id&#x3D;38710
base_url&#x2F;get&#x2F;{    “User”:{      “id”:38710    }}


Moment和对应的User
分两次请求Moment:  base_url&#x2F;get&#x2F;moment?userId&#x3D;38710User:  base_url&#x2F;get&#x2F;user?id&#x3D;38710
base_url&#x2F;get&#x2F;{    “Moment”:{      “userId”:38710    },     “User”:{      “id”:38710    }}


User列表
base_url&#x2F;get&#x2F;user&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;sex&#x3D;0
base_url&#x2F;get&#x2F;{    “User[]”:{      “page”:0,       “count”:3,       “User”:{        “sex”:0      }    }}


Moment列表，每个Moment包括1.发布者User2.前3条Comment
Moment里必须有1.User对象2.Comment数组 base_url&#x2F;get&#x2F;moment&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;commentCount&#x3D;3
base_url&#x2F;get&#x2F;{    “[]”:{      “page”:0,       “count”:3,       “Moment”:{},       “User”:{        “id@”:”&#x2F;Moment&#x2F;userId”      },      “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }}


User发布的Moment列表， 每个Moment包括 1.发布者User 2.前3条Comment
1.Moment里必须有User对象和Comment数组 2.字段名必须查接口文档，例如评论数量字段名可能是 commentCount,comment_count或者简写cmt_count等各种奇葩写法…  base_url&#x2F;get&#x2F;moment&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;commentCount&#x3D;3&amp;userId&#x3D;38710
有以下几种方式: ① 把以上请求里的“Moment”:{}, “User”:{“id@”:”&#x2F;Moment&#x2F;userId”}改为“Moment”:{“userId”:38710}, “User”:{“id”:38710}  ② 或把User放在上面的最外层省去重复的Userbase_url&#x2F;get&#x2F;{    “User”:{      “id”:38710    },    “[]”:{      “page”:0,      “count”:3,       “Moment”:{        “userId”:38710      },       “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }} ③ 如果User之前已经获取到了，还可以不传User来节省请求和返回数据的流量并提升速度base_url&#x2F;get&#x2F;{    “[]”:{      “page”:0,      “count”:3,       “Moment”:{        “userId”:38710      },      “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }}


 
 
2.6 后端对应不同请求的返回结果


后端的返回结果
传统方式
APIJSON



User
{    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
{    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


Moment和对应的User
分别返回两次请求的结果，获取到Moment后取出userId作为User的id条件去查询User  Moment:  {    “data”:{      “id”:235,      “content”:”xxx”,      …    },    “code”:200,    “msg”:”success”}  User:  {    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
一次性返回，没有传统方式导致的 长时间等待结果、两次结果间关联、线程多次切换 等问题  {    “Moment”:{      “id”:235,      “content”:”xxx”,      …    },    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


User列表
{    “data”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}
{    “User[]”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}


Moment列表，每个Moment包括发布者User和前3条Comment
Moment里必须有1.User对象2.Comment数组  {    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          …        },        “Comment”:[          …        ]      },      {        “id”:301,        “content”:”xxx”,        …,        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}
1.高灵活，可任意组合2.低耦合，逻辑很清晰{    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          …        },        “Comment[]”:[          …        ]      },      {        “Moment”:{          “id”:301,          “content”:”xxx”,          …        },        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}


User发布的Moment列表，每个Moment包括发布者User和前3条Comment
1.大量重复User，浪费流量和服务器性能2.优化很繁琐，需要后端扩展接口、写好文档，前端&#x2F;前端再配合优化{    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:470,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:511,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:595,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      …    ],    “code”:200,    “msg”:”success”}
以上不同请求方式的结果: ① 常规请求  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ② 省去重复的User  {    “User”:{      “id”:38710,      “name”:”Tommy”,      …    },    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ③ 不查询已获取到的User  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”}


1.base_url指基地址，一般是顶级域名，其它分支url都是在base_url后扩展。如base_url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F; ，对应的GET分支url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F;get&#x2F; 。下同。2.请求中的key或value任意一个为null值时，这个 key:value键值对 被视为无效。下同。3.请求中的 &#x2F; 需要转义。JSONRequest.java已经用URLEncoder.encode转义，不需要再写；但如果是浏览器或Postman等直接输入url&#x2F;request，需要把request中的所有 &#x2F; 都改成 %252F 。下同。4.code，指返回结果中的状态码，200表示成功，其它都是错误码，值全部都是HTTP标准状态码。下同。5.msg，指返回结果中的状态信息，对成功结果或错误原因的详细说明。下同。6.code和msg总是在返回结果的同一层级成对出现。对所有请求的返回结果都会在最外层有一对总结式code和msg。下同。7.id等字段对应的值仅供说明，不一定是数据库里存在的，请求里用的是真实存在的值。下同。



3.设计规范3.1 操作方法


方法及说明
URL
Request
Response



GET:  普通获取数据， 可用浏览器调试
base_url&#x2F;get&#x2F;
{    TableName:{      …     }}  {…}内为限制条件 例如获取一个 id &#x3D; 235 的 Moment： {    “Moment”:{      “id”:235    }}  后端校验通过后自动解析为 SQL 并执行：SELECT * FROM Moment WHERE id&#x3D;235 LIMIT 1
{    TableName:{      …    },    “code”:200,    “msg”:”success”}例如{    “Moment”:{      “id”:235,      “userId”:38710,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “code”:200,    “msg”:”success” }


HEAD:  普通获取数量， 可用浏览器调试
base_url&#x2F;head&#x2F;
{    TableName:{      …    } }  {…}内为限制条件  例如获取一个 id &#x3D; 38710 的 User 所发布的 Moment 总数： {    “Moment”:{      “userId”:38710    }}  后端校验通过后自动解析为 SQL 并执行：SELECT count(*) FROM Moment WHERE userId&#x3D;38710 LIMIT 1
{    TableName:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,    “msg”:”success”}  例如{    “Moment”:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,     “msg”:”success”}


GETS:  安全&#x2F;私密获取数据， 用于获取钱包等对安全性要求高的数据
base_url&#x2F;gets&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Privacy”，其它同GET
同GET


HEADS:  安全&#x2F;私密获取数量， 用于获取银行卡数量等对安全性要求高的数据总数
base_url&#x2F;heads&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Verify”，其它同HEAD
同HEAD


POST:  新增数据
base_url&#x2F;post&#x2F;
单个：  {    TableName:{      …    },    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 38710 发布一个新 Comment：{    “Comment”:{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”     },    “tag”:”Comment”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(38710,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;)    批量：  {    TableName[]:[{        …      }, {        …      }      …    ],    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 82001 发布 2 个 Comment：{    “Comment[]”:[{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”      }, {      “momentId”:15,      “content”:”APIJSON is a JSON transmision protocol.”    }],    “tag”:”Comment:[]”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(82001,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;);INSERT INTO Comment(userId,momentId,content) VALUES(82001,15,&#39;APIJSON is a JSON transmision protocol.&#39;);
单个：  {    TableName:{      “code”:200,      “msg”:”success”,      “id”:38710    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “id”:120    },    “code”:200,    “msg”:”success”}   批量：  {    TableName:{      “code”:200,      “msg”:”success”,      “count”:5,      “id[]”:[1, 2, 3, 4, 5]    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “count”:2,      “id[]”:[1, 2]    },    “code”:200,    “msg”:”success”}


PUT:  修改数据， 只修改所传的字段
base_url&#x2F;put&#x2F;
{    TableName:{      “id”:id,      …    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个 例如当前登录用户 82001 修改 id &#x3D; 235 的 Moment 的 content：{    “Moment”:{      “id”:235,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “tag”:”Moment”}  后端校验通过后自动解析为 SQL 并执行：UPDATE Moment SET content&#x3D;&#39;APIJSON,let interfaces and documents go to hell !&#39; WHERE id&#x3D;235 AND userId&#x3D;82001 LIMIT 1  批量除了 id{}:[] 也可类似批量 POST，只是每个 {…} 里面都必须有 id。“tag”:”Comment[]” 对应对象 “Comment”:{“id{}”:[1,2,3]}，表示指定记录全部统一设置；“tag”:”Comment:[]” 多了冒号，对应数组 “Comment[]”:[{“id”:1},{“id”:2},{“id”:3}]，表示每项单独设置
同POST


DELETE:  删除数据
base_url&#x2F;delete&#x2F;
{    TableName:{      “id”:id    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个，一般只传 id 或 id{} 例如当前登录用户 82001 批量删除 id &#x3D; 100,110,120 的 Comment：{    “Comment”:{      “id{}”:[100,110,120]    },    “tag”:”Comment[]”}  后端校验通过后自动解析为 SQL 并执行：DELETE FROM Comment WHERE id IN(100,110,120) AND userId&#x3D;82001 LIMIT 3
{    TableName:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120]      “count”:3    },    “code”:200,    “msg”:”success”}例如{   “Comment”:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120],      “count”:3   },   “code”:200,   “msg”:”success”}


以上接口的简单形式:  base_url&#x2F;{method}&#x2F;{tag}
GET: 普通获取数据  base_url&#x2F;get&#x2F;{tag}  HEAD: 普通获取数量  base_url&#x2F;head&#x2F;{tag}  GETS: 安全&#x2F;私密获取数据   base_url&#x2F;gets&#x2F;{tag}  HEADS: 安全&#x2F;私密获取数量  base_url&#x2F;heads&#x2F;{tag}  POST: 新增数据   base_url&#x2F;post&#x2F;{tag}  PUT: 修改数据  base_url&#x2F;put&#x2F;{tag}  DELETE: 删除数据  base_url&#x2F;delete&#x2F;{tag}
例如安全&#x2F;私密获取一个 id &#x3D; 82001 的 Privacy： base_url&#x2F;gets&#x2F;Privacy&#x2F;  {“id”:82001}  相当于  base_url&#x2F;gets&#x2F; {“tag”:”Privacy”, “Privacy”:{“id”:82001}}   例如批量修改 id &#x3D; 114, 124 的 Comment 的 content：base_url&#x2F;put&#x2F;Comemnt[]&#x2F;  {    “id{}”:[114,124],    “content”:”test multi put”}  相当于  base_url&#x2F;put&#x2F;  {    “tag”:”Comment[]”,     “Comment”:{      “id{}”:[114,124],      “content”:”test multi put”    }}
同以上对应的方法


1.TableName指要查询的数据库表Table的名称字符串。第一个字符为大写字母，剩下的字符要符合英语字母、数字、下划线中的任何一种。对应的值的类型为JSONObject，结构是 {…}，里面放的是Table的字段(列名)。下同。2.”tag”:tag 后面的tag是非GET、HEAD请求中匹配请求的JSON结构的标识，一般是要查询的Table的名称，由后端Request表中指定。下同。3.GET、HEAD请求是开放请求，可任意组合任意嵌套。其它请求为受限制的安全&#x2F;私密请求，对应的 方法（method）, 标识（tag）, 版本（version）, 结构（structure） 都必须和 后端Request表中所指定的 一一对应，否则请求将不被通过。version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本。下同。4.GETS与GET、HEADS与HEAD分别为同一类型的操作方法，请求稍有不同但返回结果相同。下同。5.在HTTP通信中，自动化接口(get,gets,head,heads,post,put,delete) 全用HTTP POST请求。下同。6.所有JSONObject都视为容器(或者文件夹)，结构为 {…} ，里面可以放普通对象或子容器。下同。7.每个对象都有一个唯一的路径(或者叫地址)，假设对象名为refKey，则用 key0&#x2F;key1&#x2F;…&#x2F;refKey 表示。下同。


3.2 功能符


功能
键值对格式
使用示例



查询数组
“key[]”:{}，后面是JSONObject，key可省略。当key和里面的Table名相同时，Table会被提取出来，即 {Table:{Content}} 会被转化为 {Content}
{“User[]”:{“User”:{}}}，查询一个User数组。这里key和Table名都是User，User会被提取出来，即 {“User”:{“id”, …}} 会被转化为 {“id”, …}，如果要进一步提取User中的id，可以把User[]改为User-id[]


匹配选项范围
“key{}”:[]，后面是JSONArray，作为key可取的值的选项
“id{}”:[38710,82001,70793]，对应SQL是id IN(38710,82001,70793)，查询id符合38710,82001,70793中任意一个的一个User数组


匹配条件范围
“key{}”:”条件0,条件1…”，条件为SQL表达式字符串，可进行数字比较运算等
“id{}”:”&lt;&#x3D;80000,&gt;90000”，对应SQL是id&lt;&#x3D;80000 OR id&gt;90000，查询id符合id&lt;&#x3D;80000 | id&gt;90000的一个User数组


包含选项范围
“key&lt;&gt;“:Object  &#x3D;&gt;  “key&lt;&gt;“:[Object]，key对应值的类型必须为JSONArray，Object类型不能为JSON
“contactIdList&lt;&gt;“:38710，对应SQL是json_contains(contactIdList,38710)，查询contactIdList包含38710的一个User数组


判断是否存在
“key}{@”:{    “from”:”Table”,    “Table”:{ … }}其中：}{ 表示 EXISTS； key 用来标识是哪个判断； @ 后面是 子查询 对象，具体见下方 子查询 的说明。
“id}{@”:{    “from”:”Comment”,    “Comment”:{        “momentId”:15     }} WHERE EXISTS(SELECT * FROM Comment WHERE momentId&#x3D;15)


远程调用函数
“key()”:”函数表达式”，函数表达式为 function(key0,key1…)，会调用后端对应的函数 function(JSONObject request, String key0, String key1…)，实现 参数校验、数值计算、数据同步、消息推送、字段拼接、结构变换 等特定的业务逻辑处理，可使用 - 和 + 表示优先级，解析 key-() &gt; 解析当前对象 &gt; 解析 key() &gt; 解析子对象 &gt; 解析 key+()
“isPraised()”:”isContain(praiseUserIdList,userId)”，会调用远程函数 boolean isContain(JSONObject request, String array, String value) ，然后变为 “isPraised”:true 这种（假设点赞用户id列表包含了userId，即这个User点了赞）


存储过程
“@key()”:”SQL函数表达式”，函数表达式为   function(key0,key1…)  会调用后端数据库对应的存储过程 SQL函数  function(String key0, String key1…)  除了参数会提前赋值，其它和 远程函数 一致
“@limit”:10,  “@offset”:0,  “@procedure()”:”getCommentByUserId(id,@limit,@offset)”  会转为  getCommentByUserId(38710,10,0)  来调用存储过程 SQL 函数  getCommentByUserId(IN id bigint, IN limit int, IN offset int)  然后变为 “procedure”:{    “count”:-1,     “update”:false,     “list”:[]  }  其中 count 是指写操作影响记录行数，-1 表示不是写操作；update 是指是否为写操作（增删改）；list 为返回结果集


引用赋值
“key@”:”key0&#x2F;key1&#x2F;…&#x2F;refKey”，引用路径为用&#x2F;分隔的字符串。以&#x2F;开头的是缺省引用路径，从声明key所处容器的父容器路径开始；其它是完整引用路径，从最外层开始。 被引用的refKey必须在声明key的上面。如果对refKey的容器指定了返回字段，则被引用的refKey必须写在@column对应的值内，例如 “@column”:”refKey,key1,…”
“Moment”:{    “userId”:38710},“User”:{    “id@”:”&#x2F;Moment&#x2F;userId”} User内的id引用了与User同级的Moment内的userId，即User.id &#x3D; Moment.userId，请求完成后 “id@”:”&#x2F;Moment&#x2F;userId” 会变成 “id”:38710


子查询
“key@”:{    “range”:”ALL”,     “from”:”Table”,    “Table”:{ … }}其中：range 可为 ALL,ANY；from 为目标表 Table 的名称；@ 后面的对象类似数组对象，可使用 count 和 join 等功能。
“id@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&#x3D;(SELECT min(userId) FROM Comment)


模糊搜索
&quot;key$&quot;:&quot;SQL搜索表达式&quot;  &#x3D;&gt;  &quot;key$&quot;:[&quot;SQL搜索表达式&quot;]，任意SQL搜索表达式字符串，如 %key%(包含key), key%(以key开始), %k%e%y%(包含字母k,e,y) 等，%表示任意字符
“name$”:”%m%”，对应SQL是name LIKE &#39;%m%&#39;，查询name包含”m”的一个User数组


正则匹配
“key“:”正则表达式”  &#x3D;&gt;  “key“:[“正则表达式”]，任意正则表达式字符串，如 ^[0-9]+$ ，*~ 忽略大小写，可用于高级搜索
“name~”:”^[0-9]+$”，对应SQL是name REGEXP &#39;^[0-9]+$&#39;，查询name中字符全为数字的一个User数组


连续范围
“key%”:”start,end”  &#x3D;&gt;  “key%”:[“start,end”]，其中 start 和 end 都只能为 Boolean, Number, String 中的一种，如 “2017-01-01,2019-01-01” ，[“1,90000”, “82001,100000”] ，可用于连续范围内的筛选
“date%”:”2017-10-01,2018-10-01”，对应SQL是date BETWEEN &#39;2017-10-01&#39; AND &#39;2018-10-01&#39;，查询在2017-10-01和2018-10-01期间注册的用户的一个User数组


新建别名
“name:alias”，name映射为alias，用alias替代name。可用于 column,Table,SQL函数 等。只用于GET类型、HEAD类型的请求
“@column”:”toId:parentId”，对应SQL是toId AS parentId，将查询的字段toId变为parentId返回


增加 或 扩展
“key+”:Object，Object的类型由key指定，且类型为Number,String,JSONArray中的一种。如 82001,”apijson”,[“url0”,”url1”] 等。只用于PUT请求
“praiseUserIdList+”:[82001]，对应SQL是json_insert(praiseUserIdList,82001)，添加一个点赞用户id，即这个用户点了赞


减少 或 去除
“key-“:Object，与”key+”相反
“balance-“:100.00，对应SQL是balance &#x3D; balance - 100.00，余额减少100.00，即花费了100元


比较运算
&gt;, &lt;, &gt;&#x3D;, &lt;&#x3D; 比较运算符，用于 ① 提供 “id{}”:”&lt;&#x3D;90000” 这种条件范围的简化写法 ② 实现子查询相关比较运算不支持 “key&#x3D;”:Object 和 “key!&#x3D;”:Object 这两种写法，直接用更简单的 “key”:Object 和 “key!”:Object 替代。
① “id&lt;&#x3D;”:90000，对应SQL是id&lt;&#x3D;90000，查询符合id&lt;&#x3D;90000的一个User数组 ② “id&gt;@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&gt;(SELECT min(userId) FROM Comment)


逻辑运算
&amp;, |, ! 逻辑运算符，对应数据库 SQL 中的 AND, OR, NOT。 横或纵与：同一键值对的值内条件默认 | 或连接，可以在 key 后加逻辑运算符来具体指定；不同键值对的条件默认 &amp; 与连接，可以用下面说明的对象关键词 @combine 来具体指定。 ① &amp; 可用于”key&amp;{}”:”条件”等② | 可用于”key|{}”:”条件”, “key|{}”:[]等，一般可省略③ ! 可单独使用，如”key!”:Object，也可像&amp;,|一样配合其他功能符使用  “key!”:null 无效，null 值会导致整个键值对被忽略解析，可以用 “key{}”:”!&#x3D;null” 替代，“key”:null 同理，用 “key{}”:”&#x3D;null” 替代。
① “id&amp;{}”:”&gt;80000,&lt;&#x3D;90000”，对应SQL是id&gt;80000 AND id&lt;&#x3D;90000，即id满足id&gt;80000 &amp; id&lt;&#x3D;90000 ② “id|{}”:”&gt;90000,&lt;&#x3D;80000”，同”id{}”:”&gt;90000,&lt;&#x3D;80000”，对应SQL是id&gt;80000 OR id&lt;&#x3D;90000，即id满足id&gt;90000 | id&lt;&#x3D;80000 ③ “id!{}”:[82001,38710]，对应SQL是id NOT IN(82001,38710)，即id满足 ! (id&#x3D;82001 | id&#x3D;38710)，可过滤黑名单的消息


数组关键词，可自定义
“key”:Object，key为 “[]”:{} 中{}内的关键词，Object的类型由key指定① “count”:Integer，查询数量，0 表示最大值，默认最大值为100 ② “page”:Integer，查询页码，从0开始，默认最大值为100，一般和count一起用③ “query”:Integer，查询内容0-对象，1-总数和分页详情，2-数据、总数和分页详情总数关键词为 total，分页详情关键词为 info， 它们都和 query 同级，通过引用赋值得到，例如  “total@”:”&#x2F;[]&#x2F;total”, “info@”:”&#x2F;[]&#x2F;info” 这里query及total仅为GET类型的请求提供方便， 一般可直接用HEAD类型的请求获取总数④ “join”:”&amp;&#x2F;Table0,&lt;&#x2F;Table1&#x2F;key1@” 或 “join”:{    “&amp;&#x2F;Table0”:{},  &#x2F;&#x2F; 支持 ON 多个字段关联,    “&lt;&#x2F;Table1&#x2F;key1@”:{  &#x2F;&#x2F; ON 只允许指定的 key1 关联      “key0”:value0,  &#x2F;&#x2F; 其它ON条件       “key2”:value2,      …       “@combine”:”…”,  &#x2F;&#x2F; 其它ON条件的组合方式       “@column”:”…”,  &#x2F;&#x2F; 外层 SELECT       “@group”:”…”,  &#x2F;&#x2F; 外层 GROUP BY       “@having”:”…”  &#x2F;&#x2F; 外层 HAVING     }}多表连接方式：  “@” - APP JOIN  “&lt;“ - LEFT JOIN  “&gt;” - RIGHT JOIN  “&amp;” - INNER JOIN  “|” - FULL JOIN   “!” - OUTER JOIN   “*” - CROSS JOIN   “^” - SIDE JOIN   “(“ - ANTI JOIN   “)” - FOREIGN JOIN 其中 @ APP JOIN 为应用层连表，会从已查出的主表里取得所有副表 key@ 关联的主表内的 refKey 作为一个数组 refKeys: [value0, value1…]，然后把原来副表 count 次查询 key&#x3D;$refKey 的 SQL 用 key IN($refKeys) 的方式合并为一条 SQL 来优化性能； 其它 JOIN 都是 SQL JOIN，具体功能和 MySQL,PostgreSQL 等数据库的 JOIN 一一对应 &quot;join&quot;:&quot;&lt;&#x2F;ViceTable&#x2F;key@&quot;,&quot;MainTable&quot;:{},&quot;ViceTable&quot;:{&quot;key@&quot;:&quot;&#x2F;MainTable&#x2F;refKey&quot;}会对应生成 MainTable LEFT JOIN ViceTable ON ViceTable.key&#x3D;MainTable.refKey AND 其它ON条件  除了 &#x3D; 等价关联，也支持 ! 不等关联、&gt; &lt; &gt;&#x3D; &lt;&#x3D; 等比较关联和 $ ~ {} &lt;&gt; 等其它复杂关联方式 ⑤ “otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 查询User数组，最多5个：“count”:5对应SQL是LIMIT 5  ② 查询第3页的User数组，每页5个：“count”:5,“page”:3对应SQL是LIMIT 5 OFFSET 15  ③ 查询User数组和对应的User总数：“[]”:{    “query”:2,    “User”:{}},“total@”:”&#x2F;[]&#x2F;total”,“info@”:”&#x2F;[]&#x2F;info” 返回的数据中，总数及分页详情结构为：   “total”:139,  &#x2F;&#x2F;总数  “info”:{  &#x2F;&#x2F;分页详情     “total”:139,  &#x2F;&#x2F;总数     “count”:5,  &#x2F;&#x2F;每页数量     “page”:0,  &#x2F;&#x2F;当前页码     “max”:27,  &#x2F;&#x2F;最大页码     “more”:true,  &#x2F;&#x2F;是否还有更多     “first”:true,  &#x2F;&#x2F;是否为首页     “last”:false  &#x2F;&#x2F;是否为尾页 }  ④ Moment INNER JOIN User LEFT JOIN Comment：“[]”:{    “join”:”&amp;&#x2F;User&#x2F;id@,&lt;&#x2F;Comment”,    “Moment”:{     “@group”:”id”  &#x2F;&#x2F;主副表不是一对一，要去除重复数据   },    “User”:{      “name~”:”t”,      “id@”:”&#x2F;Moment&#x2F;userId”    },    “Comment”:{      “momentId@”:”&#x2F;Moment&#x2F;id”    }} ⑤ 每一层都加当前用户名：“User”:{},“[]”:{    “name@”:”User&#x2F;name”, &#x2F;&#x2F;自定义关键词    “Moment”:{}}


对象关键词，可自定义
“@key”:Object，@key为 Table:{} 中{}内的关键词，Object的类型由@key指定① “@combine”:”key0 | (key1 &amp; (key2 | !key3))…”，条件组合方式，最终按  (其它key条件 AND 连接) AND (key0条件 OR (key1条件 AND (key2条件 OR (NOT key3条件)))) 这种方式连接，其中 “其它key” 是指与 @combine 在同一对象，且未被它声明的条件 key，默认都是 &amp; 连接。注意不要缺少或多余任何一个空格。 ② “@column”:”column;function(arg)…”，返回字段③ “@order”:”column0+,column1-…”，排序方式④ “@group”:”column0,column1…”，分组方式。如果@column里声明了Table的id，则id也必须在@group中声明；其它情况下必须满足至少一个条件:1.分组的key在@column里声明2.Table主键在@group中声明 ⑤ “@having”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…” &#x2F;&#x2F; OR 连接，或 “@having&amp;”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…”  &#x2F;&#x2F; AND 连接，或 “@having”:{   “h0”:”function0(…)?value0”,   “h1”:function1(…)?value1”,   “h2”:function2(…)?value2…”,   “@combine”:”h0 &amp; (h1 | !h2)”  &#x2F;&#x2F; 任意组合，非必传}SQL函数条件，一般和@group一起用，函数一般在@column里声明⑥ “@schema”:”sys”，集合空间(数据库名&#x2F;模式)，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑦ “@database”:”POSTGRESQL”，数据库类型，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑧ “@datasource”:”DRUID”，跨数据源，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑨ “@json”:”key0,key1…”，转为 JSON 格式返回，符合 JSONObject 则转为 {…}，符合 JSONArray 则转为 […] ⑩ “@role”:”OWNER”，来访角色，包括UNKNOWN,LOGIN,CONTACT,CIRCLE,OWNER,ADMIN，可以在最外层作为全局默认配置，可自定义其它角色并重写 Verifier.verify 等相关方法来自定义校验 ⑪ “@explain”:true，性能分析，可以在最外层作为全局默认配置 ⑫ “@raw”:”key0,key1…”，其中 key0, key1 都对应有键值对 “key0”:”SQL片段或SQL片段的别名”,  “key1”:”SQL片段或SQL片段的别名”  自定义原始SQL片段，可扩展嵌套SQL函数等复杂语句，必须是后端已配置的，只有其它功能符都做不到才考虑，谨慎使用，注意防SQL注入⑬ “@otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 搜索name或tag任何一个字段包含字符a的User列表： “name“:”a”,“tag“:”a”,“@combine”:”name~ | tag~” 对应SQL是name REGEXP &#39;a&#39; OR tag REGEXP &#39;a&#39;  ② 只查询id,sex,name这几列并且请求结果也按照这个顺序：“@column”:”id,sex,name”对应SQL是SELECT id,sex,name  ③ 查询按 name降序、id默认顺序 排序的User数组：“@order”:”name-,id”对应SQL是ORDER BY name DESC,id  ④ 查询按userId分组的Moment数组：“@group”:”userId,id”对应SQL是GROUP BY userId,id  ⑤ 查询 按userId分组、id最大值&gt;&#x3D;100 的Moment数组：“@column”:”userId;max(id)”,“@group”:”userId”,“@having”:”max(id)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) ... GROUP BY userId HAVING max(id)&gt;&#x3D;100 还可以指定函数返回名：“@column”:”userId;max(id):maxId”,“@group”:”userId”,“@having”:”(maxId)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) AS maxId ... GROUP BY userId HAVING (maxId)&gt;&#x3D;100  ⑥ 查询 sys 内的 User 表：“@schema”:”sys”对应SQL是FROM sys.User  ⑦ 查询 PostgreSQL 数据库的 User 表：“@database”:”POSTGRESQL” ⑧ 使用 Druid 连接池查询 User 表：“@datasource”:”DRUID” ⑨ 将 VARCHAR 字符串字段 get 转为 JSONArray 返回：“@json”:”get” ⑩ 查询当前用户的动态：“@role”:”OWNER” ⑪ 开启性能分析：“@explain”:true对应SQL是EXPLAIN  ⑫ 统计最近一周偶数userId的数量“@column”:”date;left(date,10):day;sum(if(userId%2&#x3D;0,1,0))”,“@group”:”day”,“@having”:”to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7”,“@raw”:”@column,@having”对应SQL是SELECT date, left(date,10) AS day, sum(if(userId%2&#x3D;0,1,0)) ... GROUP BY day HAVING to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7  ⑬ 从pictureList获取第0张图片：“@position”:0, &#x2F;&#x2F;自定义关键词“firstPicture()”:”getFromArray(pictureList,@position)”


全局关键词
为最外层对象 {} 内的关键词。其中 @database，@schema, @datasource, @role, @explain 基本同对象关键词，见上方说明，区别是全局关键词会每个表对象中没有时自动放入，作为默认值。 ① “tag”:String，后面的 tag 是非 GET、HEAD 请求中匹配请求的 JSON 结构的标识，一般是要查询的 Table 的名称或该名称对应的数组 Table[] 或 Table:[]，由后端 Request 表中指定。 ② “version”:Integer，接口版本，version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本，由后端 Request 表中指定。③ “format”:Boolean，格式化返回 Response JSON 的 key，一般是将 TableName 转为 tableName, TableName[] 转为 tableNameList, Table:alias 转为 alias, TableName-key[] 转为 tableNameKeyList 等小驼峰格式。
①  查隐私信息：[{“tag”:”Privacy”,”Privacy”:{“id”:82001}}](http:&#x2F;&#x2F;apijson.cn&#x2F;api?url&#x3D;http%3A%2F%2Fapijson.cn%3A8080%2Fgets&amp;type&#x3D;JSON&amp;json&#x3D;


</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2.3"><span class="toc-number">1.6.8.</span> <span class="toc-text">2.3 后端操作


后端操作
传统方式
APIJSON



解析和返回
取出键值对，把键值对作为条件用预设的的方式去查询数据库，最后封装JSON并返回给前端
把Parser#parse方法的返回值返回给前端就行


返回JSON结构的设定方式
由后端设定，前端不能修改
由前端设定，后端不能修改


 
 
2.4 前端解析


前端解析
传统方式
APIJSON



查看方式
查文档或问后端，或等请求成功后看日志
看请求就行，所求即所得，不用查、不用问、不用等。也可以等请求成功后看日志


解析方法
用JSON解析器来解析JSONObject
可以用JSONResponse解析JSONObject，或使用传统方式


 
 
2.5 前端对应不同需求的请求


前端的请求
传统方式
APIJSON



User
base_url&#x2F;get&#x2F;user?id&#x3D;38710
base_url&#x2F;get&#x2F;{    “User”:{      “id”:38710    }}


Moment和对应的User
分两次请求Moment:  base_url&#x2F;get&#x2F;moment?userId&#x3D;38710User:  base_url&#x2F;get&#x2F;user?id&#x3D;38710
base_url&#x2F;get&#x2F;{    “Moment”:{      “userId”:38710    },     “User”:{      “id”:38710    }}


User列表
base_url&#x2F;get&#x2F;user&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;sex&#x3D;0
base_url&#x2F;get&#x2F;{    “User[]”:{      “page”:0,       “count”:3,       “User”:{        “sex”:0      }    }}


Moment列表，每个Moment包括1.发布者User2.前3条Comment
Moment里必须有1.User对象2.Comment数组 base_url&#x2F;get&#x2F;moment&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;commentCount&#x3D;3
base_url&#x2F;get&#x2F;{    “[]”:{      “page”:0,       “count”:3,       “Moment”:{},       “User”:{        “id@”:”&#x2F;Moment&#x2F;userId”      },      “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }}


User发布的Moment列表， 每个Moment包括 1.发布者User 2.前3条Comment
1.Moment里必须有User对象和Comment数组 2.字段名必须查接口文档，例如评论数量字段名可能是 commentCount,comment_count或者简写cmt_count等各种奇葩写法…  base_url&#x2F;get&#x2F;moment&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;commentCount&#x3D;3&amp;userId&#x3D;38710
有以下几种方式: ① 把以上请求里的“Moment”:{}, “User”:{“id@”:”&#x2F;Moment&#x2F;userId”}改为“Moment”:{“userId”:38710}, “User”:{“id”:38710}  ② 或把User放在上面的最外层省去重复的Userbase_url&#x2F;get&#x2F;{    “User”:{      “id”:38710    },    “[]”:{      “page”:0,      “count”:3,       “Moment”:{        “userId”:38710      },       “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }} ③ 如果User之前已经获取到了，还可以不传User来节省请求和返回数据的流量并提升速度base_url&#x2F;get&#x2F;{    “[]”:{      “page”:0,      “count”:3,       “Moment”:{        “userId”:38710      },      “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }}


 
 
2.6 后端对应不同请求的返回结果


后端的返回结果
传统方式
APIJSON



User
{    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
{    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


Moment和对应的User
分别返回两次请求的结果，获取到Moment后取出userId作为User的id条件去查询User  Moment:  {    “data”:{      “id”:235,      “content”:”xxx”,      …    },    “code”:200,    “msg”:”success”}  User:  {    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
一次性返回，没有传统方式导致的 长时间等待结果、两次结果间关联、线程多次切换 等问题  {    “Moment”:{      “id”:235,      “content”:”xxx”,      …    },    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


User列表
{    “data”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}
{    “User[]”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}


Moment列表，每个Moment包括发布者User和前3条Comment
Moment里必须有1.User对象2.Comment数组  {    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          …        },        “Comment”:[          …        ]      },      {        “id”:301,        “content”:”xxx”,        …,        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}
1.高灵活，可任意组合2.低耦合，逻辑很清晰{    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          …        },        “Comment[]”:[          …        ]      },      {        “Moment”:{          “id”:301,          “content”:”xxx”,          …        },        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}


User发布的Moment列表，每个Moment包括发布者User和前3条Comment
1.大量重复User，浪费流量和服务器性能2.优化很繁琐，需要后端扩展接口、写好文档，前端&#x2F;前端再配合优化{    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:470,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:511,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:595,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      …    ],    “code”:200,    “msg”:”success”}
以上不同请求方式的结果: ① 常规请求  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ② 省去重复的User  {    “User”:{      “id”:38710,      “name”:”Tommy”,      …    },    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ③ 不查询已获取到的User  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”}


1.base_url指基地址，一般是顶级域名，其它分支url都是在base_url后扩展。如base_url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F; ，对应的GET分支url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F;get&#x2F; 。下同。2.请求中的key或value任意一个为null值时，这个 key:value键值对 被视为无效。下同。3.请求中的 &#x2F; 需要转义。JSONRequest.java已经用URLEncoder.encode转义，不需要再写；但如果是浏览器或Postman等直接输入url&#x2F;request，需要把request中的所有 &#x2F; 都改成 %252F 。下同。4.code，指返回结果中的状态码，200表示成功，其它都是错误码，值全部都是HTTP标准状态码。下同。5.msg，指返回结果中的状态信息，对成功结果或错误原因的详细说明。下同。6.code和msg总是在返回结果的同一层级成对出现。对所有请求的返回结果都会在最外层有一对总结式code和msg。下同。7.id等字段对应的值仅供说明，不一定是数据库里存在的，请求里用的是真实存在的值。下同。



3.设计规范3.1 操作方法


方法及说明
URL
Request
Response



GET:  普通获取数据， 可用浏览器调试
base_url&#x2F;get&#x2F;
{    TableName:{      …     }}  {…}内为限制条件 例如获取一个 id &#x3D; 235 的 Moment： {    “Moment”:{      “id”:235    }}  后端校验通过后自动解析为 SQL 并执行：SELECT * FROM Moment WHERE id&#x3D;235 LIMIT 1
{    TableName:{      …    },    “code”:200,    “msg”:”success”}例如{    “Moment”:{      “id”:235,      “userId”:38710,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “code”:200,    “msg”:”success” }


HEAD:  普通获取数量， 可用浏览器调试
base_url&#x2F;head&#x2F;
{    TableName:{      …    } }  {…}内为限制条件  例如获取一个 id &#x3D; 38710 的 User 所发布的 Moment 总数： {    “Moment”:{      “userId”:38710    }}  后端校验通过后自动解析为 SQL 并执行：SELECT count(*) FROM Moment WHERE userId&#x3D;38710 LIMIT 1
{    TableName:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,    “msg”:”success”}  例如{    “Moment”:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,     “msg”:”success”}


GETS:  安全&#x2F;私密获取数据， 用于获取钱包等对安全性要求高的数据
base_url&#x2F;gets&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Privacy”，其它同GET
同GET


HEADS:  安全&#x2F;私密获取数量， 用于获取银行卡数量等对安全性要求高的数据总数
base_url&#x2F;heads&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Verify”，其它同HEAD
同HEAD


POST:  新增数据
base_url&#x2F;post&#x2F;
单个：  {    TableName:{      …    },    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 38710 发布一个新 Comment：{    “Comment”:{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”     },    “tag”:”Comment”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(38710,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;)    批量：  {    TableName[]:[{        …      }, {        …      }      …    ],    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 82001 发布 2 个 Comment：{    “Comment[]”:[{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”      }, {      “momentId”:15,      “content”:”APIJSON is a JSON transmision protocol.”    }],    “tag”:”Comment:[]”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(82001,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;);INSERT INTO Comment(userId,momentId,content) VALUES(82001,15,&#39;APIJSON is a JSON transmision protocol.&#39;);
单个：  {    TableName:{      “code”:200,      “msg”:”success”,      “id”:38710    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “id”:120    },    “code”:200,    “msg”:”success”}   批量：  {    TableName:{      “code”:200,      “msg”:”success”,      “count”:5,      “id[]”:[1, 2, 3, 4, 5]    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “count”:2,      “id[]”:[1, 2]    },    “code”:200,    “msg”:”success”}


PUT:  修改数据， 只修改所传的字段
base_url&#x2F;put&#x2F;
{    TableName:{      “id”:id,      …    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个 例如当前登录用户 82001 修改 id &#x3D; 235 的 Moment 的 content：{    “Moment”:{      “id”:235,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “tag”:”Moment”}  后端校验通过后自动解析为 SQL 并执行：UPDATE Moment SET content&#x3D;&#39;APIJSON,let interfaces and documents go to hell !&#39; WHERE id&#x3D;235 AND userId&#x3D;82001 LIMIT 1  批量除了 id{}:[] 也可类似批量 POST，只是每个 {…} 里面都必须有 id。“tag”:”Comment[]” 对应对象 “Comment”:{“id{}”:[1,2,3]}，表示指定记录全部统一设置；“tag”:”Comment:[]” 多了冒号，对应数组 “Comment[]”:[{“id”:1},{“id”:2},{“id”:3}]，表示每项单独设置
同POST


DELETE:  删除数据
base_url&#x2F;delete&#x2F;
{    TableName:{      “id”:id    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个，一般只传 id 或 id{} 例如当前登录用户 82001 批量删除 id &#x3D; 100,110,120 的 Comment：{    “Comment”:{      “id{}”:[100,110,120]    },    “tag”:”Comment[]”}  后端校验通过后自动解析为 SQL 并执行：DELETE FROM Comment WHERE id IN(100,110,120) AND userId&#x3D;82001 LIMIT 3
{    TableName:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120]      “count”:3    },    “code”:200,    “msg”:”success”}例如{   “Comment”:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120],      “count”:3   },   “code”:200,   “msg”:”success”}


以上接口的简单形式:  base_url&#x2F;{method}&#x2F;{tag}
GET: 普通获取数据  base_url&#x2F;get&#x2F;{tag}  HEAD: 普通获取数量  base_url&#x2F;head&#x2F;{tag}  GETS: 安全&#x2F;私密获取数据   base_url&#x2F;gets&#x2F;{tag}  HEADS: 安全&#x2F;私密获取数量  base_url&#x2F;heads&#x2F;{tag}  POST: 新增数据   base_url&#x2F;post&#x2F;{tag}  PUT: 修改数据  base_url&#x2F;put&#x2F;{tag}  DELETE: 删除数据  base_url&#x2F;delete&#x2F;{tag}
例如安全&#x2F;私密获取一个 id &#x3D; 82001 的 Privacy： base_url&#x2F;gets&#x2F;Privacy&#x2F;  {“id”:82001}  相当于  base_url&#x2F;gets&#x2F; {“tag”:”Privacy”, “Privacy”:{“id”:82001}}   例如批量修改 id &#x3D; 114, 124 的 Comment 的 content：base_url&#x2F;put&#x2F;Comemnt[]&#x2F;  {    “id{}”:[114,124],    “content”:”test multi put”}  相当于  base_url&#x2F;put&#x2F;  {    “tag”:”Comment[]”,     “Comment”:{      “id{}”:[114,124],      “content”:”test multi put”    }}
同以上对应的方法


1.TableName指要查询的数据库表Table的名称字符串。第一个字符为大写字母，剩下的字符要符合英语字母、数字、下划线中的任何一种。对应的值的类型为JSONObject，结构是 {…}，里面放的是Table的字段(列名)。下同。2.”tag”:tag 后面的tag是非GET、HEAD请求中匹配请求的JSON结构的标识，一般是要查询的Table的名称，由后端Request表中指定。下同。3.GET、HEAD请求是开放请求，可任意组合任意嵌套。其它请求为受限制的安全&#x2F;私密请求，对应的 方法（method）, 标识（tag）, 版本（version）, 结构（structure） 都必须和 后端Request表中所指定的 一一对应，否则请求将不被通过。version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本。下同。4.GETS与GET、HEADS与HEAD分别为同一类型的操作方法，请求稍有不同但返回结果相同。下同。5.在HTTP通信中，自动化接口(get,gets,head,heads,post,put,delete) 全用HTTP POST请求。下同。6.所有JSONObject都视为容器(或者文件夹)，结构为 {…} ，里面可以放普通对象或子容器。下同。7.每个对象都有一个唯一的路径(或者叫地址)，假设对象名为refKey，则用 key0&#x2F;key1&#x2F;…&#x2F;refKey 表示。下同。


3.2 功能符


功能
键值对格式
使用示例



查询数组
“key[]”:{}，后面是JSONObject，key可省略。当key和里面的Table名相同时，Table会被提取出来，即 {Table:{Content}} 会被转化为 {Content}
{“User[]”:{“User”:{}}}，查询一个User数组。这里key和Table名都是User，User会被提取出来，即 {“User”:{“id”, …}} 会被转化为 {“id”, …}，如果要进一步提取User中的id，可以把User[]改为User-id[]


匹配选项范围
“key{}”:[]，后面是JSONArray，作为key可取的值的选项
“id{}”:[38710,82001,70793]，对应SQL是id IN(38710,82001,70793)，查询id符合38710,82001,70793中任意一个的一个User数组


匹配条件范围
“key{}”:”条件0,条件1…”，条件为SQL表达式字符串，可进行数字比较运算等
“id{}”:”&lt;&#x3D;80000,&gt;90000”，对应SQL是id&lt;&#x3D;80000 OR id&gt;90000，查询id符合id&lt;&#x3D;80000 | id&gt;90000的一个User数组


包含选项范围
“key&lt;&gt;“:Object  &#x3D;&gt;  “key&lt;&gt;“:[Object]，key对应值的类型必须为JSONArray，Object类型不能为JSON
“contactIdList&lt;&gt;“:38710，对应SQL是json_contains(contactIdList,38710)，查询contactIdList包含38710的一个User数组


判断是否存在
“key}{@”:{    “from”:”Table”,    “Table”:{ … }}其中：}{ 表示 EXISTS； key 用来标识是哪个判断； @ 后面是 子查询 对象，具体见下方 子查询 的说明。
“id}{@”:{    “from”:”Comment”,    “Comment”:{        “momentId”:15     }} WHERE EXISTS(SELECT * FROM Comment WHERE momentId&#x3D;15)


远程调用函数
“key()”:”函数表达式”，函数表达式为 function(key0,key1…)，会调用后端对应的函数 function(JSONObject request, String key0, String key1…)，实现 参数校验、数值计算、数据同步、消息推送、字段拼接、结构变换 等特定的业务逻辑处理，可使用 - 和 + 表示优先级，解析 key-() &gt; 解析当前对象 &gt; 解析 key() &gt; 解析子对象 &gt; 解析 key+()
“isPraised()”:”isContain(praiseUserIdList,userId)”，会调用远程函数 boolean isContain(JSONObject request, String array, String value) ，然后变为 “isPraised”:true 这种（假设点赞用户id列表包含了userId，即这个User点了赞）


存储过程
“@key()”:”SQL函数表达式”，函数表达式为   function(key0,key1…)  会调用后端数据库对应的存储过程 SQL函数  function(String key0, String key1…)  除了参数会提前赋值，其它和 远程函数 一致
“@limit”:10,  “@offset”:0,  “@procedure()”:”getCommentByUserId(id,@limit,@offset)”  会转为  getCommentByUserId(38710,10,0)  来调用存储过程 SQL 函数  getCommentByUserId(IN id bigint, IN limit int, IN offset int)  然后变为 “procedure”:{    “count”:-1,     “update”:false,     “list”:[]  }  其中 count 是指写操作影响记录行数，-1 表示不是写操作；update 是指是否为写操作（增删改）；list 为返回结果集


引用赋值
“key@”:”key0&#x2F;key1&#x2F;…&#x2F;refKey”，引用路径为用&#x2F;分隔的字符串。以&#x2F;开头的是缺省引用路径，从声明key所处容器的父容器路径开始；其它是完整引用路径，从最外层开始。 被引用的refKey必须在声明key的上面。如果对refKey的容器指定了返回字段，则被引用的refKey必须写在@column对应的值内，例如 “@column”:”refKey,key1,…”
“Moment”:{    “userId”:38710},“User”:{    “id@”:”&#x2F;Moment&#x2F;userId”} User内的id引用了与User同级的Moment内的userId，即User.id &#x3D; Moment.userId，请求完成后 “id@”:”&#x2F;Moment&#x2F;userId” 会变成 “id”:38710


子查询
“key@”:{    “range”:”ALL”,     “from”:”Table”,    “Table”:{ … }}其中：range 可为 ALL,ANY；from 为目标表 Table 的名称；@ 后面的对象类似数组对象，可使用 count 和 join 等功能。
“id@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&#x3D;(SELECT min(userId) FROM Comment)


模糊搜索
&quot;key$&quot;:&quot;SQL搜索表达式&quot;  &#x3D;&gt;  &quot;key$&quot;:[&quot;SQL搜索表达式&quot;]，任意SQL搜索表达式字符串，如 %key%(包含key), key%(以key开始), %k%e%y%(包含字母k,e,y) 等，%表示任意字符
“name$”:”%m%”，对应SQL是name LIKE &#39;%m%&#39;，查询name包含”m”的一个User数组


正则匹配
“key“:”正则表达式”  &#x3D;&gt;  “key“:[“正则表达式”]，任意正则表达式字符串，如 ^[0-9]+$ ，*~ 忽略大小写，可用于高级搜索
“name~”:”^[0-9]+$”，对应SQL是name REGEXP &#39;^[0-9]+$&#39;，查询name中字符全为数字的一个User数组


连续范围
“key%”:”start,end”  &#x3D;&gt;  “key%”:[“start,end”]，其中 start 和 end 都只能为 Boolean, Number, String 中的一种，如 “2017-01-01,2019-01-01” ，[“1,90000”, “82001,100000”] ，可用于连续范围内的筛选
“date%”:”2017-10-01,2018-10-01”，对应SQL是date BETWEEN &#39;2017-10-01&#39; AND &#39;2018-10-01&#39;，查询在2017-10-01和2018-10-01期间注册的用户的一个User数组


新建别名
“name:alias”，name映射为alias，用alias替代name。可用于 column,Table,SQL函数 等。只用于GET类型、HEAD类型的请求
“@column”:”toId:parentId”，对应SQL是toId AS parentId，将查询的字段toId变为parentId返回


增加 或 扩展
“key+”:Object，Object的类型由key指定，且类型为Number,String,JSONArray中的一种。如 82001,”apijson”,[“url0”,”url1”] 等。只用于PUT请求
“praiseUserIdList+”:[82001]，对应SQL是json_insert(praiseUserIdList,82001)，添加一个点赞用户id，即这个用户点了赞


减少 或 去除
“key-“:Object，与”key+”相反
“balance-“:100.00，对应SQL是balance &#x3D; balance - 100.00，余额减少100.00，即花费了100元


比较运算
&gt;, &lt;, &gt;&#x3D;, &lt;&#x3D; 比较运算符，用于 ① 提供 “id{}”:”&lt;&#x3D;90000” 这种条件范围的简化写法 ② 实现子查询相关比较运算不支持 “key&#x3D;”:Object 和 “key!&#x3D;”:Object 这两种写法，直接用更简单的 “key”:Object 和 “key!”:Object 替代。
① “id&lt;&#x3D;”:90000，对应SQL是id&lt;&#x3D;90000，查询符合id&lt;&#x3D;90000的一个User数组 ② “id&gt;@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&gt;(SELECT min(userId) FROM Comment)


逻辑运算
&amp;, |, ! 逻辑运算符，对应数据库 SQL 中的 AND, OR, NOT。 横或纵与：同一键值对的值内条件默认 | 或连接，可以在 key 后加逻辑运算符来具体指定；不同键值对的条件默认 &amp; 与连接，可以用下面说明的对象关键词 @combine 来具体指定。 ① &amp; 可用于”key&amp;{}”:”条件”等② | 可用于”key|{}”:”条件”, “key|{}”:[]等，一般可省略③ ! 可单独使用，如”key!”:Object，也可像&amp;,|一样配合其他功能符使用  “key!”:null 无效，null 值会导致整个键值对被忽略解析，可以用 “key{}”:”!&#x3D;null” 替代，“key”:null 同理，用 “key{}”:”&#x3D;null” 替代。
① “id&amp;{}”:”&gt;80000,&lt;&#x3D;90000”，对应SQL是id&gt;80000 AND id&lt;&#x3D;90000，即id满足id&gt;80000 &amp; id&lt;&#x3D;90000 ② “id|{}”:”&gt;90000,&lt;&#x3D;80000”，同”id{}”:”&gt;90000,&lt;&#x3D;80000”，对应SQL是id&gt;80000 OR id&lt;&#x3D;90000，即id满足id&gt;90000 | id&lt;&#x3D;80000 ③ “id!{}”:[82001,38710]，对应SQL是id NOT IN(82001,38710)，即id满足 ! (id&#x3D;82001 | id&#x3D;38710)，可过滤黑名单的消息


数组关键词，可自定义
“key”:Object，key为 “[]”:{} 中{}内的关键词，Object的类型由key指定① “count”:Integer，查询数量，0 表示最大值，默认最大值为100 ② “page”:Integer，查询页码，从0开始，默认最大值为100，一般和count一起用③ “query”:Integer，查询内容0-对象，1-总数和分页详情，2-数据、总数和分页详情总数关键词为 total，分页详情关键词为 info， 它们都和 query 同级，通过引用赋值得到，例如  “total@”:”&#x2F;[]&#x2F;total”, “info@”:”&#x2F;[]&#x2F;info” 这里query及total仅为GET类型的请求提供方便， 一般可直接用HEAD类型的请求获取总数④ “join”:”&amp;&#x2F;Table0,&lt;&#x2F;Table1&#x2F;key1@” 或 “join”:{    “&amp;&#x2F;Table0”:{},  &#x2F;&#x2F; 支持 ON 多个字段关联,    “&lt;&#x2F;Table1&#x2F;key1@”:{  &#x2F;&#x2F; ON 只允许指定的 key1 关联      “key0”:value0,  &#x2F;&#x2F; 其它ON条件       “key2”:value2,      …       “@combine”:”…”,  &#x2F;&#x2F; 其它ON条件的组合方式       “@column”:”…”,  &#x2F;&#x2F; 外层 SELECT       “@group”:”…”,  &#x2F;&#x2F; 外层 GROUP BY       “@having”:”…”  &#x2F;&#x2F; 外层 HAVING     }}多表连接方式：  “@” - APP JOIN  “&lt;“ - LEFT JOIN  “&gt;” - RIGHT JOIN  “&amp;” - INNER JOIN  “|” - FULL JOIN   “!” - OUTER JOIN   “*” - CROSS JOIN   “^” - SIDE JOIN   “(“ - ANTI JOIN   “)” - FOREIGN JOIN 其中 @ APP JOIN 为应用层连表，会从已查出的主表里取得所有副表 key@ 关联的主表内的 refKey 作为一个数组 refKeys: [value0, value1…]，然后把原来副表 count 次查询 key&#x3D;$refKey 的 SQL 用 key IN($refKeys) 的方式合并为一条 SQL 来优化性能； 其它 JOIN 都是 SQL JOIN，具体功能和 MySQL,PostgreSQL 等数据库的 JOIN 一一对应 &quot;join&quot;:&quot;&lt;&#x2F;ViceTable&#x2F;key@&quot;,&quot;MainTable&quot;:{},&quot;ViceTable&quot;:{&quot;key@&quot;:&quot;&#x2F;MainTable&#x2F;refKey&quot;}会对应生成 MainTable LEFT JOIN ViceTable ON ViceTable.key&#x3D;MainTable.refKey AND 其它ON条件  除了 &#x3D; 等价关联，也支持 ! 不等关联、&gt; &lt; &gt;&#x3D; &lt;&#x3D; 等比较关联和 $ ~ {} &lt;&gt; 等其它复杂关联方式 ⑤ “otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 查询User数组，最多5个：“count”:5对应SQL是LIMIT 5  ② 查询第3页的User数组，每页5个：“count”:5,“page”:3对应SQL是LIMIT 5 OFFSET 15  ③ 查询User数组和对应的User总数：“[]”:{    “query”:2,    “User”:{}},“total@”:”&#x2F;[]&#x2F;total”,“info@”:”&#x2F;[]&#x2F;info” 返回的数据中，总数及分页详情结构为：   “total”:139,  &#x2F;&#x2F;总数  “info”:{  &#x2F;&#x2F;分页详情     “total”:139,  &#x2F;&#x2F;总数     “count”:5,  &#x2F;&#x2F;每页数量     “page”:0,  &#x2F;&#x2F;当前页码     “max”:27,  &#x2F;&#x2F;最大页码     “more”:true,  &#x2F;&#x2F;是否还有更多     “first”:true,  &#x2F;&#x2F;是否为首页     “last”:false  &#x2F;&#x2F;是否为尾页 }  ④ Moment INNER JOIN User LEFT JOIN Comment：“[]”:{    “join”:”&amp;&#x2F;User&#x2F;id@,&lt;&#x2F;Comment”,    “Moment”:{     “@group”:”id”  &#x2F;&#x2F;主副表不是一对一，要去除重复数据   },    “User”:{      “name~”:”t”,      “id@”:”&#x2F;Moment&#x2F;userId”    },    “Comment”:{      “momentId@”:”&#x2F;Moment&#x2F;id”    }} ⑤ 每一层都加当前用户名：“User”:{},“[]”:{    “name@”:”User&#x2F;name”, &#x2F;&#x2F;自定义关键词    “Moment”:{}}


对象关键词，可自定义
“@key”:Object，@key为 Table:{} 中{}内的关键词，Object的类型由@key指定① “@combine”:”key0 | (key1 &amp; (key2 | !key3))…”，条件组合方式，最终按  (其它key条件 AND 连接) AND (key0条件 OR (key1条件 AND (key2条件 OR (NOT key3条件)))) 这种方式连接，其中 “其它key” 是指与 @combine 在同一对象，且未被它声明的条件 key，默认都是 &amp; 连接。注意不要缺少或多余任何一个空格。 ② “@column”:”column;function(arg)…”，返回字段③ “@order”:”column0+,column1-…”，排序方式④ “@group”:”column0,column1…”，分组方式。如果@column里声明了Table的id，则id也必须在@group中声明；其它情况下必须满足至少一个条件:1.分组的key在@column里声明2.Table主键在@group中声明 ⑤ “@having”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…” &#x2F;&#x2F; OR 连接，或 “@having&amp;”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…”  &#x2F;&#x2F; AND 连接，或 “@having”:{   “h0”:”function0(…)?value0”,   “h1”:function1(…)?value1”,   “h2”:function2(…)?value2…”,   “@combine”:”h0 &amp; (h1 | !h2)”  &#x2F;&#x2F; 任意组合，非必传}SQL函数条件，一般和@group一起用，函数一般在@column里声明⑥ “@schema”:”sys”，集合空间(数据库名&#x2F;模式)，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑦ “@database”:”POSTGRESQL”，数据库类型，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑧ “@datasource”:”DRUID”，跨数据源，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑨ “@json”:”key0,key1…”，转为 JSON 格式返回，符合 JSONObject 则转为 {…}，符合 JSONArray 则转为 […] ⑩ “@role”:”OWNER”，来访角色，包括UNKNOWN,LOGIN,CONTACT,CIRCLE,OWNER,ADMIN，可以在最外层作为全局默认配置，可自定义其它角色并重写 Verifier.verify 等相关方法来自定义校验 ⑪ “@explain”:true，性能分析，可以在最外层作为全局默认配置 ⑫ “@raw”:”key0,key1…”，其中 key0, key1 都对应有键值对 “key0”:”SQL片段或SQL片段的别名”,  “key1”:”SQL片段或SQL片段的别名”  自定义原始SQL片段，可扩展嵌套SQL函数等复杂语句，必须是后端已配置的，只有其它功能符都做不到才考虑，谨慎使用，注意防SQL注入⑬ “@otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 搜索name或tag任何一个字段包含字符a的User列表： “name“:”a”,“tag“:”a”,“@combine”:”name~ | tag~” 对应SQL是name REGEXP &#39;a&#39; OR tag REGEXP &#39;a&#39;  ② 只查询id,sex,name这几列并且请求结果也按照这个顺序：“@column”:”id,sex,name”对应SQL是SELECT id,sex,name  ③ 查询按 name降序、id默认顺序 排序的User数组：“@order”:”name-,id”对应SQL是ORDER BY name DESC,id  ④ 查询按userId分组的Moment数组：“@group”:”userId,id”对应SQL是GROUP BY userId,id  ⑤ 查询 按userId分组、id最大值&gt;&#x3D;100 的Moment数组：“@column”:”userId;max(id)”,“@group”:”userId”,“@having”:”max(id)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) ... GROUP BY userId HAVING max(id)&gt;&#x3D;100 还可以指定函数返回名：“@column”:”userId;max(id):maxId”,“@group”:”userId”,“@having”:”(maxId)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) AS maxId ... GROUP BY userId HAVING (maxId)&gt;&#x3D;100  ⑥ 查询 sys 内的 User 表：“@schema”:”sys”对应SQL是FROM sys.User  ⑦ 查询 PostgreSQL 数据库的 User 表：“@database”:”POSTGRESQL” ⑧ 使用 Druid 连接池查询 User 表：“@datasource”:”DRUID” ⑨ 将 VARCHAR 字符串字段 get 转为 JSONArray 返回：“@json”:”get” ⑩ 查询当前用户的动态：“@role”:”OWNER” ⑪ 开启性能分析：“@explain”:true对应SQL是EXPLAIN  ⑫ 统计最近一周偶数userId的数量“@column”:”date;left(date,10):day;sum(if(userId%2&#x3D;0,1,0))”,“@group”:”day”,“@having”:”to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7”,“@raw”:”@column,@having”对应SQL是SELECT date, left(date,10) AS day, sum(if(userId%2&#x3D;0,1,0)) ... GROUP BY day HAVING to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7  ⑬ 从pictureList获取第0张图片：“@position”:0, &#x2F;&#x2F;自定义关键词“firstPicture()”:”getFromArray(pictureList,@position)”


全局关键词
为最外层对象 {} 内的关键词。其中 @database，@schema, @datasource, @role, @explain 基本同对象关键词，见上方说明，区别是全局关键词会每个表对象中没有时自动放入，作为默认值。 ① “tag”:String，后面的 tag 是非 GET、HEAD 请求中匹配请求的 JSON 结构的标识，一般是要查询的 Table 的名称或该名称对应的数组 Table[] 或 Table:[]，由后端 Request 表中指定。 ② “version”:Integer，接口版本，version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本，由后端 Request 表中指定。③ “format”:Boolean，格式化返回 Response JSON 的 key，一般是将 TableName 转为 tableName, TableName[] 转为 tableNameList, Table:alias 转为 alias, TableName-key[] 转为 tableNameKeyList 等小驼峰格式。
①  查隐私信息：[{“tag”:”Privacy”,”Privacy”:{“id”:82001}}](http:&#x2F;&#x2F;apijson.cn&#x2F;api?url&#x3D;http%3A%2F%2Fapijson.cn%3A8080%2Fgets&amp;type&#x3D;JSON&amp;json&#x3D;


</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2.3"><span class="toc-number">1.6.9.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%89%8D%E7%AB%AF%E8%A7%A3%E6%9E%90"><span class="toc-number">1.6.10.</span> <span class="toc-text">2.4 前端解析


前端解析
传统方式
APIJSON



查看方式
查文档或问后端，或等请求成功后看日志
看请求就行，所求即所得，不用查、不用问、不用等。也可以等请求成功后看日志


解析方法
用JSON解析器来解析JSONObject
可以用JSONResponse解析JSONObject，或使用传统方式


 
 
2.5 前端对应不同需求的请求


前端的请求
传统方式
APIJSON



User
base_url&#x2F;get&#x2F;user?id&#x3D;38710
base_url&#x2F;get&#x2F;{    “User”:{      “id”:38710    }}


Moment和对应的User
分两次请求Moment:  base_url&#x2F;get&#x2F;moment?userId&#x3D;38710User:  base_url&#x2F;get&#x2F;user?id&#x3D;38710
base_url&#x2F;get&#x2F;{    “Moment”:{      “userId”:38710    },     “User”:{      “id”:38710    }}


User列表
base_url&#x2F;get&#x2F;user&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;sex&#x3D;0
base_url&#x2F;get&#x2F;{    “User[]”:{      “page”:0,       “count”:3,       “User”:{        “sex”:0      }    }}


Moment列表，每个Moment包括1.发布者User2.前3条Comment
Moment里必须有1.User对象2.Comment数组 base_url&#x2F;get&#x2F;moment&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;commentCount&#x3D;3
base_url&#x2F;get&#x2F;{    “[]”:{      “page”:0,       “count”:3,       “Moment”:{},       “User”:{        “id@”:”&#x2F;Moment&#x2F;userId”      },      “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }}


User发布的Moment列表， 每个Moment包括 1.发布者User 2.前3条Comment
1.Moment里必须有User对象和Comment数组 2.字段名必须查接口文档，例如评论数量字段名可能是 commentCount,comment_count或者简写cmt_count等各种奇葩写法…  base_url&#x2F;get&#x2F;moment&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;commentCount&#x3D;3&amp;userId&#x3D;38710
有以下几种方式: ① 把以上请求里的“Moment”:{}, “User”:{“id@”:”&#x2F;Moment&#x2F;userId”}改为“Moment”:{“userId”:38710}, “User”:{“id”:38710}  ② 或把User放在上面的最外层省去重复的Userbase_url&#x2F;get&#x2F;{    “User”:{      “id”:38710    },    “[]”:{      “page”:0,      “count”:3,       “Moment”:{        “userId”:38710      },       “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }} ③ 如果User之前已经获取到了，还可以不传User来节省请求和返回数据的流量并提升速度base_url&#x2F;get&#x2F;{    “[]”:{      “page”:0,      “count”:3,       “Moment”:{        “userId”:38710      },      “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }}


 
 
2.6 后端对应不同请求的返回结果


后端的返回结果
传统方式
APIJSON



User
{    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
{    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


Moment和对应的User
分别返回两次请求的结果，获取到Moment后取出userId作为User的id条件去查询User  Moment:  {    “data”:{      “id”:235,      “content”:”xxx”,      …    },    “code”:200,    “msg”:”success”}  User:  {    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
一次性返回，没有传统方式导致的 长时间等待结果、两次结果间关联、线程多次切换 等问题  {    “Moment”:{      “id”:235,      “content”:”xxx”,      …    },    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


User列表
{    “data”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}
{    “User[]”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}


Moment列表，每个Moment包括发布者User和前3条Comment
Moment里必须有1.User对象2.Comment数组  {    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          …        },        “Comment”:[          …        ]      },      {        “id”:301,        “content”:”xxx”,        …,        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}
1.高灵活，可任意组合2.低耦合，逻辑很清晰{    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          …        },        “Comment[]”:[          …        ]      },      {        “Moment”:{          “id”:301,          “content”:”xxx”,          …        },        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}


User发布的Moment列表，每个Moment包括发布者User和前3条Comment
1.大量重复User，浪费流量和服务器性能2.优化很繁琐，需要后端扩展接口、写好文档，前端&#x2F;前端再配合优化{    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:470,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:511,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:595,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      …    ],    “code”:200,    “msg”:”success”}
以上不同请求方式的结果: ① 常规请求  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ② 省去重复的User  {    “User”:{      “id”:38710,      “name”:”Tommy”,      …    },    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ③ 不查询已获取到的User  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”}


1.base_url指基地址，一般是顶级域名，其它分支url都是在base_url后扩展。如base_url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F; ，对应的GET分支url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F;get&#x2F; 。下同。2.请求中的key或value任意一个为null值时，这个 key:value键值对 被视为无效。下同。3.请求中的 &#x2F; 需要转义。JSONRequest.java已经用URLEncoder.encode转义，不需要再写；但如果是浏览器或Postman等直接输入url&#x2F;request，需要把request中的所有 &#x2F; 都改成 %252F 。下同。4.code，指返回结果中的状态码，200表示成功，其它都是错误码，值全部都是HTTP标准状态码。下同。5.msg，指返回结果中的状态信息，对成功结果或错误原因的详细说明。下同。6.code和msg总是在返回结果的同一层级成对出现。对所有请求的返回结果都会在最外层有一对总结式code和msg。下同。7.id等字段对应的值仅供说明，不一定是数据库里存在的，请求里用的是真实存在的值。下同。



3.设计规范3.1 操作方法


方法及说明
URL
Request
Response



GET:  普通获取数据， 可用浏览器调试
base_url&#x2F;get&#x2F;
{    TableName:{      …     }}  {…}内为限制条件 例如获取一个 id &#x3D; 235 的 Moment： {    “Moment”:{      “id”:235    }}  后端校验通过后自动解析为 SQL 并执行：SELECT * FROM Moment WHERE id&#x3D;235 LIMIT 1
{    TableName:{      …    },    “code”:200,    “msg”:”success”}例如{    “Moment”:{      “id”:235,      “userId”:38710,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “code”:200,    “msg”:”success” }


HEAD:  普通获取数量， 可用浏览器调试
base_url&#x2F;head&#x2F;
{    TableName:{      …    } }  {…}内为限制条件  例如获取一个 id &#x3D; 38710 的 User 所发布的 Moment 总数： {    “Moment”:{      “userId”:38710    }}  后端校验通过后自动解析为 SQL 并执行：SELECT count(*) FROM Moment WHERE userId&#x3D;38710 LIMIT 1
{    TableName:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,    “msg”:”success”}  例如{    “Moment”:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,     “msg”:”success”}


GETS:  安全&#x2F;私密获取数据， 用于获取钱包等对安全性要求高的数据
base_url&#x2F;gets&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Privacy”，其它同GET
同GET


HEADS:  安全&#x2F;私密获取数量， 用于获取银行卡数量等对安全性要求高的数据总数
base_url&#x2F;heads&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Verify”，其它同HEAD
同HEAD


POST:  新增数据
base_url&#x2F;post&#x2F;
单个：  {    TableName:{      …    },    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 38710 发布一个新 Comment：{    “Comment”:{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”     },    “tag”:”Comment”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(38710,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;)    批量：  {    TableName[]:[{        …      }, {        …      }      …    ],    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 82001 发布 2 个 Comment：{    “Comment[]”:[{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”      }, {      “momentId”:15,      “content”:”APIJSON is a JSON transmision protocol.”    }],    “tag”:”Comment:[]”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(82001,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;);INSERT INTO Comment(userId,momentId,content) VALUES(82001,15,&#39;APIJSON is a JSON transmision protocol.&#39;);
单个：  {    TableName:{      “code”:200,      “msg”:”success”,      “id”:38710    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “id”:120    },    “code”:200,    “msg”:”success”}   批量：  {    TableName:{      “code”:200,      “msg”:”success”,      “count”:5,      “id[]”:[1, 2, 3, 4, 5]    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “count”:2,      “id[]”:[1, 2]    },    “code”:200,    “msg”:”success”}


PUT:  修改数据， 只修改所传的字段
base_url&#x2F;put&#x2F;
{    TableName:{      “id”:id,      …    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个 例如当前登录用户 82001 修改 id &#x3D; 235 的 Moment 的 content：{    “Moment”:{      “id”:235,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “tag”:”Moment”}  后端校验通过后自动解析为 SQL 并执行：UPDATE Moment SET content&#x3D;&#39;APIJSON,let interfaces and documents go to hell !&#39; WHERE id&#x3D;235 AND userId&#x3D;82001 LIMIT 1  批量除了 id{}:[] 也可类似批量 POST，只是每个 {…} 里面都必须有 id。“tag”:”Comment[]” 对应对象 “Comment”:{“id{}”:[1,2,3]}，表示指定记录全部统一设置；“tag”:”Comment:[]” 多了冒号，对应数组 “Comment[]”:[{“id”:1},{“id”:2},{“id”:3}]，表示每项单独设置
同POST


DELETE:  删除数据
base_url&#x2F;delete&#x2F;
{    TableName:{      “id”:id    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个，一般只传 id 或 id{} 例如当前登录用户 82001 批量删除 id &#x3D; 100,110,120 的 Comment：{    “Comment”:{      “id{}”:[100,110,120]    },    “tag”:”Comment[]”}  后端校验通过后自动解析为 SQL 并执行：DELETE FROM Comment WHERE id IN(100,110,120) AND userId&#x3D;82001 LIMIT 3
{    TableName:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120]      “count”:3    },    “code”:200,    “msg”:”success”}例如{   “Comment”:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120],      “count”:3   },   “code”:200,   “msg”:”success”}


以上接口的简单形式:  base_url&#x2F;{method}&#x2F;{tag}
GET: 普通获取数据  base_url&#x2F;get&#x2F;{tag}  HEAD: 普通获取数量  base_url&#x2F;head&#x2F;{tag}  GETS: 安全&#x2F;私密获取数据   base_url&#x2F;gets&#x2F;{tag}  HEADS: 安全&#x2F;私密获取数量  base_url&#x2F;heads&#x2F;{tag}  POST: 新增数据   base_url&#x2F;post&#x2F;{tag}  PUT: 修改数据  base_url&#x2F;put&#x2F;{tag}  DELETE: 删除数据  base_url&#x2F;delete&#x2F;{tag}
例如安全&#x2F;私密获取一个 id &#x3D; 82001 的 Privacy： base_url&#x2F;gets&#x2F;Privacy&#x2F;  {“id”:82001}  相当于  base_url&#x2F;gets&#x2F; {“tag”:”Privacy”, “Privacy”:{“id”:82001}}   例如批量修改 id &#x3D; 114, 124 的 Comment 的 content：base_url&#x2F;put&#x2F;Comemnt[]&#x2F;  {    “id{}”:[114,124],    “content”:”test multi put”}  相当于  base_url&#x2F;put&#x2F;  {    “tag”:”Comment[]”,     “Comment”:{      “id{}”:[114,124],      “content”:”test multi put”    }}
同以上对应的方法


1.TableName指要查询的数据库表Table的名称字符串。第一个字符为大写字母，剩下的字符要符合英语字母、数字、下划线中的任何一种。对应的值的类型为JSONObject，结构是 {…}，里面放的是Table的字段(列名)。下同。2.”tag”:tag 后面的tag是非GET、HEAD请求中匹配请求的JSON结构的标识，一般是要查询的Table的名称，由后端Request表中指定。下同。3.GET、HEAD请求是开放请求，可任意组合任意嵌套。其它请求为受限制的安全&#x2F;私密请求，对应的 方法（method）, 标识（tag）, 版本（version）, 结构（structure） 都必须和 后端Request表中所指定的 一一对应，否则请求将不被通过。version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本。下同。4.GETS与GET、HEADS与HEAD分别为同一类型的操作方法，请求稍有不同但返回结果相同。下同。5.在HTTP通信中，自动化接口(get,gets,head,heads,post,put,delete) 全用HTTP POST请求。下同。6.所有JSONObject都视为容器(或者文件夹)，结构为 {…} ，里面可以放普通对象或子容器。下同。7.每个对象都有一个唯一的路径(或者叫地址)，假设对象名为refKey，则用 key0&#x2F;key1&#x2F;…&#x2F;refKey 表示。下同。


3.2 功能符


功能
键值对格式
使用示例



查询数组
“key[]”:{}，后面是JSONObject，key可省略。当key和里面的Table名相同时，Table会被提取出来，即 {Table:{Content}} 会被转化为 {Content}
{“User[]”:{“User”:{}}}，查询一个User数组。这里key和Table名都是User，User会被提取出来，即 {“User”:{“id”, …}} 会被转化为 {“id”, …}，如果要进一步提取User中的id，可以把User[]改为User-id[]


匹配选项范围
“key{}”:[]，后面是JSONArray，作为key可取的值的选项
“id{}”:[38710,82001,70793]，对应SQL是id IN(38710,82001,70793)，查询id符合38710,82001,70793中任意一个的一个User数组


匹配条件范围
“key{}”:”条件0,条件1…”，条件为SQL表达式字符串，可进行数字比较运算等
“id{}”:”&lt;&#x3D;80000,&gt;90000”，对应SQL是id&lt;&#x3D;80000 OR id&gt;90000，查询id符合id&lt;&#x3D;80000 | id&gt;90000的一个User数组


包含选项范围
“key&lt;&gt;“:Object  &#x3D;&gt;  “key&lt;&gt;“:[Object]，key对应值的类型必须为JSONArray，Object类型不能为JSON
“contactIdList&lt;&gt;“:38710，对应SQL是json_contains(contactIdList,38710)，查询contactIdList包含38710的一个User数组


判断是否存在
“key}{@”:{    “from”:”Table”,    “Table”:{ … }}其中：}{ 表示 EXISTS； key 用来标识是哪个判断； @ 后面是 子查询 对象，具体见下方 子查询 的说明。
“id}{@”:{    “from”:”Comment”,    “Comment”:{        “momentId”:15     }} WHERE EXISTS(SELECT * FROM Comment WHERE momentId&#x3D;15)


远程调用函数
“key()”:”函数表达式”，函数表达式为 function(key0,key1…)，会调用后端对应的函数 function(JSONObject request, String key0, String key1…)，实现 参数校验、数值计算、数据同步、消息推送、字段拼接、结构变换 等特定的业务逻辑处理，可使用 - 和 + 表示优先级，解析 key-() &gt; 解析当前对象 &gt; 解析 key() &gt; 解析子对象 &gt; 解析 key+()
“isPraised()”:”isContain(praiseUserIdList,userId)”，会调用远程函数 boolean isContain(JSONObject request, String array, String value) ，然后变为 “isPraised”:true 这种（假设点赞用户id列表包含了userId，即这个User点了赞）


存储过程
“@key()”:”SQL函数表达式”，函数表达式为   function(key0,key1…)  会调用后端数据库对应的存储过程 SQL函数  function(String key0, String key1…)  除了参数会提前赋值，其它和 远程函数 一致
“@limit”:10,  “@offset”:0,  “@procedure()”:”getCommentByUserId(id,@limit,@offset)”  会转为  getCommentByUserId(38710,10,0)  来调用存储过程 SQL 函数  getCommentByUserId(IN id bigint, IN limit int, IN offset int)  然后变为 “procedure”:{    “count”:-1,     “update”:false,     “list”:[]  }  其中 count 是指写操作影响记录行数，-1 表示不是写操作；update 是指是否为写操作（增删改）；list 为返回结果集


引用赋值
“key@”:”key0&#x2F;key1&#x2F;…&#x2F;refKey”，引用路径为用&#x2F;分隔的字符串。以&#x2F;开头的是缺省引用路径，从声明key所处容器的父容器路径开始；其它是完整引用路径，从最外层开始。 被引用的refKey必须在声明key的上面。如果对refKey的容器指定了返回字段，则被引用的refKey必须写在@column对应的值内，例如 “@column”:”refKey,key1,…”
“Moment”:{    “userId”:38710},“User”:{    “id@”:”&#x2F;Moment&#x2F;userId”} User内的id引用了与User同级的Moment内的userId，即User.id &#x3D; Moment.userId，请求完成后 “id@”:”&#x2F;Moment&#x2F;userId” 会变成 “id”:38710


子查询
“key@”:{    “range”:”ALL”,     “from”:”Table”,    “Table”:{ … }}其中：range 可为 ALL,ANY；from 为目标表 Table 的名称；@ 后面的对象类似数组对象，可使用 count 和 join 等功能。
“id@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&#x3D;(SELECT min(userId) FROM Comment)


模糊搜索
&quot;key$&quot;:&quot;SQL搜索表达式&quot;  &#x3D;&gt;  &quot;key$&quot;:[&quot;SQL搜索表达式&quot;]，任意SQL搜索表达式字符串，如 %key%(包含key), key%(以key开始), %k%e%y%(包含字母k,e,y) 等，%表示任意字符
“name$”:”%m%”，对应SQL是name LIKE &#39;%m%&#39;，查询name包含”m”的一个User数组


正则匹配
“key“:”正则表达式”  &#x3D;&gt;  “key“:[“正则表达式”]，任意正则表达式字符串，如 ^[0-9]+$ ，*~ 忽略大小写，可用于高级搜索
“name~”:”^[0-9]+$”，对应SQL是name REGEXP &#39;^[0-9]+$&#39;，查询name中字符全为数字的一个User数组


连续范围
“key%”:”start,end”  &#x3D;&gt;  “key%”:[“start,end”]，其中 start 和 end 都只能为 Boolean, Number, String 中的一种，如 “2017-01-01,2019-01-01” ，[“1,90000”, “82001,100000”] ，可用于连续范围内的筛选
“date%”:”2017-10-01,2018-10-01”，对应SQL是date BETWEEN &#39;2017-10-01&#39; AND &#39;2018-10-01&#39;，查询在2017-10-01和2018-10-01期间注册的用户的一个User数组


新建别名
“name:alias”，name映射为alias，用alias替代name。可用于 column,Table,SQL函数 等。只用于GET类型、HEAD类型的请求
“@column”:”toId:parentId”，对应SQL是toId AS parentId，将查询的字段toId变为parentId返回


增加 或 扩展
“key+”:Object，Object的类型由key指定，且类型为Number,String,JSONArray中的一种。如 82001,”apijson”,[“url0”,”url1”] 等。只用于PUT请求
“praiseUserIdList+”:[82001]，对应SQL是json_insert(praiseUserIdList,82001)，添加一个点赞用户id，即这个用户点了赞


减少 或 去除
“key-“:Object，与”key+”相反
“balance-“:100.00，对应SQL是balance &#x3D; balance - 100.00，余额减少100.00，即花费了100元


比较运算
&gt;, &lt;, &gt;&#x3D;, &lt;&#x3D; 比较运算符，用于 ① 提供 “id{}”:”&lt;&#x3D;90000” 这种条件范围的简化写法 ② 实现子查询相关比较运算不支持 “key&#x3D;”:Object 和 “key!&#x3D;”:Object 这两种写法，直接用更简单的 “key”:Object 和 “key!”:Object 替代。
① “id&lt;&#x3D;”:90000，对应SQL是id&lt;&#x3D;90000，查询符合id&lt;&#x3D;90000的一个User数组 ② “id&gt;@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&gt;(SELECT min(userId) FROM Comment)


逻辑运算
&amp;, |, ! 逻辑运算符，对应数据库 SQL 中的 AND, OR, NOT。 横或纵与：同一键值对的值内条件默认 | 或连接，可以在 key 后加逻辑运算符来具体指定；不同键值对的条件默认 &amp; 与连接，可以用下面说明的对象关键词 @combine 来具体指定。 ① &amp; 可用于”key&amp;{}”:”条件”等② | 可用于”key|{}”:”条件”, “key|{}”:[]等，一般可省略③ ! 可单独使用，如”key!”:Object，也可像&amp;,|一样配合其他功能符使用  “key!”:null 无效，null 值会导致整个键值对被忽略解析，可以用 “key{}”:”!&#x3D;null” 替代，“key”:null 同理，用 “key{}”:”&#x3D;null” 替代。
① “id&amp;{}”:”&gt;80000,&lt;&#x3D;90000”，对应SQL是id&gt;80000 AND id&lt;&#x3D;90000，即id满足id&gt;80000 &amp; id&lt;&#x3D;90000 ② “id|{}”:”&gt;90000,&lt;&#x3D;80000”，同”id{}”:”&gt;90000,&lt;&#x3D;80000”，对应SQL是id&gt;80000 OR id&lt;&#x3D;90000，即id满足id&gt;90000 | id&lt;&#x3D;80000 ③ “id!{}”:[82001,38710]，对应SQL是id NOT IN(82001,38710)，即id满足 ! (id&#x3D;82001 | id&#x3D;38710)，可过滤黑名单的消息


数组关键词，可自定义
“key”:Object，key为 “[]”:{} 中{}内的关键词，Object的类型由key指定① “count”:Integer，查询数量，0 表示最大值，默认最大值为100 ② “page”:Integer，查询页码，从0开始，默认最大值为100，一般和count一起用③ “query”:Integer，查询内容0-对象，1-总数和分页详情，2-数据、总数和分页详情总数关键词为 total，分页详情关键词为 info， 它们都和 query 同级，通过引用赋值得到，例如  “total@”:”&#x2F;[]&#x2F;total”, “info@”:”&#x2F;[]&#x2F;info” 这里query及total仅为GET类型的请求提供方便， 一般可直接用HEAD类型的请求获取总数④ “join”:”&amp;&#x2F;Table0,&lt;&#x2F;Table1&#x2F;key1@” 或 “join”:{    “&amp;&#x2F;Table0”:{},  &#x2F;&#x2F; 支持 ON 多个字段关联,    “&lt;&#x2F;Table1&#x2F;key1@”:{  &#x2F;&#x2F; ON 只允许指定的 key1 关联      “key0”:value0,  &#x2F;&#x2F; 其它ON条件       “key2”:value2,      …       “@combine”:”…”,  &#x2F;&#x2F; 其它ON条件的组合方式       “@column”:”…”,  &#x2F;&#x2F; 外层 SELECT       “@group”:”…”,  &#x2F;&#x2F; 外层 GROUP BY       “@having”:”…”  &#x2F;&#x2F; 外层 HAVING     }}多表连接方式：  “@” - APP JOIN  “&lt;“ - LEFT JOIN  “&gt;” - RIGHT JOIN  “&amp;” - INNER JOIN  “|” - FULL JOIN   “!” - OUTER JOIN   “*” - CROSS JOIN   “^” - SIDE JOIN   “(“ - ANTI JOIN   “)” - FOREIGN JOIN 其中 @ APP JOIN 为应用层连表，会从已查出的主表里取得所有副表 key@ 关联的主表内的 refKey 作为一个数组 refKeys: [value0, value1…]，然后把原来副表 count 次查询 key&#x3D;$refKey 的 SQL 用 key IN($refKeys) 的方式合并为一条 SQL 来优化性能； 其它 JOIN 都是 SQL JOIN，具体功能和 MySQL,PostgreSQL 等数据库的 JOIN 一一对应 &quot;join&quot;:&quot;&lt;&#x2F;ViceTable&#x2F;key@&quot;,&quot;MainTable&quot;:{},&quot;ViceTable&quot;:{&quot;key@&quot;:&quot;&#x2F;MainTable&#x2F;refKey&quot;}会对应生成 MainTable LEFT JOIN ViceTable ON ViceTable.key&#x3D;MainTable.refKey AND 其它ON条件  除了 &#x3D; 等价关联，也支持 ! 不等关联、&gt; &lt; &gt;&#x3D; &lt;&#x3D; 等比较关联和 $ ~ {} &lt;&gt; 等其它复杂关联方式 ⑤ “otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 查询User数组，最多5个：“count”:5对应SQL是LIMIT 5  ② 查询第3页的User数组，每页5个：“count”:5,“page”:3对应SQL是LIMIT 5 OFFSET 15  ③ 查询User数组和对应的User总数：“[]”:{    “query”:2,    “User”:{}},“total@”:”&#x2F;[]&#x2F;total”,“info@”:”&#x2F;[]&#x2F;info” 返回的数据中，总数及分页详情结构为：   “total”:139,  &#x2F;&#x2F;总数  “info”:{  &#x2F;&#x2F;分页详情     “total”:139,  &#x2F;&#x2F;总数     “count”:5,  &#x2F;&#x2F;每页数量     “page”:0,  &#x2F;&#x2F;当前页码     “max”:27,  &#x2F;&#x2F;最大页码     “more”:true,  &#x2F;&#x2F;是否还有更多     “first”:true,  &#x2F;&#x2F;是否为首页     “last”:false  &#x2F;&#x2F;是否为尾页 }  ④ Moment INNER JOIN User LEFT JOIN Comment：“[]”:{    “join”:”&amp;&#x2F;User&#x2F;id@,&lt;&#x2F;Comment”,    “Moment”:{     “@group”:”id”  &#x2F;&#x2F;主副表不是一对一，要去除重复数据   },    “User”:{      “name~”:”t”,      “id@”:”&#x2F;Moment&#x2F;userId”    },    “Comment”:{      “momentId@”:”&#x2F;Moment&#x2F;id”    }} ⑤ 每一层都加当前用户名：“User”:{},“[]”:{    “name@”:”User&#x2F;name”, &#x2F;&#x2F;自定义关键词    “Moment”:{}}


对象关键词，可自定义
“@key”:Object，@key为 Table:{} 中{}内的关键词，Object的类型由@key指定① “@combine”:”key0 | (key1 &amp; (key2 | !key3))…”，条件组合方式，最终按  (其它key条件 AND 连接) AND (key0条件 OR (key1条件 AND (key2条件 OR (NOT key3条件)))) 这种方式连接，其中 “其它key” 是指与 @combine 在同一对象，且未被它声明的条件 key，默认都是 &amp; 连接。注意不要缺少或多余任何一个空格。 ② “@column”:”column;function(arg)…”，返回字段③ “@order”:”column0+,column1-…”，排序方式④ “@group”:”column0,column1…”，分组方式。如果@column里声明了Table的id，则id也必须在@group中声明；其它情况下必须满足至少一个条件:1.分组的key在@column里声明2.Table主键在@group中声明 ⑤ “@having”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…” &#x2F;&#x2F; OR 连接，或 “@having&amp;”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…”  &#x2F;&#x2F; AND 连接，或 “@having”:{   “h0”:”function0(…)?value0”,   “h1”:function1(…)?value1”,   “h2”:function2(…)?value2…”,   “@combine”:”h0 &amp; (h1 | !h2)”  &#x2F;&#x2F; 任意组合，非必传}SQL函数条件，一般和@group一起用，函数一般在@column里声明⑥ “@schema”:”sys”，集合空间(数据库名&#x2F;模式)，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑦ “@database”:”POSTGRESQL”，数据库类型，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑧ “@datasource”:”DRUID”，跨数据源，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑨ “@json”:”key0,key1…”，转为 JSON 格式返回，符合 JSONObject 则转为 {…}，符合 JSONArray 则转为 […] ⑩ “@role”:”OWNER”，来访角色，包括UNKNOWN,LOGIN,CONTACT,CIRCLE,OWNER,ADMIN，可以在最外层作为全局默认配置，可自定义其它角色并重写 Verifier.verify 等相关方法来自定义校验 ⑪ “@explain”:true，性能分析，可以在最外层作为全局默认配置 ⑫ “@raw”:”key0,key1…”，其中 key0, key1 都对应有键值对 “key0”:”SQL片段或SQL片段的别名”,  “key1”:”SQL片段或SQL片段的别名”  自定义原始SQL片段，可扩展嵌套SQL函数等复杂语句，必须是后端已配置的，只有其它功能符都做不到才考虑，谨慎使用，注意防SQL注入⑬ “@otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 搜索name或tag任何一个字段包含字符a的User列表： “name“:”a”,“tag“:”a”,“@combine”:”name~ | tag~” 对应SQL是name REGEXP &#39;a&#39; OR tag REGEXP &#39;a&#39;  ② 只查询id,sex,name这几列并且请求结果也按照这个顺序：“@column”:”id,sex,name”对应SQL是SELECT id,sex,name  ③ 查询按 name降序、id默认顺序 排序的User数组：“@order”:”name-,id”对应SQL是ORDER BY name DESC,id  ④ 查询按userId分组的Moment数组：“@group”:”userId,id”对应SQL是GROUP BY userId,id  ⑤ 查询 按userId分组、id最大值&gt;&#x3D;100 的Moment数组：“@column”:”userId;max(id)”,“@group”:”userId”,“@having”:”max(id)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) ... GROUP BY userId HAVING max(id)&gt;&#x3D;100 还可以指定函数返回名：“@column”:”userId;max(id):maxId”,“@group”:”userId”,“@having”:”(maxId)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) AS maxId ... GROUP BY userId HAVING (maxId)&gt;&#x3D;100  ⑥ 查询 sys 内的 User 表：“@schema”:”sys”对应SQL是FROM sys.User  ⑦ 查询 PostgreSQL 数据库的 User 表：“@database”:”POSTGRESQL” ⑧ 使用 Druid 连接池查询 User 表：“@datasource”:”DRUID” ⑨ 将 VARCHAR 字符串字段 get 转为 JSONArray 返回：“@json”:”get” ⑩ 查询当前用户的动态：“@role”:”OWNER” ⑪ 开启性能分析：“@explain”:true对应SQL是EXPLAIN  ⑫ 统计最近一周偶数userId的数量“@column”:”date;left(date,10):day;sum(if(userId%2&#x3D;0,1,0))”,“@group”:”day”,“@having”:”to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7”,“@raw”:”@column,@having”对应SQL是SELECT date, left(date,10) AS day, sum(if(userId%2&#x3D;0,1,0)) ... GROUP BY day HAVING to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7  ⑬ 从pictureList获取第0张图片：“@position”:0, &#x2F;&#x2F;自定义关键词“firstPicture()”:”getFromArray(pictureList,@position)”


全局关键词
为最外层对象 {} 内的关键词。其中 @database，@schema, @datasource, @role, @explain 基本同对象关键词，见上方说明，区别是全局关键词会每个表对象中没有时自动放入，作为默认值。 ① “tag”:String，后面的 tag 是非 GET、HEAD 请求中匹配请求的 JSON 结构的标识，一般是要查询的 Table 的名称或该名称对应的数组 Table[] 或 Table:[]，由后端 Request 表中指定。 ② “version”:Integer，接口版本，version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本，由后端 Request 表中指定。③ “format”:Boolean，格式化返回 Response JSON 的 key，一般是将 TableName 转为 tableName, TableName[] 转为 tableNameList, Table:alias 转为 alias, TableName-key[] 转为 tableNameKeyList 等小驼峰格式。
①  查隐私信息：[{“tag”:”Privacy”,”Privacy”:{“id”:82001}}](http:&#x2F;&#x2F;apijson.cn&#x2F;api?url&#x3D;http%3A%2F%2Fapijson.cn%3A8080%2Fgets&amp;type&#x3D;JSON&amp;json&#x3D;


</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2.4"><span class="toc-number">1.6.11.</span> <span class="toc-text">2.4 前端解析


前端解析
传统方式
APIJSON



查看方式
查文档或问后端，或等请求成功后看日志
看请求就行，所求即所得，不用查、不用问、不用等。也可以等请求成功后看日志


解析方法
用JSON解析器来解析JSONObject
可以用JSONResponse解析JSONObject，或使用传统方式


 
 
2.5 前端对应不同需求的请求


前端的请求
传统方式
APIJSON



User
base_url&#x2F;get&#x2F;user?id&#x3D;38710
base_url&#x2F;get&#x2F;{    “User”:{      “id”:38710    }}


Moment和对应的User
分两次请求Moment:  base_url&#x2F;get&#x2F;moment?userId&#x3D;38710User:  base_url&#x2F;get&#x2F;user?id&#x3D;38710
base_url&#x2F;get&#x2F;{    “Moment”:{      “userId”:38710    },     “User”:{      “id”:38710    }}


User列表
base_url&#x2F;get&#x2F;user&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;sex&#x3D;0
base_url&#x2F;get&#x2F;{    “User[]”:{      “page”:0,       “count”:3,       “User”:{        “sex”:0      }    }}


Moment列表，每个Moment包括1.发布者User2.前3条Comment
Moment里必须有1.User对象2.Comment数组 base_url&#x2F;get&#x2F;moment&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;commentCount&#x3D;3
base_url&#x2F;get&#x2F;{    “[]”:{      “page”:0,       “count”:3,       “Moment”:{},       “User”:{        “id@”:”&#x2F;Moment&#x2F;userId”      },      “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }}


User发布的Moment列表， 每个Moment包括 1.发布者User 2.前3条Comment
1.Moment里必须有User对象和Comment数组 2.字段名必须查接口文档，例如评论数量字段名可能是 commentCount,comment_count或者简写cmt_count等各种奇葩写法…  base_url&#x2F;get&#x2F;moment&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;commentCount&#x3D;3&amp;userId&#x3D;38710
有以下几种方式: ① 把以上请求里的“Moment”:{}, “User”:{“id@”:”&#x2F;Moment&#x2F;userId”}改为“Moment”:{“userId”:38710}, “User”:{“id”:38710}  ② 或把User放在上面的最外层省去重复的Userbase_url&#x2F;get&#x2F;{    “User”:{      “id”:38710    },    “[]”:{      “page”:0,      “count”:3,       “Moment”:{        “userId”:38710      },       “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }} ③ 如果User之前已经获取到了，还可以不传User来节省请求和返回数据的流量并提升速度base_url&#x2F;get&#x2F;{    “[]”:{      “page”:0,      “count”:3,       “Moment”:{        “userId”:38710      },      “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }}


 
 
2.6 后端对应不同请求的返回结果


后端的返回结果
传统方式
APIJSON



User
{    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
{    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


Moment和对应的User
分别返回两次请求的结果，获取到Moment后取出userId作为User的id条件去查询User  Moment:  {    “data”:{      “id”:235,      “content”:”xxx”,      …    },    “code”:200,    “msg”:”success”}  User:  {    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
一次性返回，没有传统方式导致的 长时间等待结果、两次结果间关联、线程多次切换 等问题  {    “Moment”:{      “id”:235,      “content”:”xxx”,      …    },    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


User列表
{    “data”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}
{    “User[]”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}


Moment列表，每个Moment包括发布者User和前3条Comment
Moment里必须有1.User对象2.Comment数组  {    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          …        },        “Comment”:[          …        ]      },      {        “id”:301,        “content”:”xxx”,        …,        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}
1.高灵活，可任意组合2.低耦合，逻辑很清晰{    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          …        },        “Comment[]”:[          …        ]      },      {        “Moment”:{          “id”:301,          “content”:”xxx”,          …        },        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}


User发布的Moment列表，每个Moment包括发布者User和前3条Comment
1.大量重复User，浪费流量和服务器性能2.优化很繁琐，需要后端扩展接口、写好文档，前端&#x2F;前端再配合优化{    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:470,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:511,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:595,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      …    ],    “code”:200,    “msg”:”success”}
以上不同请求方式的结果: ① 常规请求  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ② 省去重复的User  {    “User”:{      “id”:38710,      “name”:”Tommy”,      …    },    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ③ 不查询已获取到的User  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”}


1.base_url指基地址，一般是顶级域名，其它分支url都是在base_url后扩展。如base_url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F; ，对应的GET分支url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F;get&#x2F; 。下同。2.请求中的key或value任意一个为null值时，这个 key:value键值对 被视为无效。下同。3.请求中的 &#x2F; 需要转义。JSONRequest.java已经用URLEncoder.encode转义，不需要再写；但如果是浏览器或Postman等直接输入url&#x2F;request，需要把request中的所有 &#x2F; 都改成 %252F 。下同。4.code，指返回结果中的状态码，200表示成功，其它都是错误码，值全部都是HTTP标准状态码。下同。5.msg，指返回结果中的状态信息，对成功结果或错误原因的详细说明。下同。6.code和msg总是在返回结果的同一层级成对出现。对所有请求的返回结果都会在最外层有一对总结式code和msg。下同。7.id等字段对应的值仅供说明，不一定是数据库里存在的，请求里用的是真实存在的值。下同。



3.设计规范3.1 操作方法


方法及说明
URL
Request
Response



GET:  普通获取数据， 可用浏览器调试
base_url&#x2F;get&#x2F;
{    TableName:{      …     }}  {…}内为限制条件 例如获取一个 id &#x3D; 235 的 Moment： {    “Moment”:{      “id”:235    }}  后端校验通过后自动解析为 SQL 并执行：SELECT * FROM Moment WHERE id&#x3D;235 LIMIT 1
{    TableName:{      …    },    “code”:200,    “msg”:”success”}例如{    “Moment”:{      “id”:235,      “userId”:38710,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “code”:200,    “msg”:”success” }


HEAD:  普通获取数量， 可用浏览器调试
base_url&#x2F;head&#x2F;
{    TableName:{      …    } }  {…}内为限制条件  例如获取一个 id &#x3D; 38710 的 User 所发布的 Moment 总数： {    “Moment”:{      “userId”:38710    }}  后端校验通过后自动解析为 SQL 并执行：SELECT count(*) FROM Moment WHERE userId&#x3D;38710 LIMIT 1
{    TableName:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,    “msg”:”success”}  例如{    “Moment”:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,     “msg”:”success”}


GETS:  安全&#x2F;私密获取数据， 用于获取钱包等对安全性要求高的数据
base_url&#x2F;gets&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Privacy”，其它同GET
同GET


HEADS:  安全&#x2F;私密获取数量， 用于获取银行卡数量等对安全性要求高的数据总数
base_url&#x2F;heads&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Verify”，其它同HEAD
同HEAD


POST:  新增数据
base_url&#x2F;post&#x2F;
单个：  {    TableName:{      …    },    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 38710 发布一个新 Comment：{    “Comment”:{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”     },    “tag”:”Comment”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(38710,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;)    批量：  {    TableName[]:[{        …      }, {        …      }      …    ],    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 82001 发布 2 个 Comment：{    “Comment[]”:[{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”      }, {      “momentId”:15,      “content”:”APIJSON is a JSON transmision protocol.”    }],    “tag”:”Comment:[]”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(82001,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;);INSERT INTO Comment(userId,momentId,content) VALUES(82001,15,&#39;APIJSON is a JSON transmision protocol.&#39;);
单个：  {    TableName:{      “code”:200,      “msg”:”success”,      “id”:38710    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “id”:120    },    “code”:200,    “msg”:”success”}   批量：  {    TableName:{      “code”:200,      “msg”:”success”,      “count”:5,      “id[]”:[1, 2, 3, 4, 5]    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “count”:2,      “id[]”:[1, 2]    },    “code”:200,    “msg”:”success”}


PUT:  修改数据， 只修改所传的字段
base_url&#x2F;put&#x2F;
{    TableName:{      “id”:id,      …    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个 例如当前登录用户 82001 修改 id &#x3D; 235 的 Moment 的 content：{    “Moment”:{      “id”:235,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “tag”:”Moment”}  后端校验通过后自动解析为 SQL 并执行：UPDATE Moment SET content&#x3D;&#39;APIJSON,let interfaces and documents go to hell !&#39; WHERE id&#x3D;235 AND userId&#x3D;82001 LIMIT 1  批量除了 id{}:[] 也可类似批量 POST，只是每个 {…} 里面都必须有 id。“tag”:”Comment[]” 对应对象 “Comment”:{“id{}”:[1,2,3]}，表示指定记录全部统一设置；“tag”:”Comment:[]” 多了冒号，对应数组 “Comment[]”:[{“id”:1},{“id”:2},{“id”:3}]，表示每项单独设置
同POST


DELETE:  删除数据
base_url&#x2F;delete&#x2F;
{    TableName:{      “id”:id    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个，一般只传 id 或 id{} 例如当前登录用户 82001 批量删除 id &#x3D; 100,110,120 的 Comment：{    “Comment”:{      “id{}”:[100,110,120]    },    “tag”:”Comment[]”}  后端校验通过后自动解析为 SQL 并执行：DELETE FROM Comment WHERE id IN(100,110,120) AND userId&#x3D;82001 LIMIT 3
{    TableName:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120]      “count”:3    },    “code”:200,    “msg”:”success”}例如{   “Comment”:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120],      “count”:3   },   “code”:200,   “msg”:”success”}


以上接口的简单形式:  base_url&#x2F;{method}&#x2F;{tag}
GET: 普通获取数据  base_url&#x2F;get&#x2F;{tag}  HEAD: 普通获取数量  base_url&#x2F;head&#x2F;{tag}  GETS: 安全&#x2F;私密获取数据   base_url&#x2F;gets&#x2F;{tag}  HEADS: 安全&#x2F;私密获取数量  base_url&#x2F;heads&#x2F;{tag}  POST: 新增数据   base_url&#x2F;post&#x2F;{tag}  PUT: 修改数据  base_url&#x2F;put&#x2F;{tag}  DELETE: 删除数据  base_url&#x2F;delete&#x2F;{tag}
例如安全&#x2F;私密获取一个 id &#x3D; 82001 的 Privacy： base_url&#x2F;gets&#x2F;Privacy&#x2F;  {“id”:82001}  相当于  base_url&#x2F;gets&#x2F; {“tag”:”Privacy”, “Privacy”:{“id”:82001}}   例如批量修改 id &#x3D; 114, 124 的 Comment 的 content：base_url&#x2F;put&#x2F;Comemnt[]&#x2F;  {    “id{}”:[114,124],    “content”:”test multi put”}  相当于  base_url&#x2F;put&#x2F;  {    “tag”:”Comment[]”,     “Comment”:{      “id{}”:[114,124],      “content”:”test multi put”    }}
同以上对应的方法


1.TableName指要查询的数据库表Table的名称字符串。第一个字符为大写字母，剩下的字符要符合英语字母、数字、下划线中的任何一种。对应的值的类型为JSONObject，结构是 {…}，里面放的是Table的字段(列名)。下同。2.”tag”:tag 后面的tag是非GET、HEAD请求中匹配请求的JSON结构的标识，一般是要查询的Table的名称，由后端Request表中指定。下同。3.GET、HEAD请求是开放请求，可任意组合任意嵌套。其它请求为受限制的安全&#x2F;私密请求，对应的 方法（method）, 标识（tag）, 版本（version）, 结构（structure） 都必须和 后端Request表中所指定的 一一对应，否则请求将不被通过。version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本。下同。4.GETS与GET、HEADS与HEAD分别为同一类型的操作方法，请求稍有不同但返回结果相同。下同。5.在HTTP通信中，自动化接口(get,gets,head,heads,post,put,delete) 全用HTTP POST请求。下同。6.所有JSONObject都视为容器(或者文件夹)，结构为 {…} ，里面可以放普通对象或子容器。下同。7.每个对象都有一个唯一的路径(或者叫地址)，假设对象名为refKey，则用 key0&#x2F;key1&#x2F;…&#x2F;refKey 表示。下同。


3.2 功能符


功能
键值对格式
使用示例



查询数组
“key[]”:{}，后面是JSONObject，key可省略。当key和里面的Table名相同时，Table会被提取出来，即 {Table:{Content}} 会被转化为 {Content}
{“User[]”:{“User”:{}}}，查询一个User数组。这里key和Table名都是User，User会被提取出来，即 {“User”:{“id”, …}} 会被转化为 {“id”, …}，如果要进一步提取User中的id，可以把User[]改为User-id[]


匹配选项范围
“key{}”:[]，后面是JSONArray，作为key可取的值的选项
“id{}”:[38710,82001,70793]，对应SQL是id IN(38710,82001,70793)，查询id符合38710,82001,70793中任意一个的一个User数组


匹配条件范围
“key{}”:”条件0,条件1…”，条件为SQL表达式字符串，可进行数字比较运算等
“id{}”:”&lt;&#x3D;80000,&gt;90000”，对应SQL是id&lt;&#x3D;80000 OR id&gt;90000，查询id符合id&lt;&#x3D;80000 | id&gt;90000的一个User数组


包含选项范围
“key&lt;&gt;“:Object  &#x3D;&gt;  “key&lt;&gt;“:[Object]，key对应值的类型必须为JSONArray，Object类型不能为JSON
“contactIdList&lt;&gt;“:38710，对应SQL是json_contains(contactIdList,38710)，查询contactIdList包含38710的一个User数组


判断是否存在
“key}{@”:{    “from”:”Table”,    “Table”:{ … }}其中：}{ 表示 EXISTS； key 用来标识是哪个判断； @ 后面是 子查询 对象，具体见下方 子查询 的说明。
“id}{@”:{    “from”:”Comment”,    “Comment”:{        “momentId”:15     }} WHERE EXISTS(SELECT * FROM Comment WHERE momentId&#x3D;15)


远程调用函数
“key()”:”函数表达式”，函数表达式为 function(key0,key1…)，会调用后端对应的函数 function(JSONObject request, String key0, String key1…)，实现 参数校验、数值计算、数据同步、消息推送、字段拼接、结构变换 等特定的业务逻辑处理，可使用 - 和 + 表示优先级，解析 key-() &gt; 解析当前对象 &gt; 解析 key() &gt; 解析子对象 &gt; 解析 key+()
“isPraised()”:”isContain(praiseUserIdList,userId)”，会调用远程函数 boolean isContain(JSONObject request, String array, String value) ，然后变为 “isPraised”:true 这种（假设点赞用户id列表包含了userId，即这个User点了赞）


存储过程
“@key()”:”SQL函数表达式”，函数表达式为   function(key0,key1…)  会调用后端数据库对应的存储过程 SQL函数  function(String key0, String key1…)  除了参数会提前赋值，其它和 远程函数 一致
“@limit”:10,  “@offset”:0,  “@procedure()”:”getCommentByUserId(id,@limit,@offset)”  会转为  getCommentByUserId(38710,10,0)  来调用存储过程 SQL 函数  getCommentByUserId(IN id bigint, IN limit int, IN offset int)  然后变为 “procedure”:{    “count”:-1,     “update”:false,     “list”:[]  }  其中 count 是指写操作影响记录行数，-1 表示不是写操作；update 是指是否为写操作（增删改）；list 为返回结果集


引用赋值
“key@”:”key0&#x2F;key1&#x2F;…&#x2F;refKey”，引用路径为用&#x2F;分隔的字符串。以&#x2F;开头的是缺省引用路径，从声明key所处容器的父容器路径开始；其它是完整引用路径，从最外层开始。 被引用的refKey必须在声明key的上面。如果对refKey的容器指定了返回字段，则被引用的refKey必须写在@column对应的值内，例如 “@column”:”refKey,key1,…”
“Moment”:{    “userId”:38710},“User”:{    “id@”:”&#x2F;Moment&#x2F;userId”} User内的id引用了与User同级的Moment内的userId，即User.id &#x3D; Moment.userId，请求完成后 “id@”:”&#x2F;Moment&#x2F;userId” 会变成 “id”:38710


子查询
“key@”:{    “range”:”ALL”,     “from”:”Table”,    “Table”:{ … }}其中：range 可为 ALL,ANY；from 为目标表 Table 的名称；@ 后面的对象类似数组对象，可使用 count 和 join 等功能。
“id@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&#x3D;(SELECT min(userId) FROM Comment)


模糊搜索
&quot;key$&quot;:&quot;SQL搜索表达式&quot;  &#x3D;&gt;  &quot;key$&quot;:[&quot;SQL搜索表达式&quot;]，任意SQL搜索表达式字符串，如 %key%(包含key), key%(以key开始), %k%e%y%(包含字母k,e,y) 等，%表示任意字符
“name$”:”%m%”，对应SQL是name LIKE &#39;%m%&#39;，查询name包含”m”的一个User数组


正则匹配
“key“:”正则表达式”  &#x3D;&gt;  “key“:[“正则表达式”]，任意正则表达式字符串，如 ^[0-9]+$ ，*~ 忽略大小写，可用于高级搜索
“name~”:”^[0-9]+$”，对应SQL是name REGEXP &#39;^[0-9]+$&#39;，查询name中字符全为数字的一个User数组


连续范围
“key%”:”start,end”  &#x3D;&gt;  “key%”:[“start,end”]，其中 start 和 end 都只能为 Boolean, Number, String 中的一种，如 “2017-01-01,2019-01-01” ，[“1,90000”, “82001,100000”] ，可用于连续范围内的筛选
“date%”:”2017-10-01,2018-10-01”，对应SQL是date BETWEEN &#39;2017-10-01&#39; AND &#39;2018-10-01&#39;，查询在2017-10-01和2018-10-01期间注册的用户的一个User数组


新建别名
“name:alias”，name映射为alias，用alias替代name。可用于 column,Table,SQL函数 等。只用于GET类型、HEAD类型的请求
“@column”:”toId:parentId”，对应SQL是toId AS parentId，将查询的字段toId变为parentId返回


增加 或 扩展
“key+”:Object，Object的类型由key指定，且类型为Number,String,JSONArray中的一种。如 82001,”apijson”,[“url0”,”url1”] 等。只用于PUT请求
“praiseUserIdList+”:[82001]，对应SQL是json_insert(praiseUserIdList,82001)，添加一个点赞用户id，即这个用户点了赞


减少 或 去除
“key-“:Object，与”key+”相反
“balance-“:100.00，对应SQL是balance &#x3D; balance - 100.00，余额减少100.00，即花费了100元


比较运算
&gt;, &lt;, &gt;&#x3D;, &lt;&#x3D; 比较运算符，用于 ① 提供 “id{}”:”&lt;&#x3D;90000” 这种条件范围的简化写法 ② 实现子查询相关比较运算不支持 “key&#x3D;”:Object 和 “key!&#x3D;”:Object 这两种写法，直接用更简单的 “key”:Object 和 “key!”:Object 替代。
① “id&lt;&#x3D;”:90000，对应SQL是id&lt;&#x3D;90000，查询符合id&lt;&#x3D;90000的一个User数组 ② “id&gt;@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&gt;(SELECT min(userId) FROM Comment)


逻辑运算
&amp;, |, ! 逻辑运算符，对应数据库 SQL 中的 AND, OR, NOT。 横或纵与：同一键值对的值内条件默认 | 或连接，可以在 key 后加逻辑运算符来具体指定；不同键值对的条件默认 &amp; 与连接，可以用下面说明的对象关键词 @combine 来具体指定。 ① &amp; 可用于”key&amp;{}”:”条件”等② | 可用于”key|{}”:”条件”, “key|{}”:[]等，一般可省略③ ! 可单独使用，如”key!”:Object，也可像&amp;,|一样配合其他功能符使用  “key!”:null 无效，null 值会导致整个键值对被忽略解析，可以用 “key{}”:”!&#x3D;null” 替代，“key”:null 同理，用 “key{}”:”&#x3D;null” 替代。
① “id&amp;{}”:”&gt;80000,&lt;&#x3D;90000”，对应SQL是id&gt;80000 AND id&lt;&#x3D;90000，即id满足id&gt;80000 &amp; id&lt;&#x3D;90000 ② “id|{}”:”&gt;90000,&lt;&#x3D;80000”，同”id{}”:”&gt;90000,&lt;&#x3D;80000”，对应SQL是id&gt;80000 OR id&lt;&#x3D;90000，即id满足id&gt;90000 | id&lt;&#x3D;80000 ③ “id!{}”:[82001,38710]，对应SQL是id NOT IN(82001,38710)，即id满足 ! (id&#x3D;82001 | id&#x3D;38710)，可过滤黑名单的消息


数组关键词，可自定义
“key”:Object，key为 “[]”:{} 中{}内的关键词，Object的类型由key指定① “count”:Integer，查询数量，0 表示最大值，默认最大值为100 ② “page”:Integer，查询页码，从0开始，默认最大值为100，一般和count一起用③ “query”:Integer，查询内容0-对象，1-总数和分页详情，2-数据、总数和分页详情总数关键词为 total，分页详情关键词为 info， 它们都和 query 同级，通过引用赋值得到，例如  “total@”:”&#x2F;[]&#x2F;total”, “info@”:”&#x2F;[]&#x2F;info” 这里query及total仅为GET类型的请求提供方便， 一般可直接用HEAD类型的请求获取总数④ “join”:”&amp;&#x2F;Table0,&lt;&#x2F;Table1&#x2F;key1@” 或 “join”:{    “&amp;&#x2F;Table0”:{},  &#x2F;&#x2F; 支持 ON 多个字段关联,    “&lt;&#x2F;Table1&#x2F;key1@”:{  &#x2F;&#x2F; ON 只允许指定的 key1 关联      “key0”:value0,  &#x2F;&#x2F; 其它ON条件       “key2”:value2,      …       “@combine”:”…”,  &#x2F;&#x2F; 其它ON条件的组合方式       “@column”:”…”,  &#x2F;&#x2F; 外层 SELECT       “@group”:”…”,  &#x2F;&#x2F; 外层 GROUP BY       “@having”:”…”  &#x2F;&#x2F; 外层 HAVING     }}多表连接方式：  “@” - APP JOIN  “&lt;“ - LEFT JOIN  “&gt;” - RIGHT JOIN  “&amp;” - INNER JOIN  “|” - FULL JOIN   “!” - OUTER JOIN   “*” - CROSS JOIN   “^” - SIDE JOIN   “(“ - ANTI JOIN   “)” - FOREIGN JOIN 其中 @ APP JOIN 为应用层连表，会从已查出的主表里取得所有副表 key@ 关联的主表内的 refKey 作为一个数组 refKeys: [value0, value1…]，然后把原来副表 count 次查询 key&#x3D;$refKey 的 SQL 用 key IN($refKeys) 的方式合并为一条 SQL 来优化性能； 其它 JOIN 都是 SQL JOIN，具体功能和 MySQL,PostgreSQL 等数据库的 JOIN 一一对应 &quot;join&quot;:&quot;&lt;&#x2F;ViceTable&#x2F;key@&quot;,&quot;MainTable&quot;:{},&quot;ViceTable&quot;:{&quot;key@&quot;:&quot;&#x2F;MainTable&#x2F;refKey&quot;}会对应生成 MainTable LEFT JOIN ViceTable ON ViceTable.key&#x3D;MainTable.refKey AND 其它ON条件  除了 &#x3D; 等价关联，也支持 ! 不等关联、&gt; &lt; &gt;&#x3D; &lt;&#x3D; 等比较关联和 $ ~ {} &lt;&gt; 等其它复杂关联方式 ⑤ “otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 查询User数组，最多5个：“count”:5对应SQL是LIMIT 5  ② 查询第3页的User数组，每页5个：“count”:5,“page”:3对应SQL是LIMIT 5 OFFSET 15  ③ 查询User数组和对应的User总数：“[]”:{    “query”:2,    “User”:{}},“total@”:”&#x2F;[]&#x2F;total”,“info@”:”&#x2F;[]&#x2F;info” 返回的数据中，总数及分页详情结构为：   “total”:139,  &#x2F;&#x2F;总数  “info”:{  &#x2F;&#x2F;分页详情     “total”:139,  &#x2F;&#x2F;总数     “count”:5,  &#x2F;&#x2F;每页数量     “page”:0,  &#x2F;&#x2F;当前页码     “max”:27,  &#x2F;&#x2F;最大页码     “more”:true,  &#x2F;&#x2F;是否还有更多     “first”:true,  &#x2F;&#x2F;是否为首页     “last”:false  &#x2F;&#x2F;是否为尾页 }  ④ Moment INNER JOIN User LEFT JOIN Comment：“[]”:{    “join”:”&amp;&#x2F;User&#x2F;id@,&lt;&#x2F;Comment”,    “Moment”:{     “@group”:”id”  &#x2F;&#x2F;主副表不是一对一，要去除重复数据   },    “User”:{      “name~”:”t”,      “id@”:”&#x2F;Moment&#x2F;userId”    },    “Comment”:{      “momentId@”:”&#x2F;Moment&#x2F;id”    }} ⑤ 每一层都加当前用户名：“User”:{},“[]”:{    “name@”:”User&#x2F;name”, &#x2F;&#x2F;自定义关键词    “Moment”:{}}


对象关键词，可自定义
“@key”:Object，@key为 Table:{} 中{}内的关键词，Object的类型由@key指定① “@combine”:”key0 | (key1 &amp; (key2 | !key3))…”，条件组合方式，最终按  (其它key条件 AND 连接) AND (key0条件 OR (key1条件 AND (key2条件 OR (NOT key3条件)))) 这种方式连接，其中 “其它key” 是指与 @combine 在同一对象，且未被它声明的条件 key，默认都是 &amp; 连接。注意不要缺少或多余任何一个空格。 ② “@column”:”column;function(arg)…”，返回字段③ “@order”:”column0+,column1-…”，排序方式④ “@group”:”column0,column1…”，分组方式。如果@column里声明了Table的id，则id也必须在@group中声明；其它情况下必须满足至少一个条件:1.分组的key在@column里声明2.Table主键在@group中声明 ⑤ “@having”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…” &#x2F;&#x2F; OR 连接，或 “@having&amp;”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…”  &#x2F;&#x2F; AND 连接，或 “@having”:{   “h0”:”function0(…)?value0”,   “h1”:function1(…)?value1”,   “h2”:function2(…)?value2…”,   “@combine”:”h0 &amp; (h1 | !h2)”  &#x2F;&#x2F; 任意组合，非必传}SQL函数条件，一般和@group一起用，函数一般在@column里声明⑥ “@schema”:”sys”，集合空间(数据库名&#x2F;模式)，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑦ “@database”:”POSTGRESQL”，数据库类型，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑧ “@datasource”:”DRUID”，跨数据源，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑨ “@json”:”key0,key1…”，转为 JSON 格式返回，符合 JSONObject 则转为 {…}，符合 JSONArray 则转为 […] ⑩ “@role”:”OWNER”，来访角色，包括UNKNOWN,LOGIN,CONTACT,CIRCLE,OWNER,ADMIN，可以在最外层作为全局默认配置，可自定义其它角色并重写 Verifier.verify 等相关方法来自定义校验 ⑪ “@explain”:true，性能分析，可以在最外层作为全局默认配置 ⑫ “@raw”:”key0,key1…”，其中 key0, key1 都对应有键值对 “key0”:”SQL片段或SQL片段的别名”,  “key1”:”SQL片段或SQL片段的别名”  自定义原始SQL片段，可扩展嵌套SQL函数等复杂语句，必须是后端已配置的，只有其它功能符都做不到才考虑，谨慎使用，注意防SQL注入⑬ “@otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 搜索name或tag任何一个字段包含字符a的User列表： “name“:”a”,“tag“:”a”,“@combine”:”name~ | tag~” 对应SQL是name REGEXP &#39;a&#39; OR tag REGEXP &#39;a&#39;  ② 只查询id,sex,name这几列并且请求结果也按照这个顺序：“@column”:”id,sex,name”对应SQL是SELECT id,sex,name  ③ 查询按 name降序、id默认顺序 排序的User数组：“@order”:”name-,id”对应SQL是ORDER BY name DESC,id  ④ 查询按userId分组的Moment数组：“@group”:”userId,id”对应SQL是GROUP BY userId,id  ⑤ 查询 按userId分组、id最大值&gt;&#x3D;100 的Moment数组：“@column”:”userId;max(id)”,“@group”:”userId”,“@having”:”max(id)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) ... GROUP BY userId HAVING max(id)&gt;&#x3D;100 还可以指定函数返回名：“@column”:”userId;max(id):maxId”,“@group”:”userId”,“@having”:”(maxId)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) AS maxId ... GROUP BY userId HAVING (maxId)&gt;&#x3D;100  ⑥ 查询 sys 内的 User 表：“@schema”:”sys”对应SQL是FROM sys.User  ⑦ 查询 PostgreSQL 数据库的 User 表：“@database”:”POSTGRESQL” ⑧ 使用 Druid 连接池查询 User 表：“@datasource”:”DRUID” ⑨ 将 VARCHAR 字符串字段 get 转为 JSONArray 返回：“@json”:”get” ⑩ 查询当前用户的动态：“@role”:”OWNER” ⑪ 开启性能分析：“@explain”:true对应SQL是EXPLAIN  ⑫ 统计最近一周偶数userId的数量“@column”:”date;left(date,10):day;sum(if(userId%2&#x3D;0,1,0))”,“@group”:”day”,“@having”:”to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7”,“@raw”:”@column,@having”对应SQL是SELECT date, left(date,10) AS day, sum(if(userId%2&#x3D;0,1,0)) ... GROUP BY day HAVING to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7  ⑬ 从pictureList获取第0张图片：“@position”:0, &#x2F;&#x2F;自定义关键词“firstPicture()”:”getFromArray(pictureList,@position)”


全局关键词
为最外层对象 {} 内的关键词。其中 @database，@schema, @datasource, @role, @explain 基本同对象关键词，见上方说明，区别是全局关键词会每个表对象中没有时自动放入，作为默认值。 ① “tag”:String，后面的 tag 是非 GET、HEAD 请求中匹配请求的 JSON 结构的标识，一般是要查询的 Table 的名称或该名称对应的数组 Table[] 或 Table:[]，由后端 Request 表中指定。 ② “version”:Integer，接口版本，version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本，由后端 Request 表中指定。③ “format”:Boolean，格式化返回 Response JSON 的 key，一般是将 TableName 转为 tableName, TableName[] 转为 tableNameList, Table:alias 转为 alias, TableName-key[] 转为 tableNameKeyList 等小驼峰格式。
①  查隐私信息：[{“tag”:”Privacy”,”Privacy”:{“id”:82001}}](http:&#x2F;&#x2F;apijson.cn&#x2F;api?url&#x3D;http%3A%2F%2Fapijson.cn%3A8080%2Fgets&amp;type&#x3D;JSON&amp;json&#x3D;


</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2.4"><span class="toc-number">1.6.12.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%89%8D%E7%AB%AF%E5%AF%B9%E5%BA%94%E4%B8%8D%E5%90%8C%E9%9C%80%E6%B1%82%E7%9A%84%E8%AF%B7%E6%B1%82"><span class="toc-number">1.6.13.</span> <span class="toc-text">2.5 前端对应不同需求的请求


前端的请求
传统方式
APIJSON



User
base_url&#x2F;get&#x2F;user?id&#x3D;38710
base_url&#x2F;get&#x2F;{    “User”:{      “id”:38710    }}


Moment和对应的User
分两次请求Moment:  base_url&#x2F;get&#x2F;moment?userId&#x3D;38710User:  base_url&#x2F;get&#x2F;user?id&#x3D;38710
base_url&#x2F;get&#x2F;{    “Moment”:{      “userId”:38710    },     “User”:{      “id”:38710    }}


User列表
base_url&#x2F;get&#x2F;user&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;sex&#x3D;0
base_url&#x2F;get&#x2F;{    “User[]”:{      “page”:0,       “count”:3,       “User”:{        “sex”:0      }    }}


Moment列表，每个Moment包括1.发布者User2.前3条Comment
Moment里必须有1.User对象2.Comment数组 base_url&#x2F;get&#x2F;moment&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;commentCount&#x3D;3
base_url&#x2F;get&#x2F;{    “[]”:{      “page”:0,       “count”:3,       “Moment”:{},       “User”:{        “id@”:”&#x2F;Moment&#x2F;userId”      },      “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }}


User发布的Moment列表， 每个Moment包括 1.发布者User 2.前3条Comment
1.Moment里必须有User对象和Comment数组 2.字段名必须查接口文档，例如评论数量字段名可能是 commentCount,comment_count或者简写cmt_count等各种奇葩写法…  base_url&#x2F;get&#x2F;moment&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;commentCount&#x3D;3&amp;userId&#x3D;38710
有以下几种方式: ① 把以上请求里的“Moment”:{}, “User”:{“id@”:”&#x2F;Moment&#x2F;userId”}改为“Moment”:{“userId”:38710}, “User”:{“id”:38710}  ② 或把User放在上面的最外层省去重复的Userbase_url&#x2F;get&#x2F;{    “User”:{      “id”:38710    },    “[]”:{      “page”:0,      “count”:3,       “Moment”:{        “userId”:38710      },       “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }} ③ 如果User之前已经获取到了，还可以不传User来节省请求和返回数据的流量并提升速度base_url&#x2F;get&#x2F;{    “[]”:{      “page”:0,      “count”:3,       “Moment”:{        “userId”:38710      },      “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }}


 
 
2.6 后端对应不同请求的返回结果


后端的返回结果
传统方式
APIJSON



User
{    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
{    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


Moment和对应的User
分别返回两次请求的结果，获取到Moment后取出userId作为User的id条件去查询User  Moment:  {    “data”:{      “id”:235,      “content”:”xxx”,      …    },    “code”:200,    “msg”:”success”}  User:  {    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
一次性返回，没有传统方式导致的 长时间等待结果、两次结果间关联、线程多次切换 等问题  {    “Moment”:{      “id”:235,      “content”:”xxx”,      …    },    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


User列表
{    “data”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}
{    “User[]”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}


Moment列表，每个Moment包括发布者User和前3条Comment
Moment里必须有1.User对象2.Comment数组  {    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          …        },        “Comment”:[          …        ]      },      {        “id”:301,        “content”:”xxx”,        …,        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}
1.高灵活，可任意组合2.低耦合，逻辑很清晰{    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          …        },        “Comment[]”:[          …        ]      },      {        “Moment”:{          “id”:301,          “content”:”xxx”,          …        },        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}


User发布的Moment列表，每个Moment包括发布者User和前3条Comment
1.大量重复User，浪费流量和服务器性能2.优化很繁琐，需要后端扩展接口、写好文档，前端&#x2F;前端再配合优化{    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:470,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:511,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:595,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      …    ],    “code”:200,    “msg”:”success”}
以上不同请求方式的结果: ① 常规请求  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ② 省去重复的User  {    “User”:{      “id”:38710,      “name”:”Tommy”,      …    },    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ③ 不查询已获取到的User  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”}


1.base_url指基地址，一般是顶级域名，其它分支url都是在base_url后扩展。如base_url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F; ，对应的GET分支url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F;get&#x2F; 。下同。2.请求中的key或value任意一个为null值时，这个 key:value键值对 被视为无效。下同。3.请求中的 &#x2F; 需要转义。JSONRequest.java已经用URLEncoder.encode转义，不需要再写；但如果是浏览器或Postman等直接输入url&#x2F;request，需要把request中的所有 &#x2F; 都改成 %252F 。下同。4.code，指返回结果中的状态码，200表示成功，其它都是错误码，值全部都是HTTP标准状态码。下同。5.msg，指返回结果中的状态信息，对成功结果或错误原因的详细说明。下同。6.code和msg总是在返回结果的同一层级成对出现。对所有请求的返回结果都会在最外层有一对总结式code和msg。下同。7.id等字段对应的值仅供说明，不一定是数据库里存在的，请求里用的是真实存在的值。下同。



3.设计规范3.1 操作方法


方法及说明
URL
Request
Response



GET:  普通获取数据， 可用浏览器调试
base_url&#x2F;get&#x2F;
{    TableName:{      …     }}  {…}内为限制条件 例如获取一个 id &#x3D; 235 的 Moment： {    “Moment”:{      “id”:235    }}  后端校验通过后自动解析为 SQL 并执行：SELECT * FROM Moment WHERE id&#x3D;235 LIMIT 1
{    TableName:{      …    },    “code”:200,    “msg”:”success”}例如{    “Moment”:{      “id”:235,      “userId”:38710,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “code”:200,    “msg”:”success” }


HEAD:  普通获取数量， 可用浏览器调试
base_url&#x2F;head&#x2F;
{    TableName:{      …    } }  {…}内为限制条件  例如获取一个 id &#x3D; 38710 的 User 所发布的 Moment 总数： {    “Moment”:{      “userId”:38710    }}  后端校验通过后自动解析为 SQL 并执行：SELECT count(*) FROM Moment WHERE userId&#x3D;38710 LIMIT 1
{    TableName:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,    “msg”:”success”}  例如{    “Moment”:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,     “msg”:”success”}


GETS:  安全&#x2F;私密获取数据， 用于获取钱包等对安全性要求高的数据
base_url&#x2F;gets&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Privacy”，其它同GET
同GET


HEADS:  安全&#x2F;私密获取数量， 用于获取银行卡数量等对安全性要求高的数据总数
base_url&#x2F;heads&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Verify”，其它同HEAD
同HEAD


POST:  新增数据
base_url&#x2F;post&#x2F;
单个：  {    TableName:{      …    },    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 38710 发布一个新 Comment：{    “Comment”:{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”     },    “tag”:”Comment”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(38710,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;)    批量：  {    TableName[]:[{        …      }, {        …      }      …    ],    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 82001 发布 2 个 Comment：{    “Comment[]”:[{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”      }, {      “momentId”:15,      “content”:”APIJSON is a JSON transmision protocol.”    }],    “tag”:”Comment:[]”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(82001,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;);INSERT INTO Comment(userId,momentId,content) VALUES(82001,15,&#39;APIJSON is a JSON transmision protocol.&#39;);
单个：  {    TableName:{      “code”:200,      “msg”:”success”,      “id”:38710    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “id”:120    },    “code”:200,    “msg”:”success”}   批量：  {    TableName:{      “code”:200,      “msg”:”success”,      “count”:5,      “id[]”:[1, 2, 3, 4, 5]    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “count”:2,      “id[]”:[1, 2]    },    “code”:200,    “msg”:”success”}


PUT:  修改数据， 只修改所传的字段
base_url&#x2F;put&#x2F;
{    TableName:{      “id”:id,      …    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个 例如当前登录用户 82001 修改 id &#x3D; 235 的 Moment 的 content：{    “Moment”:{      “id”:235,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “tag”:”Moment”}  后端校验通过后自动解析为 SQL 并执行：UPDATE Moment SET content&#x3D;&#39;APIJSON,let interfaces and documents go to hell !&#39; WHERE id&#x3D;235 AND userId&#x3D;82001 LIMIT 1  批量除了 id{}:[] 也可类似批量 POST，只是每个 {…} 里面都必须有 id。“tag”:”Comment[]” 对应对象 “Comment”:{“id{}”:[1,2,3]}，表示指定记录全部统一设置；“tag”:”Comment:[]” 多了冒号，对应数组 “Comment[]”:[{“id”:1},{“id”:2},{“id”:3}]，表示每项单独设置
同POST


DELETE:  删除数据
base_url&#x2F;delete&#x2F;
{    TableName:{      “id”:id    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个，一般只传 id 或 id{} 例如当前登录用户 82001 批量删除 id &#x3D; 100,110,120 的 Comment：{    “Comment”:{      “id{}”:[100,110,120]    },    “tag”:”Comment[]”}  后端校验通过后自动解析为 SQL 并执行：DELETE FROM Comment WHERE id IN(100,110,120) AND userId&#x3D;82001 LIMIT 3
{    TableName:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120]      “count”:3    },    “code”:200,    “msg”:”success”}例如{   “Comment”:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120],      “count”:3   },   “code”:200,   “msg”:”success”}


以上接口的简单形式:  base_url&#x2F;{method}&#x2F;{tag}
GET: 普通获取数据  base_url&#x2F;get&#x2F;{tag}  HEAD: 普通获取数量  base_url&#x2F;head&#x2F;{tag}  GETS: 安全&#x2F;私密获取数据   base_url&#x2F;gets&#x2F;{tag}  HEADS: 安全&#x2F;私密获取数量  base_url&#x2F;heads&#x2F;{tag}  POST: 新增数据   base_url&#x2F;post&#x2F;{tag}  PUT: 修改数据  base_url&#x2F;put&#x2F;{tag}  DELETE: 删除数据  base_url&#x2F;delete&#x2F;{tag}
例如安全&#x2F;私密获取一个 id &#x3D; 82001 的 Privacy： base_url&#x2F;gets&#x2F;Privacy&#x2F;  {“id”:82001}  相当于  base_url&#x2F;gets&#x2F; {“tag”:”Privacy”, “Privacy”:{“id”:82001}}   例如批量修改 id &#x3D; 114, 124 的 Comment 的 content：base_url&#x2F;put&#x2F;Comemnt[]&#x2F;  {    “id{}”:[114,124],    “content”:”test multi put”}  相当于  base_url&#x2F;put&#x2F;  {    “tag”:”Comment[]”,     “Comment”:{      “id{}”:[114,124],      “content”:”test multi put”    }}
同以上对应的方法


1.TableName指要查询的数据库表Table的名称字符串。第一个字符为大写字母，剩下的字符要符合英语字母、数字、下划线中的任何一种。对应的值的类型为JSONObject，结构是 {…}，里面放的是Table的字段(列名)。下同。2.”tag”:tag 后面的tag是非GET、HEAD请求中匹配请求的JSON结构的标识，一般是要查询的Table的名称，由后端Request表中指定。下同。3.GET、HEAD请求是开放请求，可任意组合任意嵌套。其它请求为受限制的安全&#x2F;私密请求，对应的 方法（method）, 标识（tag）, 版本（version）, 结构（structure） 都必须和 后端Request表中所指定的 一一对应，否则请求将不被通过。version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本。下同。4.GETS与GET、HEADS与HEAD分别为同一类型的操作方法，请求稍有不同但返回结果相同。下同。5.在HTTP通信中，自动化接口(get,gets,head,heads,post,put,delete) 全用HTTP POST请求。下同。6.所有JSONObject都视为容器(或者文件夹)，结构为 {…} ，里面可以放普通对象或子容器。下同。7.每个对象都有一个唯一的路径(或者叫地址)，假设对象名为refKey，则用 key0&#x2F;key1&#x2F;…&#x2F;refKey 表示。下同。


3.2 功能符


功能
键值对格式
使用示例



查询数组
“key[]”:{}，后面是JSONObject，key可省略。当key和里面的Table名相同时，Table会被提取出来，即 {Table:{Content}} 会被转化为 {Content}
{“User[]”:{“User”:{}}}，查询一个User数组。这里key和Table名都是User，User会被提取出来，即 {“User”:{“id”, …}} 会被转化为 {“id”, …}，如果要进一步提取User中的id，可以把User[]改为User-id[]


匹配选项范围
“key{}”:[]，后面是JSONArray，作为key可取的值的选项
“id{}”:[38710,82001,70793]，对应SQL是id IN(38710,82001,70793)，查询id符合38710,82001,70793中任意一个的一个User数组


匹配条件范围
“key{}”:”条件0,条件1…”，条件为SQL表达式字符串，可进行数字比较运算等
“id{}”:”&lt;&#x3D;80000,&gt;90000”，对应SQL是id&lt;&#x3D;80000 OR id&gt;90000，查询id符合id&lt;&#x3D;80000 | id&gt;90000的一个User数组


包含选项范围
“key&lt;&gt;“:Object  &#x3D;&gt;  “key&lt;&gt;“:[Object]，key对应值的类型必须为JSONArray，Object类型不能为JSON
“contactIdList&lt;&gt;“:38710，对应SQL是json_contains(contactIdList,38710)，查询contactIdList包含38710的一个User数组


判断是否存在
“key}{@”:{    “from”:”Table”,    “Table”:{ … }}其中：}{ 表示 EXISTS； key 用来标识是哪个判断； @ 后面是 子查询 对象，具体见下方 子查询 的说明。
“id}{@”:{    “from”:”Comment”,    “Comment”:{        “momentId”:15     }} WHERE EXISTS(SELECT * FROM Comment WHERE momentId&#x3D;15)


远程调用函数
“key()”:”函数表达式”，函数表达式为 function(key0,key1…)，会调用后端对应的函数 function(JSONObject request, String key0, String key1…)，实现 参数校验、数值计算、数据同步、消息推送、字段拼接、结构变换 等特定的业务逻辑处理，可使用 - 和 + 表示优先级，解析 key-() &gt; 解析当前对象 &gt; 解析 key() &gt; 解析子对象 &gt; 解析 key+()
“isPraised()”:”isContain(praiseUserIdList,userId)”，会调用远程函数 boolean isContain(JSONObject request, String array, String value) ，然后变为 “isPraised”:true 这种（假设点赞用户id列表包含了userId，即这个User点了赞）


存储过程
“@key()”:”SQL函数表达式”，函数表达式为   function(key0,key1…)  会调用后端数据库对应的存储过程 SQL函数  function(String key0, String key1…)  除了参数会提前赋值，其它和 远程函数 一致
“@limit”:10,  “@offset”:0,  “@procedure()”:”getCommentByUserId(id,@limit,@offset)”  会转为  getCommentByUserId(38710,10,0)  来调用存储过程 SQL 函数  getCommentByUserId(IN id bigint, IN limit int, IN offset int)  然后变为 “procedure”:{    “count”:-1,     “update”:false,     “list”:[]  }  其中 count 是指写操作影响记录行数，-1 表示不是写操作；update 是指是否为写操作（增删改）；list 为返回结果集


引用赋值
“key@”:”key0&#x2F;key1&#x2F;…&#x2F;refKey”，引用路径为用&#x2F;分隔的字符串。以&#x2F;开头的是缺省引用路径，从声明key所处容器的父容器路径开始；其它是完整引用路径，从最外层开始。 被引用的refKey必须在声明key的上面。如果对refKey的容器指定了返回字段，则被引用的refKey必须写在@column对应的值内，例如 “@column”:”refKey,key1,…”
“Moment”:{    “userId”:38710},“User”:{    “id@”:”&#x2F;Moment&#x2F;userId”} User内的id引用了与User同级的Moment内的userId，即User.id &#x3D; Moment.userId，请求完成后 “id@”:”&#x2F;Moment&#x2F;userId” 会变成 “id”:38710


子查询
“key@”:{    “range”:”ALL”,     “from”:”Table”,    “Table”:{ … }}其中：range 可为 ALL,ANY；from 为目标表 Table 的名称；@ 后面的对象类似数组对象，可使用 count 和 join 等功能。
“id@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&#x3D;(SELECT min(userId) FROM Comment)


模糊搜索
&quot;key$&quot;:&quot;SQL搜索表达式&quot;  &#x3D;&gt;  &quot;key$&quot;:[&quot;SQL搜索表达式&quot;]，任意SQL搜索表达式字符串，如 %key%(包含key), key%(以key开始), %k%e%y%(包含字母k,e,y) 等，%表示任意字符
“name$”:”%m%”，对应SQL是name LIKE &#39;%m%&#39;，查询name包含”m”的一个User数组


正则匹配
“key“:”正则表达式”  &#x3D;&gt;  “key“:[“正则表达式”]，任意正则表达式字符串，如 ^[0-9]+$ ，*~ 忽略大小写，可用于高级搜索
“name~”:”^[0-9]+$”，对应SQL是name REGEXP &#39;^[0-9]+$&#39;，查询name中字符全为数字的一个User数组


连续范围
“key%”:”start,end”  &#x3D;&gt;  “key%”:[“start,end”]，其中 start 和 end 都只能为 Boolean, Number, String 中的一种，如 “2017-01-01,2019-01-01” ，[“1,90000”, “82001,100000”] ，可用于连续范围内的筛选
“date%”:”2017-10-01,2018-10-01”，对应SQL是date BETWEEN &#39;2017-10-01&#39; AND &#39;2018-10-01&#39;，查询在2017-10-01和2018-10-01期间注册的用户的一个User数组


新建别名
“name:alias”，name映射为alias，用alias替代name。可用于 column,Table,SQL函数 等。只用于GET类型、HEAD类型的请求
“@column”:”toId:parentId”，对应SQL是toId AS parentId，将查询的字段toId变为parentId返回


增加 或 扩展
“key+”:Object，Object的类型由key指定，且类型为Number,String,JSONArray中的一种。如 82001,”apijson”,[“url0”,”url1”] 等。只用于PUT请求
“praiseUserIdList+”:[82001]，对应SQL是json_insert(praiseUserIdList,82001)，添加一个点赞用户id，即这个用户点了赞


减少 或 去除
“key-“:Object，与”key+”相反
“balance-“:100.00，对应SQL是balance &#x3D; balance - 100.00，余额减少100.00，即花费了100元


比较运算
&gt;, &lt;, &gt;&#x3D;, &lt;&#x3D; 比较运算符，用于 ① 提供 “id{}”:”&lt;&#x3D;90000” 这种条件范围的简化写法 ② 实现子查询相关比较运算不支持 “key&#x3D;”:Object 和 “key!&#x3D;”:Object 这两种写法，直接用更简单的 “key”:Object 和 “key!”:Object 替代。
① “id&lt;&#x3D;”:90000，对应SQL是id&lt;&#x3D;90000，查询符合id&lt;&#x3D;90000的一个User数组 ② “id&gt;@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&gt;(SELECT min(userId) FROM Comment)


逻辑运算
&amp;, |, ! 逻辑运算符，对应数据库 SQL 中的 AND, OR, NOT。 横或纵与：同一键值对的值内条件默认 | 或连接，可以在 key 后加逻辑运算符来具体指定；不同键值对的条件默认 &amp; 与连接，可以用下面说明的对象关键词 @combine 来具体指定。 ① &amp; 可用于”key&amp;{}”:”条件”等② | 可用于”key|{}”:”条件”, “key|{}”:[]等，一般可省略③ ! 可单独使用，如”key!”:Object，也可像&amp;,|一样配合其他功能符使用  “key!”:null 无效，null 值会导致整个键值对被忽略解析，可以用 “key{}”:”!&#x3D;null” 替代，“key”:null 同理，用 “key{}”:”&#x3D;null” 替代。
① “id&amp;{}”:”&gt;80000,&lt;&#x3D;90000”，对应SQL是id&gt;80000 AND id&lt;&#x3D;90000，即id满足id&gt;80000 &amp; id&lt;&#x3D;90000 ② “id|{}”:”&gt;90000,&lt;&#x3D;80000”，同”id{}”:”&gt;90000,&lt;&#x3D;80000”，对应SQL是id&gt;80000 OR id&lt;&#x3D;90000，即id满足id&gt;90000 | id&lt;&#x3D;80000 ③ “id!{}”:[82001,38710]，对应SQL是id NOT IN(82001,38710)，即id满足 ! (id&#x3D;82001 | id&#x3D;38710)，可过滤黑名单的消息


数组关键词，可自定义
“key”:Object，key为 “[]”:{} 中{}内的关键词，Object的类型由key指定① “count”:Integer，查询数量，0 表示最大值，默认最大值为100 ② “page”:Integer，查询页码，从0开始，默认最大值为100，一般和count一起用③ “query”:Integer，查询内容0-对象，1-总数和分页详情，2-数据、总数和分页详情总数关键词为 total，分页详情关键词为 info， 它们都和 query 同级，通过引用赋值得到，例如  “total@”:”&#x2F;[]&#x2F;total”, “info@”:”&#x2F;[]&#x2F;info” 这里query及total仅为GET类型的请求提供方便， 一般可直接用HEAD类型的请求获取总数④ “join”:”&amp;&#x2F;Table0,&lt;&#x2F;Table1&#x2F;key1@” 或 “join”:{    “&amp;&#x2F;Table0”:{},  &#x2F;&#x2F; 支持 ON 多个字段关联,    “&lt;&#x2F;Table1&#x2F;key1@”:{  &#x2F;&#x2F; ON 只允许指定的 key1 关联      “key0”:value0,  &#x2F;&#x2F; 其它ON条件       “key2”:value2,      …       “@combine”:”…”,  &#x2F;&#x2F; 其它ON条件的组合方式       “@column”:”…”,  &#x2F;&#x2F; 外层 SELECT       “@group”:”…”,  &#x2F;&#x2F; 外层 GROUP BY       “@having”:”…”  &#x2F;&#x2F; 外层 HAVING     }}多表连接方式：  “@” - APP JOIN  “&lt;“ - LEFT JOIN  “&gt;” - RIGHT JOIN  “&amp;” - INNER JOIN  “|” - FULL JOIN   “!” - OUTER JOIN   “*” - CROSS JOIN   “^” - SIDE JOIN   “(“ - ANTI JOIN   “)” - FOREIGN JOIN 其中 @ APP JOIN 为应用层连表，会从已查出的主表里取得所有副表 key@ 关联的主表内的 refKey 作为一个数组 refKeys: [value0, value1…]，然后把原来副表 count 次查询 key&#x3D;$refKey 的 SQL 用 key IN($refKeys) 的方式合并为一条 SQL 来优化性能； 其它 JOIN 都是 SQL JOIN，具体功能和 MySQL,PostgreSQL 等数据库的 JOIN 一一对应 &quot;join&quot;:&quot;&lt;&#x2F;ViceTable&#x2F;key@&quot;,&quot;MainTable&quot;:{},&quot;ViceTable&quot;:{&quot;key@&quot;:&quot;&#x2F;MainTable&#x2F;refKey&quot;}会对应生成 MainTable LEFT JOIN ViceTable ON ViceTable.key&#x3D;MainTable.refKey AND 其它ON条件  除了 &#x3D; 等价关联，也支持 ! 不等关联、&gt; &lt; &gt;&#x3D; &lt;&#x3D; 等比较关联和 $ ~ {} &lt;&gt; 等其它复杂关联方式 ⑤ “otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 查询User数组，最多5个：“count”:5对应SQL是LIMIT 5  ② 查询第3页的User数组，每页5个：“count”:5,“page”:3对应SQL是LIMIT 5 OFFSET 15  ③ 查询User数组和对应的User总数：“[]”:{    “query”:2,    “User”:{}},“total@”:”&#x2F;[]&#x2F;total”,“info@”:”&#x2F;[]&#x2F;info” 返回的数据中，总数及分页详情结构为：   “total”:139,  &#x2F;&#x2F;总数  “info”:{  &#x2F;&#x2F;分页详情     “total”:139,  &#x2F;&#x2F;总数     “count”:5,  &#x2F;&#x2F;每页数量     “page”:0,  &#x2F;&#x2F;当前页码     “max”:27,  &#x2F;&#x2F;最大页码     “more”:true,  &#x2F;&#x2F;是否还有更多     “first”:true,  &#x2F;&#x2F;是否为首页     “last”:false  &#x2F;&#x2F;是否为尾页 }  ④ Moment INNER JOIN User LEFT JOIN Comment：“[]”:{    “join”:”&amp;&#x2F;User&#x2F;id@,&lt;&#x2F;Comment”,    “Moment”:{     “@group”:”id”  &#x2F;&#x2F;主副表不是一对一，要去除重复数据   },    “User”:{      “name~”:”t”,      “id@”:”&#x2F;Moment&#x2F;userId”    },    “Comment”:{      “momentId@”:”&#x2F;Moment&#x2F;id”    }} ⑤ 每一层都加当前用户名：“User”:{},“[]”:{    “name@”:”User&#x2F;name”, &#x2F;&#x2F;自定义关键词    “Moment”:{}}


对象关键词，可自定义
“@key”:Object，@key为 Table:{} 中{}内的关键词，Object的类型由@key指定① “@combine”:”key0 | (key1 &amp; (key2 | !key3))…”，条件组合方式，最终按  (其它key条件 AND 连接) AND (key0条件 OR (key1条件 AND (key2条件 OR (NOT key3条件)))) 这种方式连接，其中 “其它key” 是指与 @combine 在同一对象，且未被它声明的条件 key，默认都是 &amp; 连接。注意不要缺少或多余任何一个空格。 ② “@column”:”column;function(arg)…”，返回字段③ “@order”:”column0+,column1-…”，排序方式④ “@group”:”column0,column1…”，分组方式。如果@column里声明了Table的id，则id也必须在@group中声明；其它情况下必须满足至少一个条件:1.分组的key在@column里声明2.Table主键在@group中声明 ⑤ “@having”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…” &#x2F;&#x2F; OR 连接，或 “@having&amp;”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…”  &#x2F;&#x2F; AND 连接，或 “@having”:{   “h0”:”function0(…)?value0”,   “h1”:function1(…)?value1”,   “h2”:function2(…)?value2…”,   “@combine”:”h0 &amp; (h1 | !h2)”  &#x2F;&#x2F; 任意组合，非必传}SQL函数条件，一般和@group一起用，函数一般在@column里声明⑥ “@schema”:”sys”，集合空间(数据库名&#x2F;模式)，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑦ “@database”:”POSTGRESQL”，数据库类型，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑧ “@datasource”:”DRUID”，跨数据源，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑨ “@json”:”key0,key1…”，转为 JSON 格式返回，符合 JSONObject 则转为 {…}，符合 JSONArray 则转为 […] ⑩ “@role”:”OWNER”，来访角色，包括UNKNOWN,LOGIN,CONTACT,CIRCLE,OWNER,ADMIN，可以在最外层作为全局默认配置，可自定义其它角色并重写 Verifier.verify 等相关方法来自定义校验 ⑪ “@explain”:true，性能分析，可以在最外层作为全局默认配置 ⑫ “@raw”:”key0,key1…”，其中 key0, key1 都对应有键值对 “key0”:”SQL片段或SQL片段的别名”,  “key1”:”SQL片段或SQL片段的别名”  自定义原始SQL片段，可扩展嵌套SQL函数等复杂语句，必须是后端已配置的，只有其它功能符都做不到才考虑，谨慎使用，注意防SQL注入⑬ “@otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 搜索name或tag任何一个字段包含字符a的User列表： “name“:”a”,“tag“:”a”,“@combine”:”name~ | tag~” 对应SQL是name REGEXP &#39;a&#39; OR tag REGEXP &#39;a&#39;  ② 只查询id,sex,name这几列并且请求结果也按照这个顺序：“@column”:”id,sex,name”对应SQL是SELECT id,sex,name  ③ 查询按 name降序、id默认顺序 排序的User数组：“@order”:”name-,id”对应SQL是ORDER BY name DESC,id  ④ 查询按userId分组的Moment数组：“@group”:”userId,id”对应SQL是GROUP BY userId,id  ⑤ 查询 按userId分组、id最大值&gt;&#x3D;100 的Moment数组：“@column”:”userId;max(id)”,“@group”:”userId”,“@having”:”max(id)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) ... GROUP BY userId HAVING max(id)&gt;&#x3D;100 还可以指定函数返回名：“@column”:”userId;max(id):maxId”,“@group”:”userId”,“@having”:”(maxId)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) AS maxId ... GROUP BY userId HAVING (maxId)&gt;&#x3D;100  ⑥ 查询 sys 内的 User 表：“@schema”:”sys”对应SQL是FROM sys.User  ⑦ 查询 PostgreSQL 数据库的 User 表：“@database”:”POSTGRESQL” ⑧ 使用 Druid 连接池查询 User 表：“@datasource”:”DRUID” ⑨ 将 VARCHAR 字符串字段 get 转为 JSONArray 返回：“@json”:”get” ⑩ 查询当前用户的动态：“@role”:”OWNER” ⑪ 开启性能分析：“@explain”:true对应SQL是EXPLAIN  ⑫ 统计最近一周偶数userId的数量“@column”:”date;left(date,10):day;sum(if(userId%2&#x3D;0,1,0))”,“@group”:”day”,“@having”:”to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7”,“@raw”:”@column,@having”对应SQL是SELECT date, left(date,10) AS day, sum(if(userId%2&#x3D;0,1,0)) ... GROUP BY day HAVING to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7  ⑬ 从pictureList获取第0张图片：“@position”:0, &#x2F;&#x2F;自定义关键词“firstPicture()”:”getFromArray(pictureList,@position)”


全局关键词
为最外层对象 {} 内的关键词。其中 @database，@schema, @datasource, @role, @explain 基本同对象关键词，见上方说明，区别是全局关键词会每个表对象中没有时自动放入，作为默认值。 ① “tag”:String，后面的 tag 是非 GET、HEAD 请求中匹配请求的 JSON 结构的标识，一般是要查询的 Table 的名称或该名称对应的数组 Table[] 或 Table:[]，由后端 Request 表中指定。 ② “version”:Integer，接口版本，version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本，由后端 Request 表中指定。③ “format”:Boolean，格式化返回 Response JSON 的 key，一般是将 TableName 转为 tableName, TableName[] 转为 tableNameList, Table:alias 转为 alias, TableName-key[] 转为 tableNameKeyList 等小驼峰格式。
①  查隐私信息：[{“tag”:”Privacy”,”Privacy”:{“id”:82001}}](http:&#x2F;&#x2F;apijson.cn&#x2F;api?url&#x3D;http%3A%2F%2Fapijson.cn%3A8080%2Fgets&amp;type&#x3D;JSON&amp;json&#x3D;


</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2.5"><span class="toc-number">1.6.14.</span> <span class="toc-text">2.5 前端对应不同需求的请求


前端的请求
传统方式
APIJSON



User
base_url&#x2F;get&#x2F;user?id&#x3D;38710
base_url&#x2F;get&#x2F;{    “User”:{      “id”:38710    }}


Moment和对应的User
分两次请求Moment:  base_url&#x2F;get&#x2F;moment?userId&#x3D;38710User:  base_url&#x2F;get&#x2F;user?id&#x3D;38710
base_url&#x2F;get&#x2F;{    “Moment”:{      “userId”:38710    },     “User”:{      “id”:38710    }}


User列表
base_url&#x2F;get&#x2F;user&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;sex&#x3D;0
base_url&#x2F;get&#x2F;{    “User[]”:{      “page”:0,       “count”:3,       “User”:{        “sex”:0      }    }}


Moment列表，每个Moment包括1.发布者User2.前3条Comment
Moment里必须有1.User对象2.Comment数组 base_url&#x2F;get&#x2F;moment&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;commentCount&#x3D;3
base_url&#x2F;get&#x2F;{    “[]”:{      “page”:0,       “count”:3,       “Moment”:{},       “User”:{        “id@”:”&#x2F;Moment&#x2F;userId”      },      “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }}


User发布的Moment列表， 每个Moment包括 1.发布者User 2.前3条Comment
1.Moment里必须有User对象和Comment数组 2.字段名必须查接口文档，例如评论数量字段名可能是 commentCount,comment_count或者简写cmt_count等各种奇葩写法…  base_url&#x2F;get&#x2F;moment&#x2F;list?page&#x3D;0&amp;count&#x3D;3&amp;commentCount&#x3D;3&amp;userId&#x3D;38710
有以下几种方式: ① 把以上请求里的“Moment”:{}, “User”:{“id@”:”&#x2F;Moment&#x2F;userId”}改为“Moment”:{“userId”:38710}, “User”:{“id”:38710}  ② 或把User放在上面的最外层省去重复的Userbase_url&#x2F;get&#x2F;{    “User”:{      “id”:38710    },    “[]”:{      “page”:0,      “count”:3,       “Moment”:{        “userId”:38710      },       “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }} ③ 如果User之前已经获取到了，还可以不传User来节省请求和返回数据的流量并提升速度base_url&#x2F;get&#x2F;{    “[]”:{      “page”:0,      “count”:3,       “Moment”:{        “userId”:38710      },      “Comment[]”:{        “count”:3,        “Comment”:{          “momentId@”:”[]&#x2F;Moment&#x2F;id”        }      }    }}


 
 
2.6 后端对应不同请求的返回结果


后端的返回结果
传统方式
APIJSON



User
{    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
{    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


Moment和对应的User
分别返回两次请求的结果，获取到Moment后取出userId作为User的id条件去查询User  Moment:  {    “data”:{      “id”:235,      “content”:”xxx”,      …    },    “code”:200,    “msg”:”success”}  User:  {    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
一次性返回，没有传统方式导致的 长时间等待结果、两次结果间关联、线程多次切换 等问题  {    “Moment”:{      “id”:235,      “content”:”xxx”,      …    },    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


User列表
{    “data”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}
{    “User[]”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}


Moment列表，每个Moment包括发布者User和前3条Comment
Moment里必须有1.User对象2.Comment数组  {    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          …        },        “Comment”:[          …        ]      },      {        “id”:301,        “content”:”xxx”,        …,        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}
1.高灵活，可任意组合2.低耦合，逻辑很清晰{    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          …        },        “Comment[]”:[          …        ]      },      {        “Moment”:{          “id”:301,          “content”:”xxx”,          …        },        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}


User发布的Moment列表，每个Moment包括发布者User和前3条Comment
1.大量重复User，浪费流量和服务器性能2.优化很繁琐，需要后端扩展接口、写好文档，前端&#x2F;前端再配合优化{    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:470,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:511,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:595,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      …    ],    “code”:200,    “msg”:”success”}
以上不同请求方式的结果: ① 常规请求  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ② 省去重复的User  {    “User”:{      “id”:38710,      “name”:”Tommy”,      …    },    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ③ 不查询已获取到的User  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”}


1.base_url指基地址，一般是顶级域名，其它分支url都是在base_url后扩展。如base_url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F; ，对应的GET分支url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F;get&#x2F; 。下同。2.请求中的key或value任意一个为null值时，这个 key:value键值对 被视为无效。下同。3.请求中的 &#x2F; 需要转义。JSONRequest.java已经用URLEncoder.encode转义，不需要再写；但如果是浏览器或Postman等直接输入url&#x2F;request，需要把request中的所有 &#x2F; 都改成 %252F 。下同。4.code，指返回结果中的状态码，200表示成功，其它都是错误码，值全部都是HTTP标准状态码。下同。5.msg，指返回结果中的状态信息，对成功结果或错误原因的详细说明。下同。6.code和msg总是在返回结果的同一层级成对出现。对所有请求的返回结果都会在最外层有一对总结式code和msg。下同。7.id等字段对应的值仅供说明，不一定是数据库里存在的，请求里用的是真实存在的值。下同。



3.设计规范3.1 操作方法


方法及说明
URL
Request
Response



GET:  普通获取数据， 可用浏览器调试
base_url&#x2F;get&#x2F;
{    TableName:{      …     }}  {…}内为限制条件 例如获取一个 id &#x3D; 235 的 Moment： {    “Moment”:{      “id”:235    }}  后端校验通过后自动解析为 SQL 并执行：SELECT * FROM Moment WHERE id&#x3D;235 LIMIT 1
{    TableName:{      …    },    “code”:200,    “msg”:”success”}例如{    “Moment”:{      “id”:235,      “userId”:38710,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “code”:200,    “msg”:”success” }


HEAD:  普通获取数量， 可用浏览器调试
base_url&#x2F;head&#x2F;
{    TableName:{      …    } }  {…}内为限制条件  例如获取一个 id &#x3D; 38710 的 User 所发布的 Moment 总数： {    “Moment”:{      “userId”:38710    }}  后端校验通过后自动解析为 SQL 并执行：SELECT count(*) FROM Moment WHERE userId&#x3D;38710 LIMIT 1
{    TableName:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,    “msg”:”success”}  例如{    “Moment”:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,     “msg”:”success”}


GETS:  安全&#x2F;私密获取数据， 用于获取钱包等对安全性要求高的数据
base_url&#x2F;gets&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Privacy”，其它同GET
同GET


HEADS:  安全&#x2F;私密获取数量， 用于获取银行卡数量等对安全性要求高的数据总数
base_url&#x2F;heads&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Verify”，其它同HEAD
同HEAD


POST:  新增数据
base_url&#x2F;post&#x2F;
单个：  {    TableName:{      …    },    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 38710 发布一个新 Comment：{    “Comment”:{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”     },    “tag”:”Comment”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(38710,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;)    批量：  {    TableName[]:[{        …      }, {        …      }      …    ],    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 82001 发布 2 个 Comment：{    “Comment[]”:[{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”      }, {      “momentId”:15,      “content”:”APIJSON is a JSON transmision protocol.”    }],    “tag”:”Comment:[]”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(82001,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;);INSERT INTO Comment(userId,momentId,content) VALUES(82001,15,&#39;APIJSON is a JSON transmision protocol.&#39;);
单个：  {    TableName:{      “code”:200,      “msg”:”success”,      “id”:38710    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “id”:120    },    “code”:200,    “msg”:”success”}   批量：  {    TableName:{      “code”:200,      “msg”:”success”,      “count”:5,      “id[]”:[1, 2, 3, 4, 5]    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “count”:2,      “id[]”:[1, 2]    },    “code”:200,    “msg”:”success”}


PUT:  修改数据， 只修改所传的字段
base_url&#x2F;put&#x2F;
{    TableName:{      “id”:id,      …    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个 例如当前登录用户 82001 修改 id &#x3D; 235 的 Moment 的 content：{    “Moment”:{      “id”:235,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “tag”:”Moment”}  后端校验通过后自动解析为 SQL 并执行：UPDATE Moment SET content&#x3D;&#39;APIJSON,let interfaces and documents go to hell !&#39; WHERE id&#x3D;235 AND userId&#x3D;82001 LIMIT 1  批量除了 id{}:[] 也可类似批量 POST，只是每个 {…} 里面都必须有 id。“tag”:”Comment[]” 对应对象 “Comment”:{“id{}”:[1,2,3]}，表示指定记录全部统一设置；“tag”:”Comment:[]” 多了冒号，对应数组 “Comment[]”:[{“id”:1},{“id”:2},{“id”:3}]，表示每项单独设置
同POST


DELETE:  删除数据
base_url&#x2F;delete&#x2F;
{    TableName:{      “id”:id    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个，一般只传 id 或 id{} 例如当前登录用户 82001 批量删除 id &#x3D; 100,110,120 的 Comment：{    “Comment”:{      “id{}”:[100,110,120]    },    “tag”:”Comment[]”}  后端校验通过后自动解析为 SQL 并执行：DELETE FROM Comment WHERE id IN(100,110,120) AND userId&#x3D;82001 LIMIT 3
{    TableName:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120]      “count”:3    },    “code”:200,    “msg”:”success”}例如{   “Comment”:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120],      “count”:3   },   “code”:200,   “msg”:”success”}


以上接口的简单形式:  base_url&#x2F;{method}&#x2F;{tag}
GET: 普通获取数据  base_url&#x2F;get&#x2F;{tag}  HEAD: 普通获取数量  base_url&#x2F;head&#x2F;{tag}  GETS: 安全&#x2F;私密获取数据   base_url&#x2F;gets&#x2F;{tag}  HEADS: 安全&#x2F;私密获取数量  base_url&#x2F;heads&#x2F;{tag}  POST: 新增数据   base_url&#x2F;post&#x2F;{tag}  PUT: 修改数据  base_url&#x2F;put&#x2F;{tag}  DELETE: 删除数据  base_url&#x2F;delete&#x2F;{tag}
例如安全&#x2F;私密获取一个 id &#x3D; 82001 的 Privacy： base_url&#x2F;gets&#x2F;Privacy&#x2F;  {“id”:82001}  相当于  base_url&#x2F;gets&#x2F; {“tag”:”Privacy”, “Privacy”:{“id”:82001}}   例如批量修改 id &#x3D; 114, 124 的 Comment 的 content：base_url&#x2F;put&#x2F;Comemnt[]&#x2F;  {    “id{}”:[114,124],    “content”:”test multi put”}  相当于  base_url&#x2F;put&#x2F;  {    “tag”:”Comment[]”,     “Comment”:{      “id{}”:[114,124],      “content”:”test multi put”    }}
同以上对应的方法


1.TableName指要查询的数据库表Table的名称字符串。第一个字符为大写字母，剩下的字符要符合英语字母、数字、下划线中的任何一种。对应的值的类型为JSONObject，结构是 {…}，里面放的是Table的字段(列名)。下同。2.”tag”:tag 后面的tag是非GET、HEAD请求中匹配请求的JSON结构的标识，一般是要查询的Table的名称，由后端Request表中指定。下同。3.GET、HEAD请求是开放请求，可任意组合任意嵌套。其它请求为受限制的安全&#x2F;私密请求，对应的 方法（method）, 标识（tag）, 版本（version）, 结构（structure） 都必须和 后端Request表中所指定的 一一对应，否则请求将不被通过。version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本。下同。4.GETS与GET、HEADS与HEAD分别为同一类型的操作方法，请求稍有不同但返回结果相同。下同。5.在HTTP通信中，自动化接口(get,gets,head,heads,post,put,delete) 全用HTTP POST请求。下同。6.所有JSONObject都视为容器(或者文件夹)，结构为 {…} ，里面可以放普通对象或子容器。下同。7.每个对象都有一个唯一的路径(或者叫地址)，假设对象名为refKey，则用 key0&#x2F;key1&#x2F;…&#x2F;refKey 表示。下同。


3.2 功能符


功能
键值对格式
使用示例



查询数组
“key[]”:{}，后面是JSONObject，key可省略。当key和里面的Table名相同时，Table会被提取出来，即 {Table:{Content}} 会被转化为 {Content}
{“User[]”:{“User”:{}}}，查询一个User数组。这里key和Table名都是User，User会被提取出来，即 {“User”:{“id”, …}} 会被转化为 {“id”, …}，如果要进一步提取User中的id，可以把User[]改为User-id[]


匹配选项范围
“key{}”:[]，后面是JSONArray，作为key可取的值的选项
“id{}”:[38710,82001,70793]，对应SQL是id IN(38710,82001,70793)，查询id符合38710,82001,70793中任意一个的一个User数组


匹配条件范围
“key{}”:”条件0,条件1…”，条件为SQL表达式字符串，可进行数字比较运算等
“id{}”:”&lt;&#x3D;80000,&gt;90000”，对应SQL是id&lt;&#x3D;80000 OR id&gt;90000，查询id符合id&lt;&#x3D;80000 | id&gt;90000的一个User数组


包含选项范围
“key&lt;&gt;“:Object  &#x3D;&gt;  “key&lt;&gt;“:[Object]，key对应值的类型必须为JSONArray，Object类型不能为JSON
“contactIdList&lt;&gt;“:38710，对应SQL是json_contains(contactIdList,38710)，查询contactIdList包含38710的一个User数组


判断是否存在
“key}{@”:{    “from”:”Table”,    “Table”:{ … }}其中：}{ 表示 EXISTS； key 用来标识是哪个判断； @ 后面是 子查询 对象，具体见下方 子查询 的说明。
“id}{@”:{    “from”:”Comment”,    “Comment”:{        “momentId”:15     }} WHERE EXISTS(SELECT * FROM Comment WHERE momentId&#x3D;15)


远程调用函数
“key()”:”函数表达式”，函数表达式为 function(key0,key1…)，会调用后端对应的函数 function(JSONObject request, String key0, String key1…)，实现 参数校验、数值计算、数据同步、消息推送、字段拼接、结构变换 等特定的业务逻辑处理，可使用 - 和 + 表示优先级，解析 key-() &gt; 解析当前对象 &gt; 解析 key() &gt; 解析子对象 &gt; 解析 key+()
“isPraised()”:”isContain(praiseUserIdList,userId)”，会调用远程函数 boolean isContain(JSONObject request, String array, String value) ，然后变为 “isPraised”:true 这种（假设点赞用户id列表包含了userId，即这个User点了赞）


存储过程
“@key()”:”SQL函数表达式”，函数表达式为   function(key0,key1…)  会调用后端数据库对应的存储过程 SQL函数  function(String key0, String key1…)  除了参数会提前赋值，其它和 远程函数 一致
“@limit”:10,  “@offset”:0,  “@procedure()”:”getCommentByUserId(id,@limit,@offset)”  会转为  getCommentByUserId(38710,10,0)  来调用存储过程 SQL 函数  getCommentByUserId(IN id bigint, IN limit int, IN offset int)  然后变为 “procedure”:{    “count”:-1,     “update”:false,     “list”:[]  }  其中 count 是指写操作影响记录行数，-1 表示不是写操作；update 是指是否为写操作（增删改）；list 为返回结果集


引用赋值
“key@”:”key0&#x2F;key1&#x2F;…&#x2F;refKey”，引用路径为用&#x2F;分隔的字符串。以&#x2F;开头的是缺省引用路径，从声明key所处容器的父容器路径开始；其它是完整引用路径，从最外层开始。 被引用的refKey必须在声明key的上面。如果对refKey的容器指定了返回字段，则被引用的refKey必须写在@column对应的值内，例如 “@column”:”refKey,key1,…”
“Moment”:{    “userId”:38710},“User”:{    “id@”:”&#x2F;Moment&#x2F;userId”} User内的id引用了与User同级的Moment内的userId，即User.id &#x3D; Moment.userId，请求完成后 “id@”:”&#x2F;Moment&#x2F;userId” 会变成 “id”:38710


子查询
“key@”:{    “range”:”ALL”,     “from”:”Table”,    “Table”:{ … }}其中：range 可为 ALL,ANY；from 为目标表 Table 的名称；@ 后面的对象类似数组对象，可使用 count 和 join 等功能。
“id@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&#x3D;(SELECT min(userId) FROM Comment)


模糊搜索
&quot;key$&quot;:&quot;SQL搜索表达式&quot;  &#x3D;&gt;  &quot;key$&quot;:[&quot;SQL搜索表达式&quot;]，任意SQL搜索表达式字符串，如 %key%(包含key), key%(以key开始), %k%e%y%(包含字母k,e,y) 等，%表示任意字符
“name$”:”%m%”，对应SQL是name LIKE &#39;%m%&#39;，查询name包含”m”的一个User数组


正则匹配
“key“:”正则表达式”  &#x3D;&gt;  “key“:[“正则表达式”]，任意正则表达式字符串，如 ^[0-9]+$ ，*~ 忽略大小写，可用于高级搜索
“name~”:”^[0-9]+$”，对应SQL是name REGEXP &#39;^[0-9]+$&#39;，查询name中字符全为数字的一个User数组


连续范围
“key%”:”start,end”  &#x3D;&gt;  “key%”:[“start,end”]，其中 start 和 end 都只能为 Boolean, Number, String 中的一种，如 “2017-01-01,2019-01-01” ，[“1,90000”, “82001,100000”] ，可用于连续范围内的筛选
“date%”:”2017-10-01,2018-10-01”，对应SQL是date BETWEEN &#39;2017-10-01&#39; AND &#39;2018-10-01&#39;，查询在2017-10-01和2018-10-01期间注册的用户的一个User数组


新建别名
“name:alias”，name映射为alias，用alias替代name。可用于 column,Table,SQL函数 等。只用于GET类型、HEAD类型的请求
“@column”:”toId:parentId”，对应SQL是toId AS parentId，将查询的字段toId变为parentId返回


增加 或 扩展
“key+”:Object，Object的类型由key指定，且类型为Number,String,JSONArray中的一种。如 82001,”apijson”,[“url0”,”url1”] 等。只用于PUT请求
“praiseUserIdList+”:[82001]，对应SQL是json_insert(praiseUserIdList,82001)，添加一个点赞用户id，即这个用户点了赞


减少 或 去除
“key-“:Object，与”key+”相反
“balance-“:100.00，对应SQL是balance &#x3D; balance - 100.00，余额减少100.00，即花费了100元


比较运算
&gt;, &lt;, &gt;&#x3D;, &lt;&#x3D; 比较运算符，用于 ① 提供 “id{}”:”&lt;&#x3D;90000” 这种条件范围的简化写法 ② 实现子查询相关比较运算不支持 “key&#x3D;”:Object 和 “key!&#x3D;”:Object 这两种写法，直接用更简单的 “key”:Object 和 “key!”:Object 替代。
① “id&lt;&#x3D;”:90000，对应SQL是id&lt;&#x3D;90000，查询符合id&lt;&#x3D;90000的一个User数组 ② “id&gt;@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&gt;(SELECT min(userId) FROM Comment)


逻辑运算
&amp;, |, ! 逻辑运算符，对应数据库 SQL 中的 AND, OR, NOT。 横或纵与：同一键值对的值内条件默认 | 或连接，可以在 key 后加逻辑运算符来具体指定；不同键值对的条件默认 &amp; 与连接，可以用下面说明的对象关键词 @combine 来具体指定。 ① &amp; 可用于”key&amp;{}”:”条件”等② | 可用于”key|{}”:”条件”, “key|{}”:[]等，一般可省略③ ! 可单独使用，如”key!”:Object，也可像&amp;,|一样配合其他功能符使用  “key!”:null 无效，null 值会导致整个键值对被忽略解析，可以用 “key{}”:”!&#x3D;null” 替代，“key”:null 同理，用 “key{}”:”&#x3D;null” 替代。
① “id&amp;{}”:”&gt;80000,&lt;&#x3D;90000”，对应SQL是id&gt;80000 AND id&lt;&#x3D;90000，即id满足id&gt;80000 &amp; id&lt;&#x3D;90000 ② “id|{}”:”&gt;90000,&lt;&#x3D;80000”，同”id{}”:”&gt;90000,&lt;&#x3D;80000”，对应SQL是id&gt;80000 OR id&lt;&#x3D;90000，即id满足id&gt;90000 | id&lt;&#x3D;80000 ③ “id!{}”:[82001,38710]，对应SQL是id NOT IN(82001,38710)，即id满足 ! (id&#x3D;82001 | id&#x3D;38710)，可过滤黑名单的消息


数组关键词，可自定义
“key”:Object，key为 “[]”:{} 中{}内的关键词，Object的类型由key指定① “count”:Integer，查询数量，0 表示最大值，默认最大值为100 ② “page”:Integer，查询页码，从0开始，默认最大值为100，一般和count一起用③ “query”:Integer，查询内容0-对象，1-总数和分页详情，2-数据、总数和分页详情总数关键词为 total，分页详情关键词为 info， 它们都和 query 同级，通过引用赋值得到，例如  “total@”:”&#x2F;[]&#x2F;total”, “info@”:”&#x2F;[]&#x2F;info” 这里query及total仅为GET类型的请求提供方便， 一般可直接用HEAD类型的请求获取总数④ “join”:”&amp;&#x2F;Table0,&lt;&#x2F;Table1&#x2F;key1@” 或 “join”:{    “&amp;&#x2F;Table0”:{},  &#x2F;&#x2F; 支持 ON 多个字段关联,    “&lt;&#x2F;Table1&#x2F;key1@”:{  &#x2F;&#x2F; ON 只允许指定的 key1 关联      “key0”:value0,  &#x2F;&#x2F; 其它ON条件       “key2”:value2,      …       “@combine”:”…”,  &#x2F;&#x2F; 其它ON条件的组合方式       “@column”:”…”,  &#x2F;&#x2F; 外层 SELECT       “@group”:”…”,  &#x2F;&#x2F; 外层 GROUP BY       “@having”:”…”  &#x2F;&#x2F; 外层 HAVING     }}多表连接方式：  “@” - APP JOIN  “&lt;“ - LEFT JOIN  “&gt;” - RIGHT JOIN  “&amp;” - INNER JOIN  “|” - FULL JOIN   “!” - OUTER JOIN   “*” - CROSS JOIN   “^” - SIDE JOIN   “(“ - ANTI JOIN   “)” - FOREIGN JOIN 其中 @ APP JOIN 为应用层连表，会从已查出的主表里取得所有副表 key@ 关联的主表内的 refKey 作为一个数组 refKeys: [value0, value1…]，然后把原来副表 count 次查询 key&#x3D;$refKey 的 SQL 用 key IN($refKeys) 的方式合并为一条 SQL 来优化性能； 其它 JOIN 都是 SQL JOIN，具体功能和 MySQL,PostgreSQL 等数据库的 JOIN 一一对应 &quot;join&quot;:&quot;&lt;&#x2F;ViceTable&#x2F;key@&quot;,&quot;MainTable&quot;:{},&quot;ViceTable&quot;:{&quot;key@&quot;:&quot;&#x2F;MainTable&#x2F;refKey&quot;}会对应生成 MainTable LEFT JOIN ViceTable ON ViceTable.key&#x3D;MainTable.refKey AND 其它ON条件  除了 &#x3D; 等价关联，也支持 ! 不等关联、&gt; &lt; &gt;&#x3D; &lt;&#x3D; 等比较关联和 $ ~ {} &lt;&gt; 等其它复杂关联方式 ⑤ “otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 查询User数组，最多5个：“count”:5对应SQL是LIMIT 5  ② 查询第3页的User数组，每页5个：“count”:5,“page”:3对应SQL是LIMIT 5 OFFSET 15  ③ 查询User数组和对应的User总数：“[]”:{    “query”:2,    “User”:{}},“total@”:”&#x2F;[]&#x2F;total”,“info@”:”&#x2F;[]&#x2F;info” 返回的数据中，总数及分页详情结构为：   “total”:139,  &#x2F;&#x2F;总数  “info”:{  &#x2F;&#x2F;分页详情     “total”:139,  &#x2F;&#x2F;总数     “count”:5,  &#x2F;&#x2F;每页数量     “page”:0,  &#x2F;&#x2F;当前页码     “max”:27,  &#x2F;&#x2F;最大页码     “more”:true,  &#x2F;&#x2F;是否还有更多     “first”:true,  &#x2F;&#x2F;是否为首页     “last”:false  &#x2F;&#x2F;是否为尾页 }  ④ Moment INNER JOIN User LEFT JOIN Comment：“[]”:{    “join”:”&amp;&#x2F;User&#x2F;id@,&lt;&#x2F;Comment”,    “Moment”:{     “@group”:”id”  &#x2F;&#x2F;主副表不是一对一，要去除重复数据   },    “User”:{      “name~”:”t”,      “id@”:”&#x2F;Moment&#x2F;userId”    },    “Comment”:{      “momentId@”:”&#x2F;Moment&#x2F;id”    }} ⑤ 每一层都加当前用户名：“User”:{},“[]”:{    “name@”:”User&#x2F;name”, &#x2F;&#x2F;自定义关键词    “Moment”:{}}


对象关键词，可自定义
“@key”:Object，@key为 Table:{} 中{}内的关键词，Object的类型由@key指定① “@combine”:”key0 | (key1 &amp; (key2 | !key3))…”，条件组合方式，最终按  (其它key条件 AND 连接) AND (key0条件 OR (key1条件 AND (key2条件 OR (NOT key3条件)))) 这种方式连接，其中 “其它key” 是指与 @combine 在同一对象，且未被它声明的条件 key，默认都是 &amp; 连接。注意不要缺少或多余任何一个空格。 ② “@column”:”column;function(arg)…”，返回字段③ “@order”:”column0+,column1-…”，排序方式④ “@group”:”column0,column1…”，分组方式。如果@column里声明了Table的id，则id也必须在@group中声明；其它情况下必须满足至少一个条件:1.分组的key在@column里声明2.Table主键在@group中声明 ⑤ “@having”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…” &#x2F;&#x2F; OR 连接，或 “@having&amp;”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…”  &#x2F;&#x2F; AND 连接，或 “@having”:{   “h0”:”function0(…)?value0”,   “h1”:function1(…)?value1”,   “h2”:function2(…)?value2…”,   “@combine”:”h0 &amp; (h1 | !h2)”  &#x2F;&#x2F; 任意组合，非必传}SQL函数条件，一般和@group一起用，函数一般在@column里声明⑥ “@schema”:”sys”，集合空间(数据库名&#x2F;模式)，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑦ “@database”:”POSTGRESQL”，数据库类型，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑧ “@datasource”:”DRUID”，跨数据源，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑨ “@json”:”key0,key1…”，转为 JSON 格式返回，符合 JSONObject 则转为 {…}，符合 JSONArray 则转为 […] ⑩ “@role”:”OWNER”，来访角色，包括UNKNOWN,LOGIN,CONTACT,CIRCLE,OWNER,ADMIN，可以在最外层作为全局默认配置，可自定义其它角色并重写 Verifier.verify 等相关方法来自定义校验 ⑪ “@explain”:true，性能分析，可以在最外层作为全局默认配置 ⑫ “@raw”:”key0,key1…”，其中 key0, key1 都对应有键值对 “key0”:”SQL片段或SQL片段的别名”,  “key1”:”SQL片段或SQL片段的别名”  自定义原始SQL片段，可扩展嵌套SQL函数等复杂语句，必须是后端已配置的，只有其它功能符都做不到才考虑，谨慎使用，注意防SQL注入⑬ “@otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 搜索name或tag任何一个字段包含字符a的User列表： “name“:”a”,“tag“:”a”,“@combine”:”name~ | tag~” 对应SQL是name REGEXP &#39;a&#39; OR tag REGEXP &#39;a&#39;  ② 只查询id,sex,name这几列并且请求结果也按照这个顺序：“@column”:”id,sex,name”对应SQL是SELECT id,sex,name  ③ 查询按 name降序、id默认顺序 排序的User数组：“@order”:”name-,id”对应SQL是ORDER BY name DESC,id  ④ 查询按userId分组的Moment数组：“@group”:”userId,id”对应SQL是GROUP BY userId,id  ⑤ 查询 按userId分组、id最大值&gt;&#x3D;100 的Moment数组：“@column”:”userId;max(id)”,“@group”:”userId”,“@having”:”max(id)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) ... GROUP BY userId HAVING max(id)&gt;&#x3D;100 还可以指定函数返回名：“@column”:”userId;max(id):maxId”,“@group”:”userId”,“@having”:”(maxId)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) AS maxId ... GROUP BY userId HAVING (maxId)&gt;&#x3D;100  ⑥ 查询 sys 内的 User 表：“@schema”:”sys”对应SQL是FROM sys.User  ⑦ 查询 PostgreSQL 数据库的 User 表：“@database”:”POSTGRESQL” ⑧ 使用 Druid 连接池查询 User 表：“@datasource”:”DRUID” ⑨ 将 VARCHAR 字符串字段 get 转为 JSONArray 返回：“@json”:”get” ⑩ 查询当前用户的动态：“@role”:”OWNER” ⑪ 开启性能分析：“@explain”:true对应SQL是EXPLAIN  ⑫ 统计最近一周偶数userId的数量“@column”:”date;left(date,10):day;sum(if(userId%2&#x3D;0,1,0))”,“@group”:”day”,“@having”:”to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7”,“@raw”:”@column,@having”对应SQL是SELECT date, left(date,10) AS day, sum(if(userId%2&#x3D;0,1,0)) ... GROUP BY day HAVING to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7  ⑬ 从pictureList获取第0张图片：“@position”:0, &#x2F;&#x2F;自定义关键词“firstPicture()”:”getFromArray(pictureList,@position)”


全局关键词
为最外层对象 {} 内的关键词。其中 @database，@schema, @datasource, @role, @explain 基本同对象关键词，见上方说明，区别是全局关键词会每个表对象中没有时自动放入，作为默认值。 ① “tag”:String，后面的 tag 是非 GET、HEAD 请求中匹配请求的 JSON 结构的标识，一般是要查询的 Table 的名称或该名称对应的数组 Table[] 或 Table:[]，由后端 Request 表中指定。 ② “version”:Integer，接口版本，version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本，由后端 Request 表中指定。③ “format”:Boolean，格式化返回 Response JSON 的 key，一般是将 TableName 转为 tableName, TableName[] 转为 tableNameList, Table:alias 转为 alias, TableName-key[] 转为 tableNameKeyList 等小驼峰格式。
①  查隐私信息：[{“tag”:”Privacy”,”Privacy”:{“id”:82001}}](http:&#x2F;&#x2F;apijson.cn&#x2F;api?url&#x3D;http%3A%2F%2Fapijson.cn%3A8080%2Fgets&amp;type&#x3D;JSON&amp;json&#x3D;


</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2.5"><span class="toc-number">1.6.15.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E5%90%8E%E7%AB%AF%E5%AF%B9%E5%BA%94%E4%B8%8D%E5%90%8C%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C"><span class="toc-number">1.6.16.</span> <span class="toc-text">2.6 后端对应不同请求的返回结果


后端的返回结果
传统方式
APIJSON



User
{    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
{    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


Moment和对应的User
分别返回两次请求的结果，获取到Moment后取出userId作为User的id条件去查询User  Moment:  {    “data”:{      “id”:235,      “content”:”xxx”,      …    },    “code”:200,    “msg”:”success”}  User:  {    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
一次性返回，没有传统方式导致的 长时间等待结果、两次结果间关联、线程多次切换 等问题  {    “Moment”:{      “id”:235,      “content”:”xxx”,      …    },    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


User列表
{    “data”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}
{    “User[]”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}


Moment列表，每个Moment包括发布者User和前3条Comment
Moment里必须有1.User对象2.Comment数组  {    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          …        },        “Comment”:[          …        ]      },      {        “id”:301,        “content”:”xxx”,        …,        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}
1.高灵活，可任意组合2.低耦合，逻辑很清晰{    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          …        },        “Comment[]”:[          …        ]      },      {        “Moment”:{          “id”:301,          “content”:”xxx”,          …        },        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}


User发布的Moment列表，每个Moment包括发布者User和前3条Comment
1.大量重复User，浪费流量和服务器性能2.优化很繁琐，需要后端扩展接口、写好文档，前端&#x2F;前端再配合优化{    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:470,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:511,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:595,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      …    ],    “code”:200,    “msg”:”success”}
以上不同请求方式的结果: ① 常规请求  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ② 省去重复的User  {    “User”:{      “id”:38710,      “name”:”Tommy”,      …    },    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ③ 不查询已获取到的User  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”}


1.base_url指基地址，一般是顶级域名，其它分支url都是在base_url后扩展。如base_url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F; ，对应的GET分支url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F;get&#x2F; 。下同。2.请求中的key或value任意一个为null值时，这个 key:value键值对 被视为无效。下同。3.请求中的 &#x2F; 需要转义。JSONRequest.java已经用URLEncoder.encode转义，不需要再写；但如果是浏览器或Postman等直接输入url&#x2F;request，需要把request中的所有 &#x2F; 都改成 %252F 。下同。4.code，指返回结果中的状态码，200表示成功，其它都是错误码，值全部都是HTTP标准状态码。下同。5.msg，指返回结果中的状态信息，对成功结果或错误原因的详细说明。下同。6.code和msg总是在返回结果的同一层级成对出现。对所有请求的返回结果都会在最外层有一对总结式code和msg。下同。7.id等字段对应的值仅供说明，不一定是数据库里存在的，请求里用的是真实存在的值。下同。



3.设计规范3.1 操作方法


方法及说明
URL
Request
Response



GET:  普通获取数据， 可用浏览器调试
base_url&#x2F;get&#x2F;
{    TableName:{      …     }}  {…}内为限制条件 例如获取一个 id &#x3D; 235 的 Moment： {    “Moment”:{      “id”:235    }}  后端校验通过后自动解析为 SQL 并执行：SELECT * FROM Moment WHERE id&#x3D;235 LIMIT 1
{    TableName:{      …    },    “code”:200,    “msg”:”success”}例如{    “Moment”:{      “id”:235,      “userId”:38710,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “code”:200,    “msg”:”success” }


HEAD:  普通获取数量， 可用浏览器调试
base_url&#x2F;head&#x2F;
{    TableName:{      …    } }  {…}内为限制条件  例如获取一个 id &#x3D; 38710 的 User 所发布的 Moment 总数： {    “Moment”:{      “userId”:38710    }}  后端校验通过后自动解析为 SQL 并执行：SELECT count(*) FROM Moment WHERE userId&#x3D;38710 LIMIT 1
{    TableName:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,    “msg”:”success”}  例如{    “Moment”:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,     “msg”:”success”}


GETS:  安全&#x2F;私密获取数据， 用于获取钱包等对安全性要求高的数据
base_url&#x2F;gets&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Privacy”，其它同GET
同GET


HEADS:  安全&#x2F;私密获取数量， 用于获取银行卡数量等对安全性要求高的数据总数
base_url&#x2F;heads&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Verify”，其它同HEAD
同HEAD


POST:  新增数据
base_url&#x2F;post&#x2F;
单个：  {    TableName:{      …    },    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 38710 发布一个新 Comment：{    “Comment”:{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”     },    “tag”:”Comment”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(38710,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;)    批量：  {    TableName[]:[{        …      }, {        …      }      …    ],    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 82001 发布 2 个 Comment：{    “Comment[]”:[{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”      }, {      “momentId”:15,      “content”:”APIJSON is a JSON transmision protocol.”    }],    “tag”:”Comment:[]”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(82001,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;);INSERT INTO Comment(userId,momentId,content) VALUES(82001,15,&#39;APIJSON is a JSON transmision protocol.&#39;);
单个：  {    TableName:{      “code”:200,      “msg”:”success”,      “id”:38710    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “id”:120    },    “code”:200,    “msg”:”success”}   批量：  {    TableName:{      “code”:200,      “msg”:”success”,      “count”:5,      “id[]”:[1, 2, 3, 4, 5]    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “count”:2,      “id[]”:[1, 2]    },    “code”:200,    “msg”:”success”}


PUT:  修改数据， 只修改所传的字段
base_url&#x2F;put&#x2F;
{    TableName:{      “id”:id,      …    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个 例如当前登录用户 82001 修改 id &#x3D; 235 的 Moment 的 content：{    “Moment”:{      “id”:235,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “tag”:”Moment”}  后端校验通过后自动解析为 SQL 并执行：UPDATE Moment SET content&#x3D;&#39;APIJSON,let interfaces and documents go to hell !&#39; WHERE id&#x3D;235 AND userId&#x3D;82001 LIMIT 1  批量除了 id{}:[] 也可类似批量 POST，只是每个 {…} 里面都必须有 id。“tag”:”Comment[]” 对应对象 “Comment”:{“id{}”:[1,2,3]}，表示指定记录全部统一设置；“tag”:”Comment:[]” 多了冒号，对应数组 “Comment[]”:[{“id”:1},{“id”:2},{“id”:3}]，表示每项单独设置
同POST


DELETE:  删除数据
base_url&#x2F;delete&#x2F;
{    TableName:{      “id”:id    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个，一般只传 id 或 id{} 例如当前登录用户 82001 批量删除 id &#x3D; 100,110,120 的 Comment：{    “Comment”:{      “id{}”:[100,110,120]    },    “tag”:”Comment[]”}  后端校验通过后自动解析为 SQL 并执行：DELETE FROM Comment WHERE id IN(100,110,120) AND userId&#x3D;82001 LIMIT 3
{    TableName:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120]      “count”:3    },    “code”:200,    “msg”:”success”}例如{   “Comment”:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120],      “count”:3   },   “code”:200,   “msg”:”success”}


以上接口的简单形式:  base_url&#x2F;{method}&#x2F;{tag}
GET: 普通获取数据  base_url&#x2F;get&#x2F;{tag}  HEAD: 普通获取数量  base_url&#x2F;head&#x2F;{tag}  GETS: 安全&#x2F;私密获取数据   base_url&#x2F;gets&#x2F;{tag}  HEADS: 安全&#x2F;私密获取数量  base_url&#x2F;heads&#x2F;{tag}  POST: 新增数据   base_url&#x2F;post&#x2F;{tag}  PUT: 修改数据  base_url&#x2F;put&#x2F;{tag}  DELETE: 删除数据  base_url&#x2F;delete&#x2F;{tag}
例如安全&#x2F;私密获取一个 id &#x3D; 82001 的 Privacy： base_url&#x2F;gets&#x2F;Privacy&#x2F;  {“id”:82001}  相当于  base_url&#x2F;gets&#x2F; {“tag”:”Privacy”, “Privacy”:{“id”:82001}}   例如批量修改 id &#x3D; 114, 124 的 Comment 的 content：base_url&#x2F;put&#x2F;Comemnt[]&#x2F;  {    “id{}”:[114,124],    “content”:”test multi put”}  相当于  base_url&#x2F;put&#x2F;  {    “tag”:”Comment[]”,     “Comment”:{      “id{}”:[114,124],      “content”:”test multi put”    }}
同以上对应的方法


1.TableName指要查询的数据库表Table的名称字符串。第一个字符为大写字母，剩下的字符要符合英语字母、数字、下划线中的任何一种。对应的值的类型为JSONObject，结构是 {…}，里面放的是Table的字段(列名)。下同。2.”tag”:tag 后面的tag是非GET、HEAD请求中匹配请求的JSON结构的标识，一般是要查询的Table的名称，由后端Request表中指定。下同。3.GET、HEAD请求是开放请求，可任意组合任意嵌套。其它请求为受限制的安全&#x2F;私密请求，对应的 方法（method）, 标识（tag）, 版本（version）, 结构（structure） 都必须和 后端Request表中所指定的 一一对应，否则请求将不被通过。version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本。下同。4.GETS与GET、HEADS与HEAD分别为同一类型的操作方法，请求稍有不同但返回结果相同。下同。5.在HTTP通信中，自动化接口(get,gets,head,heads,post,put,delete) 全用HTTP POST请求。下同。6.所有JSONObject都视为容器(或者文件夹)，结构为 {…} ，里面可以放普通对象或子容器。下同。7.每个对象都有一个唯一的路径(或者叫地址)，假设对象名为refKey，则用 key0&#x2F;key1&#x2F;…&#x2F;refKey 表示。下同。


3.2 功能符


功能
键值对格式
使用示例



查询数组
“key[]”:{}，后面是JSONObject，key可省略。当key和里面的Table名相同时，Table会被提取出来，即 {Table:{Content}} 会被转化为 {Content}
{“User[]”:{“User”:{}}}，查询一个User数组。这里key和Table名都是User，User会被提取出来，即 {“User”:{“id”, …}} 会被转化为 {“id”, …}，如果要进一步提取User中的id，可以把User[]改为User-id[]


匹配选项范围
“key{}”:[]，后面是JSONArray，作为key可取的值的选项
“id{}”:[38710,82001,70793]，对应SQL是id IN(38710,82001,70793)，查询id符合38710,82001,70793中任意一个的一个User数组


匹配条件范围
“key{}”:”条件0,条件1…”，条件为SQL表达式字符串，可进行数字比较运算等
“id{}”:”&lt;&#x3D;80000,&gt;90000”，对应SQL是id&lt;&#x3D;80000 OR id&gt;90000，查询id符合id&lt;&#x3D;80000 | id&gt;90000的一个User数组


包含选项范围
“key&lt;&gt;“:Object  &#x3D;&gt;  “key&lt;&gt;“:[Object]，key对应值的类型必须为JSONArray，Object类型不能为JSON
“contactIdList&lt;&gt;“:38710，对应SQL是json_contains(contactIdList,38710)，查询contactIdList包含38710的一个User数组


判断是否存在
“key}{@”:{    “from”:”Table”,    “Table”:{ … }}其中：}{ 表示 EXISTS； key 用来标识是哪个判断； @ 后面是 子查询 对象，具体见下方 子查询 的说明。
“id}{@”:{    “from”:”Comment”,    “Comment”:{        “momentId”:15     }} WHERE EXISTS(SELECT * FROM Comment WHERE momentId&#x3D;15)


远程调用函数
“key()”:”函数表达式”，函数表达式为 function(key0,key1…)，会调用后端对应的函数 function(JSONObject request, String key0, String key1…)，实现 参数校验、数值计算、数据同步、消息推送、字段拼接、结构变换 等特定的业务逻辑处理，可使用 - 和 + 表示优先级，解析 key-() &gt; 解析当前对象 &gt; 解析 key() &gt; 解析子对象 &gt; 解析 key+()
“isPraised()”:”isContain(praiseUserIdList,userId)”，会调用远程函数 boolean isContain(JSONObject request, String array, String value) ，然后变为 “isPraised”:true 这种（假设点赞用户id列表包含了userId，即这个User点了赞）


存储过程
“@key()”:”SQL函数表达式”，函数表达式为   function(key0,key1…)  会调用后端数据库对应的存储过程 SQL函数  function(String key0, String key1…)  除了参数会提前赋值，其它和 远程函数 一致
“@limit”:10,  “@offset”:0,  “@procedure()”:”getCommentByUserId(id,@limit,@offset)”  会转为  getCommentByUserId(38710,10,0)  来调用存储过程 SQL 函数  getCommentByUserId(IN id bigint, IN limit int, IN offset int)  然后变为 “procedure”:{    “count”:-1,     “update”:false,     “list”:[]  }  其中 count 是指写操作影响记录行数，-1 表示不是写操作；update 是指是否为写操作（增删改）；list 为返回结果集


引用赋值
“key@”:”key0&#x2F;key1&#x2F;…&#x2F;refKey”，引用路径为用&#x2F;分隔的字符串。以&#x2F;开头的是缺省引用路径，从声明key所处容器的父容器路径开始；其它是完整引用路径，从最外层开始。 被引用的refKey必须在声明key的上面。如果对refKey的容器指定了返回字段，则被引用的refKey必须写在@column对应的值内，例如 “@column”:”refKey,key1,…”
“Moment”:{    “userId”:38710},“User”:{    “id@”:”&#x2F;Moment&#x2F;userId”} User内的id引用了与User同级的Moment内的userId，即User.id &#x3D; Moment.userId，请求完成后 “id@”:”&#x2F;Moment&#x2F;userId” 会变成 “id”:38710


子查询
“key@”:{    “range”:”ALL”,     “from”:”Table”,    “Table”:{ … }}其中：range 可为 ALL,ANY；from 为目标表 Table 的名称；@ 后面的对象类似数组对象，可使用 count 和 join 等功能。
“id@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&#x3D;(SELECT min(userId) FROM Comment)


模糊搜索
&quot;key$&quot;:&quot;SQL搜索表达式&quot;  &#x3D;&gt;  &quot;key$&quot;:[&quot;SQL搜索表达式&quot;]，任意SQL搜索表达式字符串，如 %key%(包含key), key%(以key开始), %k%e%y%(包含字母k,e,y) 等，%表示任意字符
“name$”:”%m%”，对应SQL是name LIKE &#39;%m%&#39;，查询name包含”m”的一个User数组


正则匹配
“key“:”正则表达式”  &#x3D;&gt;  “key“:[“正则表达式”]，任意正则表达式字符串，如 ^[0-9]+$ ，*~ 忽略大小写，可用于高级搜索
“name~”:”^[0-9]+$”，对应SQL是name REGEXP &#39;^[0-9]+$&#39;，查询name中字符全为数字的一个User数组


连续范围
“key%”:”start,end”  &#x3D;&gt;  “key%”:[“start,end”]，其中 start 和 end 都只能为 Boolean, Number, String 中的一种，如 “2017-01-01,2019-01-01” ，[“1,90000”, “82001,100000”] ，可用于连续范围内的筛选
“date%”:”2017-10-01,2018-10-01”，对应SQL是date BETWEEN &#39;2017-10-01&#39; AND &#39;2018-10-01&#39;，查询在2017-10-01和2018-10-01期间注册的用户的一个User数组


新建别名
“name:alias”，name映射为alias，用alias替代name。可用于 column,Table,SQL函数 等。只用于GET类型、HEAD类型的请求
“@column”:”toId:parentId”，对应SQL是toId AS parentId，将查询的字段toId变为parentId返回


增加 或 扩展
“key+”:Object，Object的类型由key指定，且类型为Number,String,JSONArray中的一种。如 82001,”apijson”,[“url0”,”url1”] 等。只用于PUT请求
“praiseUserIdList+”:[82001]，对应SQL是json_insert(praiseUserIdList,82001)，添加一个点赞用户id，即这个用户点了赞


减少 或 去除
“key-“:Object，与”key+”相反
“balance-“:100.00，对应SQL是balance &#x3D; balance - 100.00，余额减少100.00，即花费了100元


比较运算
&gt;, &lt;, &gt;&#x3D;, &lt;&#x3D; 比较运算符，用于 ① 提供 “id{}”:”&lt;&#x3D;90000” 这种条件范围的简化写法 ② 实现子查询相关比较运算不支持 “key&#x3D;”:Object 和 “key!&#x3D;”:Object 这两种写法，直接用更简单的 “key”:Object 和 “key!”:Object 替代。
① “id&lt;&#x3D;”:90000，对应SQL是id&lt;&#x3D;90000，查询符合id&lt;&#x3D;90000的一个User数组 ② “id&gt;@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&gt;(SELECT min(userId) FROM Comment)


逻辑运算
&amp;, |, ! 逻辑运算符，对应数据库 SQL 中的 AND, OR, NOT。 横或纵与：同一键值对的值内条件默认 | 或连接，可以在 key 后加逻辑运算符来具体指定；不同键值对的条件默认 &amp; 与连接，可以用下面说明的对象关键词 @combine 来具体指定。 ① &amp; 可用于”key&amp;{}”:”条件”等② | 可用于”key|{}”:”条件”, “key|{}”:[]等，一般可省略③ ! 可单独使用，如”key!”:Object，也可像&amp;,|一样配合其他功能符使用  “key!”:null 无效，null 值会导致整个键值对被忽略解析，可以用 “key{}”:”!&#x3D;null” 替代，“key”:null 同理，用 “key{}”:”&#x3D;null” 替代。
① “id&amp;{}”:”&gt;80000,&lt;&#x3D;90000”，对应SQL是id&gt;80000 AND id&lt;&#x3D;90000，即id满足id&gt;80000 &amp; id&lt;&#x3D;90000 ② “id|{}”:”&gt;90000,&lt;&#x3D;80000”，同”id{}”:”&gt;90000,&lt;&#x3D;80000”，对应SQL是id&gt;80000 OR id&lt;&#x3D;90000，即id满足id&gt;90000 | id&lt;&#x3D;80000 ③ “id!{}”:[82001,38710]，对应SQL是id NOT IN(82001,38710)，即id满足 ! (id&#x3D;82001 | id&#x3D;38710)，可过滤黑名单的消息


数组关键词，可自定义
“key”:Object，key为 “[]”:{} 中{}内的关键词，Object的类型由key指定① “count”:Integer，查询数量，0 表示最大值，默认最大值为100 ② “page”:Integer，查询页码，从0开始，默认最大值为100，一般和count一起用③ “query”:Integer，查询内容0-对象，1-总数和分页详情，2-数据、总数和分页详情总数关键词为 total，分页详情关键词为 info， 它们都和 query 同级，通过引用赋值得到，例如  “total@”:”&#x2F;[]&#x2F;total”, “info@”:”&#x2F;[]&#x2F;info” 这里query及total仅为GET类型的请求提供方便， 一般可直接用HEAD类型的请求获取总数④ “join”:”&amp;&#x2F;Table0,&lt;&#x2F;Table1&#x2F;key1@” 或 “join”:{    “&amp;&#x2F;Table0”:{},  &#x2F;&#x2F; 支持 ON 多个字段关联,    “&lt;&#x2F;Table1&#x2F;key1@”:{  &#x2F;&#x2F; ON 只允许指定的 key1 关联      “key0”:value0,  &#x2F;&#x2F; 其它ON条件       “key2”:value2,      …       “@combine”:”…”,  &#x2F;&#x2F; 其它ON条件的组合方式       “@column”:”…”,  &#x2F;&#x2F; 外层 SELECT       “@group”:”…”,  &#x2F;&#x2F; 外层 GROUP BY       “@having”:”…”  &#x2F;&#x2F; 外层 HAVING     }}多表连接方式：  “@” - APP JOIN  “&lt;“ - LEFT JOIN  “&gt;” - RIGHT JOIN  “&amp;” - INNER JOIN  “|” - FULL JOIN   “!” - OUTER JOIN   “*” - CROSS JOIN   “^” - SIDE JOIN   “(“ - ANTI JOIN   “)” - FOREIGN JOIN 其中 @ APP JOIN 为应用层连表，会从已查出的主表里取得所有副表 key@ 关联的主表内的 refKey 作为一个数组 refKeys: [value0, value1…]，然后把原来副表 count 次查询 key&#x3D;$refKey 的 SQL 用 key IN($refKeys) 的方式合并为一条 SQL 来优化性能； 其它 JOIN 都是 SQL JOIN，具体功能和 MySQL,PostgreSQL 等数据库的 JOIN 一一对应 &quot;join&quot;:&quot;&lt;&#x2F;ViceTable&#x2F;key@&quot;,&quot;MainTable&quot;:{},&quot;ViceTable&quot;:{&quot;key@&quot;:&quot;&#x2F;MainTable&#x2F;refKey&quot;}会对应生成 MainTable LEFT JOIN ViceTable ON ViceTable.key&#x3D;MainTable.refKey AND 其它ON条件  除了 &#x3D; 等价关联，也支持 ! 不等关联、&gt; &lt; &gt;&#x3D; &lt;&#x3D; 等比较关联和 $ ~ {} &lt;&gt; 等其它复杂关联方式 ⑤ “otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 查询User数组，最多5个：“count”:5对应SQL是LIMIT 5  ② 查询第3页的User数组，每页5个：“count”:5,“page”:3对应SQL是LIMIT 5 OFFSET 15  ③ 查询User数组和对应的User总数：“[]”:{    “query”:2,    “User”:{}},“total@”:”&#x2F;[]&#x2F;total”,“info@”:”&#x2F;[]&#x2F;info” 返回的数据中，总数及分页详情结构为：   “total”:139,  &#x2F;&#x2F;总数  “info”:{  &#x2F;&#x2F;分页详情     “total”:139,  &#x2F;&#x2F;总数     “count”:5,  &#x2F;&#x2F;每页数量     “page”:0,  &#x2F;&#x2F;当前页码     “max”:27,  &#x2F;&#x2F;最大页码     “more”:true,  &#x2F;&#x2F;是否还有更多     “first”:true,  &#x2F;&#x2F;是否为首页     “last”:false  &#x2F;&#x2F;是否为尾页 }  ④ Moment INNER JOIN User LEFT JOIN Comment：“[]”:{    “join”:”&amp;&#x2F;User&#x2F;id@,&lt;&#x2F;Comment”,    “Moment”:{     “@group”:”id”  &#x2F;&#x2F;主副表不是一对一，要去除重复数据   },    “User”:{      “name~”:”t”,      “id@”:”&#x2F;Moment&#x2F;userId”    },    “Comment”:{      “momentId@”:”&#x2F;Moment&#x2F;id”    }} ⑤ 每一层都加当前用户名：“User”:{},“[]”:{    “name@”:”User&#x2F;name”, &#x2F;&#x2F;自定义关键词    “Moment”:{}}


对象关键词，可自定义
“@key”:Object，@key为 Table:{} 中{}内的关键词，Object的类型由@key指定① “@combine”:”key0 | (key1 &amp; (key2 | !key3))…”，条件组合方式，最终按  (其它key条件 AND 连接) AND (key0条件 OR (key1条件 AND (key2条件 OR (NOT key3条件)))) 这种方式连接，其中 “其它key” 是指与 @combine 在同一对象，且未被它声明的条件 key，默认都是 &amp; 连接。注意不要缺少或多余任何一个空格。 ② “@column”:”column;function(arg)…”，返回字段③ “@order”:”column0+,column1-…”，排序方式④ “@group”:”column0,column1…”，分组方式。如果@column里声明了Table的id，则id也必须在@group中声明；其它情况下必须满足至少一个条件:1.分组的key在@column里声明2.Table主键在@group中声明 ⑤ “@having”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…” &#x2F;&#x2F; OR 连接，或 “@having&amp;”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…”  &#x2F;&#x2F; AND 连接，或 “@having”:{   “h0”:”function0(…)?value0”,   “h1”:function1(…)?value1”,   “h2”:function2(…)?value2…”,   “@combine”:”h0 &amp; (h1 | !h2)”  &#x2F;&#x2F; 任意组合，非必传}SQL函数条件，一般和@group一起用，函数一般在@column里声明⑥ “@schema”:”sys”，集合空间(数据库名&#x2F;模式)，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑦ “@database”:”POSTGRESQL”，数据库类型，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑧ “@datasource”:”DRUID”，跨数据源，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑨ “@json”:”key0,key1…”，转为 JSON 格式返回，符合 JSONObject 则转为 {…}，符合 JSONArray 则转为 […] ⑩ “@role”:”OWNER”，来访角色，包括UNKNOWN,LOGIN,CONTACT,CIRCLE,OWNER,ADMIN，可以在最外层作为全局默认配置，可自定义其它角色并重写 Verifier.verify 等相关方法来自定义校验 ⑪ “@explain”:true，性能分析，可以在最外层作为全局默认配置 ⑫ “@raw”:”key0,key1…”，其中 key0, key1 都对应有键值对 “key0”:”SQL片段或SQL片段的别名”,  “key1”:”SQL片段或SQL片段的别名”  自定义原始SQL片段，可扩展嵌套SQL函数等复杂语句，必须是后端已配置的，只有其它功能符都做不到才考虑，谨慎使用，注意防SQL注入⑬ “@otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 搜索name或tag任何一个字段包含字符a的User列表： “name“:”a”,“tag“:”a”,“@combine”:”name~ | tag~” 对应SQL是name REGEXP &#39;a&#39; OR tag REGEXP &#39;a&#39;  ② 只查询id,sex,name这几列并且请求结果也按照这个顺序：“@column”:”id,sex,name”对应SQL是SELECT id,sex,name  ③ 查询按 name降序、id默认顺序 排序的User数组：“@order”:”name-,id”对应SQL是ORDER BY name DESC,id  ④ 查询按userId分组的Moment数组：“@group”:”userId,id”对应SQL是GROUP BY userId,id  ⑤ 查询 按userId分组、id最大值&gt;&#x3D;100 的Moment数组：“@column”:”userId;max(id)”,“@group”:”userId”,“@having”:”max(id)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) ... GROUP BY userId HAVING max(id)&gt;&#x3D;100 还可以指定函数返回名：“@column”:”userId;max(id):maxId”,“@group”:”userId”,“@having”:”(maxId)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) AS maxId ... GROUP BY userId HAVING (maxId)&gt;&#x3D;100  ⑥ 查询 sys 内的 User 表：“@schema”:”sys”对应SQL是FROM sys.User  ⑦ 查询 PostgreSQL 数据库的 User 表：“@database”:”POSTGRESQL” ⑧ 使用 Druid 连接池查询 User 表：“@datasource”:”DRUID” ⑨ 将 VARCHAR 字符串字段 get 转为 JSONArray 返回：“@json”:”get” ⑩ 查询当前用户的动态：“@role”:”OWNER” ⑪ 开启性能分析：“@explain”:true对应SQL是EXPLAIN  ⑫ 统计最近一周偶数userId的数量“@column”:”date;left(date,10):day;sum(if(userId%2&#x3D;0,1,0))”,“@group”:”day”,“@having”:”to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7”,“@raw”:”@column,@having”对应SQL是SELECT date, left(date,10) AS day, sum(if(userId%2&#x3D;0,1,0)) ... GROUP BY day HAVING to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7  ⑬ 从pictureList获取第0张图片：“@position”:0, &#x2F;&#x2F;自定义关键词“firstPicture()”:”getFromArray(pictureList,@position)”


全局关键词
为最外层对象 {} 内的关键词。其中 @database，@schema, @datasource, @role, @explain 基本同对象关键词，见上方说明，区别是全局关键词会每个表对象中没有时自动放入，作为默认值。 ① “tag”:String，后面的 tag 是非 GET、HEAD 请求中匹配请求的 JSON 结构的标识，一般是要查询的 Table 的名称或该名称对应的数组 Table[] 或 Table:[]，由后端 Request 表中指定。 ② “version”:Integer，接口版本，version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本，由后端 Request 表中指定。③ “format”:Boolean，格式化返回 Response JSON 的 key，一般是将 TableName 转为 tableName, TableName[] 转为 tableNameList, Table:alias 转为 alias, TableName-key[] 转为 tableNameKeyList 等小驼峰格式。
①  查隐私信息：[{“tag”:”Privacy”,”Privacy”:{“id”:82001}}](http:&#x2F;&#x2F;apijson.cn&#x2F;api?url&#x3D;http%3A%2F%2Fapijson.cn%3A8080%2Fgets&amp;type&#x3D;JSON&amp;json&#x3D;


</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2.6"><span class="toc-number">1.6.17.</span> <span class="toc-text">2.6 后端对应不同请求的返回结果


后端的返回结果
传统方式
APIJSON



User
{    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
{    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


Moment和对应的User
分别返回两次请求的结果，获取到Moment后取出userId作为User的id条件去查询User  Moment:  {    “data”:{      “id”:235,      “content”:”xxx”,      …    },    “code”:200,    “msg”:”success”}  User:  {    “data”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}
一次性返回，没有传统方式导致的 长时间等待结果、两次结果间关联、线程多次切换 等问题  {    “Moment”:{      “id”:235,      “content”:”xxx”,      …    },    “User”:{      “id”:38710,      “name”:”xxx”,      …    },    “code”:200,    “msg”:”success”}


User列表
{    “data”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}
{    “User[]”:[      {        “id”:38710,        “name”:”xxx”,        …      },      {        “id”:82001,        …      },      …    ],    “code”:200,    “msg”:”success”}


Moment列表，每个Moment包括发布者User和前3条Comment
Moment里必须有1.User对象2.Comment数组  {    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          …        },        “Comment”:[          …        ]      },      {        “id”:301,        “content”:”xxx”,        …,        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}
1.高灵活，可任意组合2.低耦合，逻辑很清晰{    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          …        },        “Comment[]”:[          …        ]      },      {        “Moment”:{          “id”:301,          “content”:”xxx”,          …        },        “User”:{          …        },        …      },      …    ],    “code”:200,    “msg”:”success”}


User发布的Moment列表，每个Moment包括发布者User和前3条Comment
1.大量重复User，浪费流量和服务器性能2.优化很繁琐，需要后端扩展接口、写好文档，前端&#x2F;前端再配合优化{    “data”:[      {        “id”:235,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:470,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:511,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      {        “id”:595,        “content”:”xxx”,        …,        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment”:[          …        ]        …      },      …    ],    “code”:200,    “msg”:”success”}
以上不同请求方式的结果: ① 常规请求  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “User”:{          “id”:38710,          “name”:”Tommy”          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ② 省去重复的User  {    “User”:{      “id”:38710,      “name”:”Tommy”,      …    },    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”} ③ 不查询已获取到的User  {    “[]”:[      {        “Moment”:{          “id”:235,          “content”:”xxx”,          …        },        “Comment[]”:[          …        ]      },      …    ],    “code”:200,    “msg”:”success”}


1.base_url指基地址，一般是顶级域名，其它分支url都是在base_url后扩展。如base_url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F; ，对应的GET分支url:http:&#x2F;&#x2F;apijson.cn:8080&#x2F;get&#x2F; 。下同。2.请求中的key或value任意一个为null值时，这个 key:value键值对 被视为无效。下同。3.请求中的 &#x2F; 需要转义。JSONRequest.java已经用URLEncoder.encode转义，不需要再写；但如果是浏览器或Postman等直接输入url&#x2F;request，需要把request中的所有 &#x2F; 都改成 %252F 。下同。4.code，指返回结果中的状态码，200表示成功，其它都是错误码，值全部都是HTTP标准状态码。下同。5.msg，指返回结果中的状态信息，对成功结果或错误原因的详细说明。下同。6.code和msg总是在返回结果的同一层级成对出现。对所有请求的返回结果都会在最外层有一对总结式code和msg。下同。7.id等字段对应的值仅供说明，不一定是数据库里存在的，请求里用的是真实存在的值。下同。



3.设计规范3.1 操作方法


方法及说明
URL
Request
Response



GET:  普通获取数据， 可用浏览器调试
base_url&#x2F;get&#x2F;
{    TableName:{      …     }}  {…}内为限制条件 例如获取一个 id &#x3D; 235 的 Moment： {    “Moment”:{      “id”:235    }}  后端校验通过后自动解析为 SQL 并执行：SELECT * FROM Moment WHERE id&#x3D;235 LIMIT 1
{    TableName:{      …    },    “code”:200,    “msg”:”success”}例如{    “Moment”:{      “id”:235,      “userId”:38710,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “code”:200,    “msg”:”success” }


HEAD:  普通获取数量， 可用浏览器调试
base_url&#x2F;head&#x2F;
{    TableName:{      …    } }  {…}内为限制条件  例如获取一个 id &#x3D; 38710 的 User 所发布的 Moment 总数： {    “Moment”:{      “userId”:38710    }}  后端校验通过后自动解析为 SQL 并执行：SELECT count(*) FROM Moment WHERE userId&#x3D;38710 LIMIT 1
{    TableName:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,    “msg”:”success”}  例如{    “Moment”:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,     “msg”:”success”}


GETS:  安全&#x2F;私密获取数据， 用于获取钱包等对安全性要求高的数据
base_url&#x2F;gets&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Privacy”，其它同GET
同GET


HEADS:  安全&#x2F;私密获取数量， 用于获取银行卡数量等对安全性要求高的数据总数
base_url&#x2F;heads&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Verify”，其它同HEAD
同HEAD


POST:  新增数据
base_url&#x2F;post&#x2F;
单个：  {    TableName:{      …    },    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 38710 发布一个新 Comment：{    “Comment”:{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”     },    “tag”:”Comment”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(38710,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;)    批量：  {    TableName[]:[{        …      }, {        …      }      …    ],    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 82001 发布 2 个 Comment：{    “Comment[]”:[{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”      }, {      “momentId”:15,      “content”:”APIJSON is a JSON transmision protocol.”    }],    “tag”:”Comment:[]”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(82001,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;);INSERT INTO Comment(userId,momentId,content) VALUES(82001,15,&#39;APIJSON is a JSON transmision protocol.&#39;);
单个：  {    TableName:{      “code”:200,      “msg”:”success”,      “id”:38710    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “id”:120    },    “code”:200,    “msg”:”success”}   批量：  {    TableName:{      “code”:200,      “msg”:”success”,      “count”:5,      “id[]”:[1, 2, 3, 4, 5]    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “count”:2,      “id[]”:[1, 2]    },    “code”:200,    “msg”:”success”}


PUT:  修改数据， 只修改所传的字段
base_url&#x2F;put&#x2F;
{    TableName:{      “id”:id,      …    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个 例如当前登录用户 82001 修改 id &#x3D; 235 的 Moment 的 content：{    “Moment”:{      “id”:235,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “tag”:”Moment”}  后端校验通过后自动解析为 SQL 并执行：UPDATE Moment SET content&#x3D;&#39;APIJSON,let interfaces and documents go to hell !&#39; WHERE id&#x3D;235 AND userId&#x3D;82001 LIMIT 1  批量除了 id{}:[] 也可类似批量 POST，只是每个 {…} 里面都必须有 id。“tag”:”Comment[]” 对应对象 “Comment”:{“id{}”:[1,2,3]}，表示指定记录全部统一设置；“tag”:”Comment:[]” 多了冒号，对应数组 “Comment[]”:[{“id”:1},{“id”:2},{“id”:3}]，表示每项单独设置
同POST


DELETE:  删除数据
base_url&#x2F;delete&#x2F;
{    TableName:{      “id”:id    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个，一般只传 id 或 id{} 例如当前登录用户 82001 批量删除 id &#x3D; 100,110,120 的 Comment：{    “Comment”:{      “id{}”:[100,110,120]    },    “tag”:”Comment[]”}  后端校验通过后自动解析为 SQL 并执行：DELETE FROM Comment WHERE id IN(100,110,120) AND userId&#x3D;82001 LIMIT 3
{    TableName:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120]      “count”:3    },    “code”:200,    “msg”:”success”}例如{   “Comment”:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120],      “count”:3   },   “code”:200,   “msg”:”success”}


以上接口的简单形式:  base_url&#x2F;{method}&#x2F;{tag}
GET: 普通获取数据  base_url&#x2F;get&#x2F;{tag}  HEAD: 普通获取数量  base_url&#x2F;head&#x2F;{tag}  GETS: 安全&#x2F;私密获取数据   base_url&#x2F;gets&#x2F;{tag}  HEADS: 安全&#x2F;私密获取数量  base_url&#x2F;heads&#x2F;{tag}  POST: 新增数据   base_url&#x2F;post&#x2F;{tag}  PUT: 修改数据  base_url&#x2F;put&#x2F;{tag}  DELETE: 删除数据  base_url&#x2F;delete&#x2F;{tag}
例如安全&#x2F;私密获取一个 id &#x3D; 82001 的 Privacy： base_url&#x2F;gets&#x2F;Privacy&#x2F;  {“id”:82001}  相当于  base_url&#x2F;gets&#x2F; {“tag”:”Privacy”, “Privacy”:{“id”:82001}}   例如批量修改 id &#x3D; 114, 124 的 Comment 的 content：base_url&#x2F;put&#x2F;Comemnt[]&#x2F;  {    “id{}”:[114,124],    “content”:”test multi put”}  相当于  base_url&#x2F;put&#x2F;  {    “tag”:”Comment[]”,     “Comment”:{      “id{}”:[114,124],      “content”:”test multi put”    }}
同以上对应的方法


1.TableName指要查询的数据库表Table的名称字符串。第一个字符为大写字母，剩下的字符要符合英语字母、数字、下划线中的任何一种。对应的值的类型为JSONObject，结构是 {…}，里面放的是Table的字段(列名)。下同。2.”tag”:tag 后面的tag是非GET、HEAD请求中匹配请求的JSON结构的标识，一般是要查询的Table的名称，由后端Request表中指定。下同。3.GET、HEAD请求是开放请求，可任意组合任意嵌套。其它请求为受限制的安全&#x2F;私密请求，对应的 方法（method）, 标识（tag）, 版本（version）, 结构（structure） 都必须和 后端Request表中所指定的 一一对应，否则请求将不被通过。version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本。下同。4.GETS与GET、HEADS与HEAD分别为同一类型的操作方法，请求稍有不同但返回结果相同。下同。5.在HTTP通信中，自动化接口(get,gets,head,heads,post,put,delete) 全用HTTP POST请求。下同。6.所有JSONObject都视为容器(或者文件夹)，结构为 {…} ，里面可以放普通对象或子容器。下同。7.每个对象都有一个唯一的路径(或者叫地址)，假设对象名为refKey，则用 key0&#x2F;key1&#x2F;…&#x2F;refKey 表示。下同。


3.2 功能符


功能
键值对格式
使用示例



查询数组
“key[]”:{}，后面是JSONObject，key可省略。当key和里面的Table名相同时，Table会被提取出来，即 {Table:{Content}} 会被转化为 {Content}
{“User[]”:{“User”:{}}}，查询一个User数组。这里key和Table名都是User，User会被提取出来，即 {“User”:{“id”, …}} 会被转化为 {“id”, …}，如果要进一步提取User中的id，可以把User[]改为User-id[]


匹配选项范围
“key{}”:[]，后面是JSONArray，作为key可取的值的选项
“id{}”:[38710,82001,70793]，对应SQL是id IN(38710,82001,70793)，查询id符合38710,82001,70793中任意一个的一个User数组


匹配条件范围
“key{}”:”条件0,条件1…”，条件为SQL表达式字符串，可进行数字比较运算等
“id{}”:”&lt;&#x3D;80000,&gt;90000”，对应SQL是id&lt;&#x3D;80000 OR id&gt;90000，查询id符合id&lt;&#x3D;80000 | id&gt;90000的一个User数组


包含选项范围
“key&lt;&gt;“:Object  &#x3D;&gt;  “key&lt;&gt;“:[Object]，key对应值的类型必须为JSONArray，Object类型不能为JSON
“contactIdList&lt;&gt;“:38710，对应SQL是json_contains(contactIdList,38710)，查询contactIdList包含38710的一个User数组


判断是否存在
“key}{@”:{    “from”:”Table”,    “Table”:{ … }}其中：}{ 表示 EXISTS； key 用来标识是哪个判断； @ 后面是 子查询 对象，具体见下方 子查询 的说明。
“id}{@”:{    “from”:”Comment”,    “Comment”:{        “momentId”:15     }} WHERE EXISTS(SELECT * FROM Comment WHERE momentId&#x3D;15)


远程调用函数
“key()”:”函数表达式”，函数表达式为 function(key0,key1…)，会调用后端对应的函数 function(JSONObject request, String key0, String key1…)，实现 参数校验、数值计算、数据同步、消息推送、字段拼接、结构变换 等特定的业务逻辑处理，可使用 - 和 + 表示优先级，解析 key-() &gt; 解析当前对象 &gt; 解析 key() &gt; 解析子对象 &gt; 解析 key+()
“isPraised()”:”isContain(praiseUserIdList,userId)”，会调用远程函数 boolean isContain(JSONObject request, String array, String value) ，然后变为 “isPraised”:true 这种（假设点赞用户id列表包含了userId，即这个User点了赞）


存储过程
“@key()”:”SQL函数表达式”，函数表达式为   function(key0,key1…)  会调用后端数据库对应的存储过程 SQL函数  function(String key0, String key1…)  除了参数会提前赋值，其它和 远程函数 一致
“@limit”:10,  “@offset”:0,  “@procedure()”:”getCommentByUserId(id,@limit,@offset)”  会转为  getCommentByUserId(38710,10,0)  来调用存储过程 SQL 函数  getCommentByUserId(IN id bigint, IN limit int, IN offset int)  然后变为 “procedure”:{    “count”:-1,     “update”:false,     “list”:[]  }  其中 count 是指写操作影响记录行数，-1 表示不是写操作；update 是指是否为写操作（增删改）；list 为返回结果集


引用赋值
“key@”:”key0&#x2F;key1&#x2F;…&#x2F;refKey”，引用路径为用&#x2F;分隔的字符串。以&#x2F;开头的是缺省引用路径，从声明key所处容器的父容器路径开始；其它是完整引用路径，从最外层开始。 被引用的refKey必须在声明key的上面。如果对refKey的容器指定了返回字段，则被引用的refKey必须写在@column对应的值内，例如 “@column”:”refKey,key1,…”
“Moment”:{    “userId”:38710},“User”:{    “id@”:”&#x2F;Moment&#x2F;userId”} User内的id引用了与User同级的Moment内的userId，即User.id &#x3D; Moment.userId，请求完成后 “id@”:”&#x2F;Moment&#x2F;userId” 会变成 “id”:38710


子查询
“key@”:{    “range”:”ALL”,     “from”:”Table”,    “Table”:{ … }}其中：range 可为 ALL,ANY；from 为目标表 Table 的名称；@ 后面的对象类似数组对象，可使用 count 和 join 等功能。
“id@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&#x3D;(SELECT min(userId) FROM Comment)


模糊搜索
&quot;key$&quot;:&quot;SQL搜索表达式&quot;  &#x3D;&gt;  &quot;key$&quot;:[&quot;SQL搜索表达式&quot;]，任意SQL搜索表达式字符串，如 %key%(包含key), key%(以key开始), %k%e%y%(包含字母k,e,y) 等，%表示任意字符
“name$”:”%m%”，对应SQL是name LIKE &#39;%m%&#39;，查询name包含”m”的一个User数组


正则匹配
“key“:”正则表达式”  &#x3D;&gt;  “key“:[“正则表达式”]，任意正则表达式字符串，如 ^[0-9]+$ ，*~ 忽略大小写，可用于高级搜索
“name~”:”^[0-9]+$”，对应SQL是name REGEXP &#39;^[0-9]+$&#39;，查询name中字符全为数字的一个User数组


连续范围
“key%”:”start,end”  &#x3D;&gt;  “key%”:[“start,end”]，其中 start 和 end 都只能为 Boolean, Number, String 中的一种，如 “2017-01-01,2019-01-01” ，[“1,90000”, “82001,100000”] ，可用于连续范围内的筛选
“date%”:”2017-10-01,2018-10-01”，对应SQL是date BETWEEN &#39;2017-10-01&#39; AND &#39;2018-10-01&#39;，查询在2017-10-01和2018-10-01期间注册的用户的一个User数组


新建别名
“name:alias”，name映射为alias，用alias替代name。可用于 column,Table,SQL函数 等。只用于GET类型、HEAD类型的请求
“@column”:”toId:parentId”，对应SQL是toId AS parentId，将查询的字段toId变为parentId返回


增加 或 扩展
“key+”:Object，Object的类型由key指定，且类型为Number,String,JSONArray中的一种。如 82001,”apijson”,[“url0”,”url1”] 等。只用于PUT请求
“praiseUserIdList+”:[82001]，对应SQL是json_insert(praiseUserIdList,82001)，添加一个点赞用户id，即这个用户点了赞


减少 或 去除
“key-“:Object，与”key+”相反
“balance-“:100.00，对应SQL是balance &#x3D; balance - 100.00，余额减少100.00，即花费了100元


比较运算
&gt;, &lt;, &gt;&#x3D;, &lt;&#x3D; 比较运算符，用于 ① 提供 “id{}”:”&lt;&#x3D;90000” 这种条件范围的简化写法 ② 实现子查询相关比较运算不支持 “key&#x3D;”:Object 和 “key!&#x3D;”:Object 这两种写法，直接用更简单的 “key”:Object 和 “key!”:Object 替代。
① “id&lt;&#x3D;”:90000，对应SQL是id&lt;&#x3D;90000，查询符合id&lt;&#x3D;90000的一个User数组 ② “id&gt;@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&gt;(SELECT min(userId) FROM Comment)


逻辑运算
&amp;, |, ! 逻辑运算符，对应数据库 SQL 中的 AND, OR, NOT。 横或纵与：同一键值对的值内条件默认 | 或连接，可以在 key 后加逻辑运算符来具体指定；不同键值对的条件默认 &amp; 与连接，可以用下面说明的对象关键词 @combine 来具体指定。 ① &amp; 可用于”key&amp;{}”:”条件”等② | 可用于”key|{}”:”条件”, “key|{}”:[]等，一般可省略③ ! 可单独使用，如”key!”:Object，也可像&amp;,|一样配合其他功能符使用  “key!”:null 无效，null 值会导致整个键值对被忽略解析，可以用 “key{}”:”!&#x3D;null” 替代，“key”:null 同理，用 “key{}”:”&#x3D;null” 替代。
① “id&amp;{}”:”&gt;80000,&lt;&#x3D;90000”，对应SQL是id&gt;80000 AND id&lt;&#x3D;90000，即id满足id&gt;80000 &amp; id&lt;&#x3D;90000 ② “id|{}”:”&gt;90000,&lt;&#x3D;80000”，同”id{}”:”&gt;90000,&lt;&#x3D;80000”，对应SQL是id&gt;80000 OR id&lt;&#x3D;90000，即id满足id&gt;90000 | id&lt;&#x3D;80000 ③ “id!{}”:[82001,38710]，对应SQL是id NOT IN(82001,38710)，即id满足 ! (id&#x3D;82001 | id&#x3D;38710)，可过滤黑名单的消息


数组关键词，可自定义
“key”:Object，key为 “[]”:{} 中{}内的关键词，Object的类型由key指定① “count”:Integer，查询数量，0 表示最大值，默认最大值为100 ② “page”:Integer，查询页码，从0开始，默认最大值为100，一般和count一起用③ “query”:Integer，查询内容0-对象，1-总数和分页详情，2-数据、总数和分页详情总数关键词为 total，分页详情关键词为 info， 它们都和 query 同级，通过引用赋值得到，例如  “total@”:”&#x2F;[]&#x2F;total”, “info@”:”&#x2F;[]&#x2F;info” 这里query及total仅为GET类型的请求提供方便， 一般可直接用HEAD类型的请求获取总数④ “join”:”&amp;&#x2F;Table0,&lt;&#x2F;Table1&#x2F;key1@” 或 “join”:{    “&amp;&#x2F;Table0”:{},  &#x2F;&#x2F; 支持 ON 多个字段关联,    “&lt;&#x2F;Table1&#x2F;key1@”:{  &#x2F;&#x2F; ON 只允许指定的 key1 关联      “key0”:value0,  &#x2F;&#x2F; 其它ON条件       “key2”:value2,      …       “@combine”:”…”,  &#x2F;&#x2F; 其它ON条件的组合方式       “@column”:”…”,  &#x2F;&#x2F; 外层 SELECT       “@group”:”…”,  &#x2F;&#x2F; 外层 GROUP BY       “@having”:”…”  &#x2F;&#x2F; 外层 HAVING     }}多表连接方式：  “@” - APP JOIN  “&lt;“ - LEFT JOIN  “&gt;” - RIGHT JOIN  “&amp;” - INNER JOIN  “|” - FULL JOIN   “!” - OUTER JOIN   “*” - CROSS JOIN   “^” - SIDE JOIN   “(“ - ANTI JOIN   “)” - FOREIGN JOIN 其中 @ APP JOIN 为应用层连表，会从已查出的主表里取得所有副表 key@ 关联的主表内的 refKey 作为一个数组 refKeys: [value0, value1…]，然后把原来副表 count 次查询 key&#x3D;$refKey 的 SQL 用 key IN($refKeys) 的方式合并为一条 SQL 来优化性能； 其它 JOIN 都是 SQL JOIN，具体功能和 MySQL,PostgreSQL 等数据库的 JOIN 一一对应 &quot;join&quot;:&quot;&lt;&#x2F;ViceTable&#x2F;key@&quot;,&quot;MainTable&quot;:{},&quot;ViceTable&quot;:{&quot;key@&quot;:&quot;&#x2F;MainTable&#x2F;refKey&quot;}会对应生成 MainTable LEFT JOIN ViceTable ON ViceTable.key&#x3D;MainTable.refKey AND 其它ON条件  除了 &#x3D; 等价关联，也支持 ! 不等关联、&gt; &lt; &gt;&#x3D; &lt;&#x3D; 等比较关联和 $ ~ {} &lt;&gt; 等其它复杂关联方式 ⑤ “otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 查询User数组，最多5个：“count”:5对应SQL是LIMIT 5  ② 查询第3页的User数组，每页5个：“count”:5,“page”:3对应SQL是LIMIT 5 OFFSET 15  ③ 查询User数组和对应的User总数：“[]”:{    “query”:2,    “User”:{}},“total@”:”&#x2F;[]&#x2F;total”,“info@”:”&#x2F;[]&#x2F;info” 返回的数据中，总数及分页详情结构为：   “total”:139,  &#x2F;&#x2F;总数  “info”:{  &#x2F;&#x2F;分页详情     “total”:139,  &#x2F;&#x2F;总数     “count”:5,  &#x2F;&#x2F;每页数量     “page”:0,  &#x2F;&#x2F;当前页码     “max”:27,  &#x2F;&#x2F;最大页码     “more”:true,  &#x2F;&#x2F;是否还有更多     “first”:true,  &#x2F;&#x2F;是否为首页     “last”:false  &#x2F;&#x2F;是否为尾页 }  ④ Moment INNER JOIN User LEFT JOIN Comment：“[]”:{    “join”:”&amp;&#x2F;User&#x2F;id@,&lt;&#x2F;Comment”,    “Moment”:{     “@group”:”id”  &#x2F;&#x2F;主副表不是一对一，要去除重复数据   },    “User”:{      “name~”:”t”,      “id@”:”&#x2F;Moment&#x2F;userId”    },    “Comment”:{      “momentId@”:”&#x2F;Moment&#x2F;id”    }} ⑤ 每一层都加当前用户名：“User”:{},“[]”:{    “name@”:”User&#x2F;name”, &#x2F;&#x2F;自定义关键词    “Moment”:{}}


对象关键词，可自定义
“@key”:Object，@key为 Table:{} 中{}内的关键词，Object的类型由@key指定① “@combine”:”key0 | (key1 &amp; (key2 | !key3))…”，条件组合方式，最终按  (其它key条件 AND 连接) AND (key0条件 OR (key1条件 AND (key2条件 OR (NOT key3条件)))) 这种方式连接，其中 “其它key” 是指与 @combine 在同一对象，且未被它声明的条件 key，默认都是 &amp; 连接。注意不要缺少或多余任何一个空格。 ② “@column”:”column;function(arg)…”，返回字段③ “@order”:”column0+,column1-…”，排序方式④ “@group”:”column0,column1…”，分组方式。如果@column里声明了Table的id，则id也必须在@group中声明；其它情况下必须满足至少一个条件:1.分组的key在@column里声明2.Table主键在@group中声明 ⑤ “@having”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…” &#x2F;&#x2F; OR 连接，或 “@having&amp;”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…”  &#x2F;&#x2F; AND 连接，或 “@having”:{   “h0”:”function0(…)?value0”,   “h1”:function1(…)?value1”,   “h2”:function2(…)?value2…”,   “@combine”:”h0 &amp; (h1 | !h2)”  &#x2F;&#x2F; 任意组合，非必传}SQL函数条件，一般和@group一起用，函数一般在@column里声明⑥ “@schema”:”sys”，集合空间(数据库名&#x2F;模式)，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑦ “@database”:”POSTGRESQL”，数据库类型，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑧ “@datasource”:”DRUID”，跨数据源，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑨ “@json”:”key0,key1…”，转为 JSON 格式返回，符合 JSONObject 则转为 {…}，符合 JSONArray 则转为 […] ⑩ “@role”:”OWNER”，来访角色，包括UNKNOWN,LOGIN,CONTACT,CIRCLE,OWNER,ADMIN，可以在最外层作为全局默认配置，可自定义其它角色并重写 Verifier.verify 等相关方法来自定义校验 ⑪ “@explain”:true，性能分析，可以在最外层作为全局默认配置 ⑫ “@raw”:”key0,key1…”，其中 key0, key1 都对应有键值对 “key0”:”SQL片段或SQL片段的别名”,  “key1”:”SQL片段或SQL片段的别名”  自定义原始SQL片段，可扩展嵌套SQL函数等复杂语句，必须是后端已配置的，只有其它功能符都做不到才考虑，谨慎使用，注意防SQL注入⑬ “@otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 搜索name或tag任何一个字段包含字符a的User列表： “name“:”a”,“tag“:”a”,“@combine”:”name~ | tag~” 对应SQL是name REGEXP &#39;a&#39; OR tag REGEXP &#39;a&#39;  ② 只查询id,sex,name这几列并且请求结果也按照这个顺序：“@column”:”id,sex,name”对应SQL是SELECT id,sex,name  ③ 查询按 name降序、id默认顺序 排序的User数组：“@order”:”name-,id”对应SQL是ORDER BY name DESC,id  ④ 查询按userId分组的Moment数组：“@group”:”userId,id”对应SQL是GROUP BY userId,id  ⑤ 查询 按userId分组、id最大值&gt;&#x3D;100 的Moment数组：“@column”:”userId;max(id)”,“@group”:”userId”,“@having”:”max(id)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) ... GROUP BY userId HAVING max(id)&gt;&#x3D;100 还可以指定函数返回名：“@column”:”userId;max(id):maxId”,“@group”:”userId”,“@having”:”(maxId)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) AS maxId ... GROUP BY userId HAVING (maxId)&gt;&#x3D;100  ⑥ 查询 sys 内的 User 表：“@schema”:”sys”对应SQL是FROM sys.User  ⑦ 查询 PostgreSQL 数据库的 User 表：“@database”:”POSTGRESQL” ⑧ 使用 Druid 连接池查询 User 表：“@datasource”:”DRUID” ⑨ 将 VARCHAR 字符串字段 get 转为 JSONArray 返回：“@json”:”get” ⑩ 查询当前用户的动态：“@role”:”OWNER” ⑪ 开启性能分析：“@explain”:true对应SQL是EXPLAIN  ⑫ 统计最近一周偶数userId的数量“@column”:”date;left(date,10):day;sum(if(userId%2&#x3D;0,1,0))”,“@group”:”day”,“@having”:”to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7”,“@raw”:”@column,@having”对应SQL是SELECT date, left(date,10) AS day, sum(if(userId%2&#x3D;0,1,0)) ... GROUP BY day HAVING to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7  ⑬ 从pictureList获取第0张图片：“@position”:0, &#x2F;&#x2F;自定义关键词“firstPicture()”:”getFromArray(pictureList,@position)”


全局关键词
为最外层对象 {} 内的关键词。其中 @database，@schema, @datasource, @role, @explain 基本同对象关键词，见上方说明，区别是全局关键词会每个表对象中没有时自动放入，作为默认值。 ① “tag”:String，后面的 tag 是非 GET、HEAD 请求中匹配请求的 JSON 结构的标识，一般是要查询的 Table 的名称或该名称对应的数组 Table[] 或 Table:[]，由后端 Request 表中指定。 ② “version”:Integer，接口版本，version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本，由后端 Request 表中指定。③ “format”:Boolean，格式化返回 Response JSON 的 key，一般是将 TableName 转为 tableName, TableName[] 转为 tableNameList, Table:alias 转为 alias, TableName-key[] 转为 tableNameKeyList 等小驼峰格式。
①  查隐私信息：[{“tag”:”Privacy”,”Privacy”:{“id”:82001}}](http:&#x2F;&#x2F;apijson.cn&#x2F;api?url&#x3D;http%3A%2F%2Fapijson.cn%3A8080%2Fgets&amp;type&#x3D;JSON&amp;json&#x3D;


</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2.6"><span class="toc-number">1.6.18.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83-1"><span class="toc-number">1.7.</span> <span class="toc-text">3.设计规范3.1 操作方法


方法及说明
URL
Request
Response



GET:  普通获取数据， 可用浏览器调试
base_url&#x2F;get&#x2F;
{    TableName:{      …     }}  {…}内为限制条件 例如获取一个 id &#x3D; 235 的 Moment： {    “Moment”:{      “id”:235    }}  后端校验通过后自动解析为 SQL 并执行：SELECT * FROM Moment WHERE id&#x3D;235 LIMIT 1
{    TableName:{      …    },    “code”:200,    “msg”:”success”}例如{    “Moment”:{      “id”:235,      “userId”:38710,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “code”:200,    “msg”:”success” }


HEAD:  普通获取数量， 可用浏览器调试
base_url&#x2F;head&#x2F;
{    TableName:{      …    } }  {…}内为限制条件  例如获取一个 id &#x3D; 38710 的 User 所发布的 Moment 总数： {    “Moment”:{      “userId”:38710    }}  后端校验通过后自动解析为 SQL 并执行：SELECT count(*) FROM Moment WHERE userId&#x3D;38710 LIMIT 1
{    TableName:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,    “msg”:”success”}  例如{    “Moment”:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,     “msg”:”success”}


GETS:  安全&#x2F;私密获取数据， 用于获取钱包等对安全性要求高的数据
base_url&#x2F;gets&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Privacy”，其它同GET
同GET


HEADS:  安全&#x2F;私密获取数量， 用于获取银行卡数量等对安全性要求高的数据总数
base_url&#x2F;heads&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Verify”，其它同HEAD
同HEAD


POST:  新增数据
base_url&#x2F;post&#x2F;
单个：  {    TableName:{      …    },    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 38710 发布一个新 Comment：{    “Comment”:{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”     },    “tag”:”Comment”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(38710,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;)    批量：  {    TableName[]:[{        …      }, {        …      }      …    ],    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 82001 发布 2 个 Comment：{    “Comment[]”:[{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”      }, {      “momentId”:15,      “content”:”APIJSON is a JSON transmision protocol.”    }],    “tag”:”Comment:[]”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(82001,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;);INSERT INTO Comment(userId,momentId,content) VALUES(82001,15,&#39;APIJSON is a JSON transmision protocol.&#39;);
单个：  {    TableName:{      “code”:200,      “msg”:”success”,      “id”:38710    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “id”:120    },    “code”:200,    “msg”:”success”}   批量：  {    TableName:{      “code”:200,      “msg”:”success”,      “count”:5,      “id[]”:[1, 2, 3, 4, 5]    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “count”:2,      “id[]”:[1, 2]    },    “code”:200,    “msg”:”success”}


PUT:  修改数据， 只修改所传的字段
base_url&#x2F;put&#x2F;
{    TableName:{      “id”:id,      …    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个 例如当前登录用户 82001 修改 id &#x3D; 235 的 Moment 的 content：{    “Moment”:{      “id”:235,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “tag”:”Moment”}  后端校验通过后自动解析为 SQL 并执行：UPDATE Moment SET content&#x3D;&#39;APIJSON,let interfaces and documents go to hell !&#39; WHERE id&#x3D;235 AND userId&#x3D;82001 LIMIT 1  批量除了 id{}:[] 也可类似批量 POST，只是每个 {…} 里面都必须有 id。“tag”:”Comment[]” 对应对象 “Comment”:{“id{}”:[1,2,3]}，表示指定记录全部统一设置；“tag”:”Comment:[]” 多了冒号，对应数组 “Comment[]”:[{“id”:1},{“id”:2},{“id”:3}]，表示每项单独设置
同POST


DELETE:  删除数据
base_url&#x2F;delete&#x2F;
{    TableName:{      “id”:id    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个，一般只传 id 或 id{} 例如当前登录用户 82001 批量删除 id &#x3D; 100,110,120 的 Comment：{    “Comment”:{      “id{}”:[100,110,120]    },    “tag”:”Comment[]”}  后端校验通过后自动解析为 SQL 并执行：DELETE FROM Comment WHERE id IN(100,110,120) AND userId&#x3D;82001 LIMIT 3
{    TableName:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120]      “count”:3    },    “code”:200,    “msg”:”success”}例如{   “Comment”:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120],      “count”:3   },   “code”:200,   “msg”:”success”}


以上接口的简单形式:  base_url&#x2F;{method}&#x2F;{tag}
GET: 普通获取数据  base_url&#x2F;get&#x2F;{tag}  HEAD: 普通获取数量  base_url&#x2F;head&#x2F;{tag}  GETS: 安全&#x2F;私密获取数据   base_url&#x2F;gets&#x2F;{tag}  HEADS: 安全&#x2F;私密获取数量  base_url&#x2F;heads&#x2F;{tag}  POST: 新增数据   base_url&#x2F;post&#x2F;{tag}  PUT: 修改数据  base_url&#x2F;put&#x2F;{tag}  DELETE: 删除数据  base_url&#x2F;delete&#x2F;{tag}
例如安全&#x2F;私密获取一个 id &#x3D; 82001 的 Privacy： base_url&#x2F;gets&#x2F;Privacy&#x2F;  {“id”:82001}  相当于  base_url&#x2F;gets&#x2F; {“tag”:”Privacy”, “Privacy”:{“id”:82001}}   例如批量修改 id &#x3D; 114, 124 的 Comment 的 content：base_url&#x2F;put&#x2F;Comemnt[]&#x2F;  {    “id{}”:[114,124],    “content”:”test multi put”}  相当于  base_url&#x2F;put&#x2F;  {    “tag”:”Comment[]”,     “Comment”:{      “id{}”:[114,124],      “content”:”test multi put”    }}
同以上对应的方法


1.TableName指要查询的数据库表Table的名称字符串。第一个字符为大写字母，剩下的字符要符合英语字母、数字、下划线中的任何一种。对应的值的类型为JSONObject，结构是 {…}，里面放的是Table的字段(列名)。下同。2.”tag”:tag 后面的tag是非GET、HEAD请求中匹配请求的JSON结构的标识，一般是要查询的Table的名称，由后端Request表中指定。下同。3.GET、HEAD请求是开放请求，可任意组合任意嵌套。其它请求为受限制的安全&#x2F;私密请求，对应的 方法（method）, 标识（tag）, 版本（version）, 结构（structure） 都必须和 后端Request表中所指定的 一一对应，否则请求将不被通过。version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本。下同。4.GETS与GET、HEADS与HEAD分别为同一类型的操作方法，请求稍有不同但返回结果相同。下同。5.在HTTP通信中，自动化接口(get,gets,head,heads,post,put,delete) 全用HTTP POST请求。下同。6.所有JSONObject都视为容器(或者文件夹)，结构为 {…} ，里面可以放普通对象或子容器。下同。7.每个对象都有一个唯一的路径(或者叫地址)，假设对象名为refKey，则用 key0&#x2F;key1&#x2F;…&#x2F;refKey 表示。下同。


3.2 功能符


功能
键值对格式
使用示例



查询数组
“key[]”:{}，后面是JSONObject，key可省略。当key和里面的Table名相同时，Table会被提取出来，即 {Table:{Content}} 会被转化为 {Content}
{“User[]”:{“User”:{}}}，查询一个User数组。这里key和Table名都是User，User会被提取出来，即 {“User”:{“id”, …}} 会被转化为 {“id”, …}，如果要进一步提取User中的id，可以把User[]改为User-id[]


匹配选项范围
“key{}”:[]，后面是JSONArray，作为key可取的值的选项
“id{}”:[38710,82001,70793]，对应SQL是id IN(38710,82001,70793)，查询id符合38710,82001,70793中任意一个的一个User数组


匹配条件范围
“key{}”:”条件0,条件1…”，条件为SQL表达式字符串，可进行数字比较运算等
“id{}”:”&lt;&#x3D;80000,&gt;90000”，对应SQL是id&lt;&#x3D;80000 OR id&gt;90000，查询id符合id&lt;&#x3D;80000 | id&gt;90000的一个User数组


包含选项范围
“key&lt;&gt;“:Object  &#x3D;&gt;  “key&lt;&gt;“:[Object]，key对应值的类型必须为JSONArray，Object类型不能为JSON
“contactIdList&lt;&gt;“:38710，对应SQL是json_contains(contactIdList,38710)，查询contactIdList包含38710的一个User数组


判断是否存在
“key}{@”:{    “from”:”Table”,    “Table”:{ … }}其中：}{ 表示 EXISTS； key 用来标识是哪个判断； @ 后面是 子查询 对象，具体见下方 子查询 的说明。
“id}{@”:{    “from”:”Comment”,    “Comment”:{        “momentId”:15     }} WHERE EXISTS(SELECT * FROM Comment WHERE momentId&#x3D;15)


远程调用函数
“key()”:”函数表达式”，函数表达式为 function(key0,key1…)，会调用后端对应的函数 function(JSONObject request, String key0, String key1…)，实现 参数校验、数值计算、数据同步、消息推送、字段拼接、结构变换 等特定的业务逻辑处理，可使用 - 和 + 表示优先级，解析 key-() &gt; 解析当前对象 &gt; 解析 key() &gt; 解析子对象 &gt; 解析 key+()
“isPraised()”:”isContain(praiseUserIdList,userId)”，会调用远程函数 boolean isContain(JSONObject request, String array, String value) ，然后变为 “isPraised”:true 这种（假设点赞用户id列表包含了userId，即这个User点了赞）


存储过程
“@key()”:”SQL函数表达式”，函数表达式为   function(key0,key1…)  会调用后端数据库对应的存储过程 SQL函数  function(String key0, String key1…)  除了参数会提前赋值，其它和 远程函数 一致
“@limit”:10,  “@offset”:0,  “@procedure()”:”getCommentByUserId(id,@limit,@offset)”  会转为  getCommentByUserId(38710,10,0)  来调用存储过程 SQL 函数  getCommentByUserId(IN id bigint, IN limit int, IN offset int)  然后变为 “procedure”:{    “count”:-1,     “update”:false,     “list”:[]  }  其中 count 是指写操作影响记录行数，-1 表示不是写操作；update 是指是否为写操作（增删改）；list 为返回结果集


引用赋值
“key@”:”key0&#x2F;key1&#x2F;…&#x2F;refKey”，引用路径为用&#x2F;分隔的字符串。以&#x2F;开头的是缺省引用路径，从声明key所处容器的父容器路径开始；其它是完整引用路径，从最外层开始。 被引用的refKey必须在声明key的上面。如果对refKey的容器指定了返回字段，则被引用的refKey必须写在@column对应的值内，例如 “@column”:”refKey,key1,…”
“Moment”:{    “userId”:38710},“User”:{    “id@”:”&#x2F;Moment&#x2F;userId”} User内的id引用了与User同级的Moment内的userId，即User.id &#x3D; Moment.userId，请求完成后 “id@”:”&#x2F;Moment&#x2F;userId” 会变成 “id”:38710


子查询
“key@”:{    “range”:”ALL”,     “from”:”Table”,    “Table”:{ … }}其中：range 可为 ALL,ANY；from 为目标表 Table 的名称；@ 后面的对象类似数组对象，可使用 count 和 join 等功能。
“id@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&#x3D;(SELECT min(userId) FROM Comment)


模糊搜索
&quot;key$&quot;:&quot;SQL搜索表达式&quot;  &#x3D;&gt;  &quot;key$&quot;:[&quot;SQL搜索表达式&quot;]，任意SQL搜索表达式字符串，如 %key%(包含key), key%(以key开始), %k%e%y%(包含字母k,e,y) 等，%表示任意字符
“name$”:”%m%”，对应SQL是name LIKE &#39;%m%&#39;，查询name包含”m”的一个User数组


正则匹配
“key“:”正则表达式”  &#x3D;&gt;  “key“:[“正则表达式”]，任意正则表达式字符串，如 ^[0-9]+$ ，*~ 忽略大小写，可用于高级搜索
“name~”:”^[0-9]+$”，对应SQL是name REGEXP &#39;^[0-9]+$&#39;，查询name中字符全为数字的一个User数组


连续范围
“key%”:”start,end”  &#x3D;&gt;  “key%”:[“start,end”]，其中 start 和 end 都只能为 Boolean, Number, String 中的一种，如 “2017-01-01,2019-01-01” ，[“1,90000”, “82001,100000”] ，可用于连续范围内的筛选
“date%”:”2017-10-01,2018-10-01”，对应SQL是date BETWEEN &#39;2017-10-01&#39; AND &#39;2018-10-01&#39;，查询在2017-10-01和2018-10-01期间注册的用户的一个User数组


新建别名
“name:alias”，name映射为alias，用alias替代name。可用于 column,Table,SQL函数 等。只用于GET类型、HEAD类型的请求
“@column”:”toId:parentId”，对应SQL是toId AS parentId，将查询的字段toId变为parentId返回


增加 或 扩展
“key+”:Object，Object的类型由key指定，且类型为Number,String,JSONArray中的一种。如 82001,”apijson”,[“url0”,”url1”] 等。只用于PUT请求
“praiseUserIdList+”:[82001]，对应SQL是json_insert(praiseUserIdList,82001)，添加一个点赞用户id，即这个用户点了赞


减少 或 去除
“key-“:Object，与”key+”相反
“balance-“:100.00，对应SQL是balance &#x3D; balance - 100.00，余额减少100.00，即花费了100元


比较运算
&gt;, &lt;, &gt;&#x3D;, &lt;&#x3D; 比较运算符，用于 ① 提供 “id{}”:”&lt;&#x3D;90000” 这种条件范围的简化写法 ② 实现子查询相关比较运算不支持 “key&#x3D;”:Object 和 “key!&#x3D;”:Object 这两种写法，直接用更简单的 “key”:Object 和 “key!”:Object 替代。
① “id&lt;&#x3D;”:90000，对应SQL是id&lt;&#x3D;90000，查询符合id&lt;&#x3D;90000的一个User数组 ② “id&gt;@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&gt;(SELECT min(userId) FROM Comment)


逻辑运算
&amp;, |, ! 逻辑运算符，对应数据库 SQL 中的 AND, OR, NOT。 横或纵与：同一键值对的值内条件默认 | 或连接，可以在 key 后加逻辑运算符来具体指定；不同键值对的条件默认 &amp; 与连接，可以用下面说明的对象关键词 @combine 来具体指定。 ① &amp; 可用于”key&amp;{}”:”条件”等② | 可用于”key|{}”:”条件”, “key|{}”:[]等，一般可省略③ ! 可单独使用，如”key!”:Object，也可像&amp;,|一样配合其他功能符使用  “key!”:null 无效，null 值会导致整个键值对被忽略解析，可以用 “key{}”:”!&#x3D;null” 替代，“key”:null 同理，用 “key{}”:”&#x3D;null” 替代。
① “id&amp;{}”:”&gt;80000,&lt;&#x3D;90000”，对应SQL是id&gt;80000 AND id&lt;&#x3D;90000，即id满足id&gt;80000 &amp; id&lt;&#x3D;90000 ② “id|{}”:”&gt;90000,&lt;&#x3D;80000”，同”id{}”:”&gt;90000,&lt;&#x3D;80000”，对应SQL是id&gt;80000 OR id&lt;&#x3D;90000，即id满足id&gt;90000 | id&lt;&#x3D;80000 ③ “id!{}”:[82001,38710]，对应SQL是id NOT IN(82001,38710)，即id满足 ! (id&#x3D;82001 | id&#x3D;38710)，可过滤黑名单的消息


数组关键词，可自定义
“key”:Object，key为 “[]”:{} 中{}内的关键词，Object的类型由key指定① “count”:Integer，查询数量，0 表示最大值，默认最大值为100 ② “page”:Integer，查询页码，从0开始，默认最大值为100，一般和count一起用③ “query”:Integer，查询内容0-对象，1-总数和分页详情，2-数据、总数和分页详情总数关键词为 total，分页详情关键词为 info， 它们都和 query 同级，通过引用赋值得到，例如  “total@”:”&#x2F;[]&#x2F;total”, “info@”:”&#x2F;[]&#x2F;info” 这里query及total仅为GET类型的请求提供方便， 一般可直接用HEAD类型的请求获取总数④ “join”:”&amp;&#x2F;Table0,&lt;&#x2F;Table1&#x2F;key1@” 或 “join”:{    “&amp;&#x2F;Table0”:{},  &#x2F;&#x2F; 支持 ON 多个字段关联,    “&lt;&#x2F;Table1&#x2F;key1@”:{  &#x2F;&#x2F; ON 只允许指定的 key1 关联      “key0”:value0,  &#x2F;&#x2F; 其它ON条件       “key2”:value2,      …       “@combine”:”…”,  &#x2F;&#x2F; 其它ON条件的组合方式       “@column”:”…”,  &#x2F;&#x2F; 外层 SELECT       “@group”:”…”,  &#x2F;&#x2F; 外层 GROUP BY       “@having”:”…”  &#x2F;&#x2F; 外层 HAVING     }}多表连接方式：  “@” - APP JOIN  “&lt;“ - LEFT JOIN  “&gt;” - RIGHT JOIN  “&amp;” - INNER JOIN  “|” - FULL JOIN   “!” - OUTER JOIN   “*” - CROSS JOIN   “^” - SIDE JOIN   “(“ - ANTI JOIN   “)” - FOREIGN JOIN 其中 @ APP JOIN 为应用层连表，会从已查出的主表里取得所有副表 key@ 关联的主表内的 refKey 作为一个数组 refKeys: [value0, value1…]，然后把原来副表 count 次查询 key&#x3D;$refKey 的 SQL 用 key IN($refKeys) 的方式合并为一条 SQL 来优化性能； 其它 JOIN 都是 SQL JOIN，具体功能和 MySQL,PostgreSQL 等数据库的 JOIN 一一对应 &quot;join&quot;:&quot;&lt;&#x2F;ViceTable&#x2F;key@&quot;,&quot;MainTable&quot;:{},&quot;ViceTable&quot;:{&quot;key@&quot;:&quot;&#x2F;MainTable&#x2F;refKey&quot;}会对应生成 MainTable LEFT JOIN ViceTable ON ViceTable.key&#x3D;MainTable.refKey AND 其它ON条件  除了 &#x3D; 等价关联，也支持 ! 不等关联、&gt; &lt; &gt;&#x3D; &lt;&#x3D; 等比较关联和 $ ~ {} &lt;&gt; 等其它复杂关联方式 ⑤ “otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 查询User数组，最多5个：“count”:5对应SQL是LIMIT 5  ② 查询第3页的User数组，每页5个：“count”:5,“page”:3对应SQL是LIMIT 5 OFFSET 15  ③ 查询User数组和对应的User总数：“[]”:{    “query”:2,    “User”:{}},“total@”:”&#x2F;[]&#x2F;total”,“info@”:”&#x2F;[]&#x2F;info” 返回的数据中，总数及分页详情结构为：   “total”:139,  &#x2F;&#x2F;总数  “info”:{  &#x2F;&#x2F;分页详情     “total”:139,  &#x2F;&#x2F;总数     “count”:5,  &#x2F;&#x2F;每页数量     “page”:0,  &#x2F;&#x2F;当前页码     “max”:27,  &#x2F;&#x2F;最大页码     “more”:true,  &#x2F;&#x2F;是否还有更多     “first”:true,  &#x2F;&#x2F;是否为首页     “last”:false  &#x2F;&#x2F;是否为尾页 }  ④ Moment INNER JOIN User LEFT JOIN Comment：“[]”:{    “join”:”&amp;&#x2F;User&#x2F;id@,&lt;&#x2F;Comment”,    “Moment”:{     “@group”:”id”  &#x2F;&#x2F;主副表不是一对一，要去除重复数据   },    “User”:{      “name~”:”t”,      “id@”:”&#x2F;Moment&#x2F;userId”    },    “Comment”:{      “momentId@”:”&#x2F;Moment&#x2F;id”    }} ⑤ 每一层都加当前用户名：“User”:{},“[]”:{    “name@”:”User&#x2F;name”, &#x2F;&#x2F;自定义关键词    “Moment”:{}}


对象关键词，可自定义
“@key”:Object，@key为 Table:{} 中{}内的关键词，Object的类型由@key指定① “@combine”:”key0 | (key1 &amp; (key2 | !key3))…”，条件组合方式，最终按  (其它key条件 AND 连接) AND (key0条件 OR (key1条件 AND (key2条件 OR (NOT key3条件)))) 这种方式连接，其中 “其它key” 是指与 @combine 在同一对象，且未被它声明的条件 key，默认都是 &amp; 连接。注意不要缺少或多余任何一个空格。 ② “@column”:”column;function(arg)…”，返回字段③ “@order”:”column0+,column1-…”，排序方式④ “@group”:”column0,column1…”，分组方式。如果@column里声明了Table的id，则id也必须在@group中声明；其它情况下必须满足至少一个条件:1.分组的key在@column里声明2.Table主键在@group中声明 ⑤ “@having”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…” &#x2F;&#x2F; OR 连接，或 “@having&amp;”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…”  &#x2F;&#x2F; AND 连接，或 “@having”:{   “h0”:”function0(…)?value0”,   “h1”:function1(…)?value1”,   “h2”:function2(…)?value2…”,   “@combine”:”h0 &amp; (h1 | !h2)”  &#x2F;&#x2F; 任意组合，非必传}SQL函数条件，一般和@group一起用，函数一般在@column里声明⑥ “@schema”:”sys”，集合空间(数据库名&#x2F;模式)，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑦ “@database”:”POSTGRESQL”，数据库类型，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑧ “@datasource”:”DRUID”，跨数据源，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑨ “@json”:”key0,key1…”，转为 JSON 格式返回，符合 JSONObject 则转为 {…}，符合 JSONArray 则转为 […] ⑩ “@role”:”OWNER”，来访角色，包括UNKNOWN,LOGIN,CONTACT,CIRCLE,OWNER,ADMIN，可以在最外层作为全局默认配置，可自定义其它角色并重写 Verifier.verify 等相关方法来自定义校验 ⑪ “@explain”:true，性能分析，可以在最外层作为全局默认配置 ⑫ “@raw”:”key0,key1…”，其中 key0, key1 都对应有键值对 “key0”:”SQL片段或SQL片段的别名”,  “key1”:”SQL片段或SQL片段的别名”  自定义原始SQL片段，可扩展嵌套SQL函数等复杂语句，必须是后端已配置的，只有其它功能符都做不到才考虑，谨慎使用，注意防SQL注入⑬ “@otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 搜索name或tag任何一个字段包含字符a的User列表： “name“:”a”,“tag“:”a”,“@combine”:”name~ | tag~” 对应SQL是name REGEXP &#39;a&#39; OR tag REGEXP &#39;a&#39;  ② 只查询id,sex,name这几列并且请求结果也按照这个顺序：“@column”:”id,sex,name”对应SQL是SELECT id,sex,name  ③ 查询按 name降序、id默认顺序 排序的User数组：“@order”:”name-,id”对应SQL是ORDER BY name DESC,id  ④ 查询按userId分组的Moment数组：“@group”:”userId,id”对应SQL是GROUP BY userId,id  ⑤ 查询 按userId分组、id最大值&gt;&#x3D;100 的Moment数组：“@column”:”userId;max(id)”,“@group”:”userId”,“@having”:”max(id)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) ... GROUP BY userId HAVING max(id)&gt;&#x3D;100 还可以指定函数返回名：“@column”:”userId;max(id):maxId”,“@group”:”userId”,“@having”:”(maxId)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) AS maxId ... GROUP BY userId HAVING (maxId)&gt;&#x3D;100  ⑥ 查询 sys 内的 User 表：“@schema”:”sys”对应SQL是FROM sys.User  ⑦ 查询 PostgreSQL 数据库的 User 表：“@database”:”POSTGRESQL” ⑧ 使用 Druid 连接池查询 User 表：“@datasource”:”DRUID” ⑨ 将 VARCHAR 字符串字段 get 转为 JSONArray 返回：“@json”:”get” ⑩ 查询当前用户的动态：“@role”:”OWNER” ⑪ 开启性能分析：“@explain”:true对应SQL是EXPLAIN  ⑫ 统计最近一周偶数userId的数量“@column”:”date;left(date,10):day;sum(if(userId%2&#x3D;0,1,0))”,“@group”:”day”,“@having”:”to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7”,“@raw”:”@column,@having”对应SQL是SELECT date, left(date,10) AS day, sum(if(userId%2&#x3D;0,1,0)) ... GROUP BY day HAVING to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7  ⑬ 从pictureList获取第0张图片：“@position”:0, &#x2F;&#x2F;自定义关键词“firstPicture()”:”getFromArray(pictureList,@position)”


全局关键词
为最外层对象 {} 内的关键词。其中 @database，@schema, @datasource, @role, @explain 基本同对象关键词，见上方说明，区别是全局关键词会每个表对象中没有时自动放入，作为默认值。 ① “tag”:String，后面的 tag 是非 GET、HEAD 请求中匹配请求的 JSON 结构的标识，一般是要查询的 Table 的名称或该名称对应的数组 Table[] 或 Table:[]，由后端 Request 表中指定。 ② “version”:Integer，接口版本，version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本，由后端 Request 表中指定。③ “format”:Boolean，格式化返回 Response JSON 的 key，一般是将 TableName 转为 tableName, TableName[] 转为 tableNameList, Table:alias 转为 alias, TableName-key[] 转为 tableNameKeyList 等小驼峰格式。
①  查隐私信息：[{“tag”:”Privacy”,”Privacy”:{“id”:82001}}](http:&#x2F;&#x2F;apijson.cn&#x2F;api?url&#x3D;http%3A%2F%2Fapijson.cn%3A8080%2Fgets&amp;type&#x3D;JSON&amp;json&#x3D;


</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3"><span class="toc-number">1.8.</span> <span class="toc-text">3.设计规范3.1 操作方法


方法及说明
URL
Request
Response



GET:  普通获取数据， 可用浏览器调试
base_url&#x2F;get&#x2F;
{    TableName:{      …     }}  {…}内为限制条件 例如获取一个 id &#x3D; 235 的 Moment： {    “Moment”:{      “id”:235    }}  后端校验通过后自动解析为 SQL 并执行：SELECT * FROM Moment WHERE id&#x3D;235 LIMIT 1
{    TableName:{      …    },    “code”:200,    “msg”:”success”}例如{    “Moment”:{      “id”:235,      “userId”:38710,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “code”:200,    “msg”:”success” }


HEAD:  普通获取数量， 可用浏览器调试
base_url&#x2F;head&#x2F;
{    TableName:{      …    } }  {…}内为限制条件  例如获取一个 id &#x3D; 38710 的 User 所发布的 Moment 总数： {    “Moment”:{      “userId”:38710    }}  后端校验通过后自动解析为 SQL 并执行：SELECT count(*) FROM Moment WHERE userId&#x3D;38710 LIMIT 1
{    TableName:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,    “msg”:”success”}  例如{    “Moment”:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,     “msg”:”success”}


GETS:  安全&#x2F;私密获取数据， 用于获取钱包等对安全性要求高的数据
base_url&#x2F;gets&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Privacy”，其它同GET
同GET


HEADS:  安全&#x2F;私密获取数量， 用于获取银行卡数量等对安全性要求高的数据总数
base_url&#x2F;heads&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Verify”，其它同HEAD
同HEAD


POST:  新增数据
base_url&#x2F;post&#x2F;
单个：  {    TableName:{      …    },    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 38710 发布一个新 Comment：{    “Comment”:{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”     },    “tag”:”Comment”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(38710,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;)    批量：  {    TableName[]:[{        …      }, {        …      }      …    ],    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 82001 发布 2 个 Comment：{    “Comment[]”:[{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”      }, {      “momentId”:15,      “content”:”APIJSON is a JSON transmision protocol.”    }],    “tag”:”Comment:[]”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(82001,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;);INSERT INTO Comment(userId,momentId,content) VALUES(82001,15,&#39;APIJSON is a JSON transmision protocol.&#39;);
单个：  {    TableName:{      “code”:200,      “msg”:”success”,      “id”:38710    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “id”:120    },    “code”:200,    “msg”:”success”}   批量：  {    TableName:{      “code”:200,      “msg”:”success”,      “count”:5,      “id[]”:[1, 2, 3, 4, 5]    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “count”:2,      “id[]”:[1, 2]    },    “code”:200,    “msg”:”success”}


PUT:  修改数据， 只修改所传的字段
base_url&#x2F;put&#x2F;
{    TableName:{      “id”:id,      …    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个 例如当前登录用户 82001 修改 id &#x3D; 235 的 Moment 的 content：{    “Moment”:{      “id”:235,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “tag”:”Moment”}  后端校验通过后自动解析为 SQL 并执行：UPDATE Moment SET content&#x3D;&#39;APIJSON,let interfaces and documents go to hell !&#39; WHERE id&#x3D;235 AND userId&#x3D;82001 LIMIT 1  批量除了 id{}:[] 也可类似批量 POST，只是每个 {…} 里面都必须有 id。“tag”:”Comment[]” 对应对象 “Comment”:{“id{}”:[1,2,3]}，表示指定记录全部统一设置；“tag”:”Comment:[]” 多了冒号，对应数组 “Comment[]”:[{“id”:1},{“id”:2},{“id”:3}]，表示每项单独设置
同POST


DELETE:  删除数据
base_url&#x2F;delete&#x2F;
{    TableName:{      “id”:id    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个，一般只传 id 或 id{} 例如当前登录用户 82001 批量删除 id &#x3D; 100,110,120 的 Comment：{    “Comment”:{      “id{}”:[100,110,120]    },    “tag”:”Comment[]”}  后端校验通过后自动解析为 SQL 并执行：DELETE FROM Comment WHERE id IN(100,110,120) AND userId&#x3D;82001 LIMIT 3
{    TableName:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120]      “count”:3    },    “code”:200,    “msg”:”success”}例如{   “Comment”:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120],      “count”:3   },   “code”:200,   “msg”:”success”}


以上接口的简单形式:  base_url&#x2F;{method}&#x2F;{tag}
GET: 普通获取数据  base_url&#x2F;get&#x2F;{tag}  HEAD: 普通获取数量  base_url&#x2F;head&#x2F;{tag}  GETS: 安全&#x2F;私密获取数据   base_url&#x2F;gets&#x2F;{tag}  HEADS: 安全&#x2F;私密获取数量  base_url&#x2F;heads&#x2F;{tag}  POST: 新增数据   base_url&#x2F;post&#x2F;{tag}  PUT: 修改数据  base_url&#x2F;put&#x2F;{tag}  DELETE: 删除数据  base_url&#x2F;delete&#x2F;{tag}
例如安全&#x2F;私密获取一个 id &#x3D; 82001 的 Privacy： base_url&#x2F;gets&#x2F;Privacy&#x2F;  {“id”:82001}  相当于  base_url&#x2F;gets&#x2F; {“tag”:”Privacy”, “Privacy”:{“id”:82001}}   例如批量修改 id &#x3D; 114, 124 的 Comment 的 content：base_url&#x2F;put&#x2F;Comemnt[]&#x2F;  {    “id{}”:[114,124],    “content”:”test multi put”}  相当于  base_url&#x2F;put&#x2F;  {    “tag”:”Comment[]”,     “Comment”:{      “id{}”:[114,124],      “content”:”test multi put”    }}
同以上对应的方法


1.TableName指要查询的数据库表Table的名称字符串。第一个字符为大写字母，剩下的字符要符合英语字母、数字、下划线中的任何一种。对应的值的类型为JSONObject，结构是 {…}，里面放的是Table的字段(列名)。下同。2.”tag”:tag 后面的tag是非GET、HEAD请求中匹配请求的JSON结构的标识，一般是要查询的Table的名称，由后端Request表中指定。下同。3.GET、HEAD请求是开放请求，可任意组合任意嵌套。其它请求为受限制的安全&#x2F;私密请求，对应的 方法（method）, 标识（tag）, 版本（version）, 结构（structure） 都必须和 后端Request表中所指定的 一一对应，否则请求将不被通过。version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本。下同。4.GETS与GET、HEADS与HEAD分别为同一类型的操作方法，请求稍有不同但返回结果相同。下同。5.在HTTP通信中，自动化接口(get,gets,head,heads,post,put,delete) 全用HTTP POST请求。下同。6.所有JSONObject都视为容器(或者文件夹)，结构为 {…} ，里面可以放普通对象或子容器。下同。7.每个对象都有一个唯一的路径(或者叫地址)，假设对象名为refKey，则用 key0&#x2F;key1&#x2F;…&#x2F;refKey 表示。下同。


3.2 功能符


功能
键值对格式
使用示例



查询数组
“key[]”:{}，后面是JSONObject，key可省略。当key和里面的Table名相同时，Table会被提取出来，即 {Table:{Content}} 会被转化为 {Content}
{“User[]”:{“User”:{}}}，查询一个User数组。这里key和Table名都是User，User会被提取出来，即 {“User”:{“id”, …}} 会被转化为 {“id”, …}，如果要进一步提取User中的id，可以把User[]改为User-id[]


匹配选项范围
“key{}”:[]，后面是JSONArray，作为key可取的值的选项
“id{}”:[38710,82001,70793]，对应SQL是id IN(38710,82001,70793)，查询id符合38710,82001,70793中任意一个的一个User数组


匹配条件范围
“key{}”:”条件0,条件1…”，条件为SQL表达式字符串，可进行数字比较运算等
“id{}”:”&lt;&#x3D;80000,&gt;90000”，对应SQL是id&lt;&#x3D;80000 OR id&gt;90000，查询id符合id&lt;&#x3D;80000 | id&gt;90000的一个User数组


包含选项范围
“key&lt;&gt;“:Object  &#x3D;&gt;  “key&lt;&gt;“:[Object]，key对应值的类型必须为JSONArray，Object类型不能为JSON
“contactIdList&lt;&gt;“:38710，对应SQL是json_contains(contactIdList,38710)，查询contactIdList包含38710的一个User数组


判断是否存在
“key}{@”:{    “from”:”Table”,    “Table”:{ … }}其中：}{ 表示 EXISTS； key 用来标识是哪个判断； @ 后面是 子查询 对象，具体见下方 子查询 的说明。
“id}{@”:{    “from”:”Comment”,    “Comment”:{        “momentId”:15     }} WHERE EXISTS(SELECT * FROM Comment WHERE momentId&#x3D;15)


远程调用函数
“key()”:”函数表达式”，函数表达式为 function(key0,key1…)，会调用后端对应的函数 function(JSONObject request, String key0, String key1…)，实现 参数校验、数值计算、数据同步、消息推送、字段拼接、结构变换 等特定的业务逻辑处理，可使用 - 和 + 表示优先级，解析 key-() &gt; 解析当前对象 &gt; 解析 key() &gt; 解析子对象 &gt; 解析 key+()
“isPraised()”:”isContain(praiseUserIdList,userId)”，会调用远程函数 boolean isContain(JSONObject request, String array, String value) ，然后变为 “isPraised”:true 这种（假设点赞用户id列表包含了userId，即这个User点了赞）


存储过程
“@key()”:”SQL函数表达式”，函数表达式为   function(key0,key1…)  会调用后端数据库对应的存储过程 SQL函数  function(String key0, String key1…)  除了参数会提前赋值，其它和 远程函数 一致
“@limit”:10,  “@offset”:0,  “@procedure()”:”getCommentByUserId(id,@limit,@offset)”  会转为  getCommentByUserId(38710,10,0)  来调用存储过程 SQL 函数  getCommentByUserId(IN id bigint, IN limit int, IN offset int)  然后变为 “procedure”:{    “count”:-1,     “update”:false,     “list”:[]  }  其中 count 是指写操作影响记录行数，-1 表示不是写操作；update 是指是否为写操作（增删改）；list 为返回结果集


引用赋值
“key@”:”key0&#x2F;key1&#x2F;…&#x2F;refKey”，引用路径为用&#x2F;分隔的字符串。以&#x2F;开头的是缺省引用路径，从声明key所处容器的父容器路径开始；其它是完整引用路径，从最外层开始。 被引用的refKey必须在声明key的上面。如果对refKey的容器指定了返回字段，则被引用的refKey必须写在@column对应的值内，例如 “@column”:”refKey,key1,…”
“Moment”:{    “userId”:38710},“User”:{    “id@”:”&#x2F;Moment&#x2F;userId”} User内的id引用了与User同级的Moment内的userId，即User.id &#x3D; Moment.userId，请求完成后 “id@”:”&#x2F;Moment&#x2F;userId” 会变成 “id”:38710


子查询
“key@”:{    “range”:”ALL”,     “from”:”Table”,    “Table”:{ … }}其中：range 可为 ALL,ANY；from 为目标表 Table 的名称；@ 后面的对象类似数组对象，可使用 count 和 join 等功能。
“id@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&#x3D;(SELECT min(userId) FROM Comment)


模糊搜索
&quot;key$&quot;:&quot;SQL搜索表达式&quot;  &#x3D;&gt;  &quot;key$&quot;:[&quot;SQL搜索表达式&quot;]，任意SQL搜索表达式字符串，如 %key%(包含key), key%(以key开始), %k%e%y%(包含字母k,e,y) 等，%表示任意字符
“name$”:”%m%”，对应SQL是name LIKE &#39;%m%&#39;，查询name包含”m”的一个User数组


正则匹配
“key“:”正则表达式”  &#x3D;&gt;  “key“:[“正则表达式”]，任意正则表达式字符串，如 ^[0-9]+$ ，*~ 忽略大小写，可用于高级搜索
“name~”:”^[0-9]+$”，对应SQL是name REGEXP &#39;^[0-9]+$&#39;，查询name中字符全为数字的一个User数组


连续范围
“key%”:”start,end”  &#x3D;&gt;  “key%”:[“start,end”]，其中 start 和 end 都只能为 Boolean, Number, String 中的一种，如 “2017-01-01,2019-01-01” ，[“1,90000”, “82001,100000”] ，可用于连续范围内的筛选
“date%”:”2017-10-01,2018-10-01”，对应SQL是date BETWEEN &#39;2017-10-01&#39; AND &#39;2018-10-01&#39;，查询在2017-10-01和2018-10-01期间注册的用户的一个User数组


新建别名
“name:alias”，name映射为alias，用alias替代name。可用于 column,Table,SQL函数 等。只用于GET类型、HEAD类型的请求
“@column”:”toId:parentId”，对应SQL是toId AS parentId，将查询的字段toId变为parentId返回


增加 或 扩展
“key+”:Object，Object的类型由key指定，且类型为Number,String,JSONArray中的一种。如 82001,”apijson”,[“url0”,”url1”] 等。只用于PUT请求
“praiseUserIdList+”:[82001]，对应SQL是json_insert(praiseUserIdList,82001)，添加一个点赞用户id，即这个用户点了赞


减少 或 去除
“key-“:Object，与”key+”相反
“balance-“:100.00，对应SQL是balance &#x3D; balance - 100.00，余额减少100.00，即花费了100元


比较运算
&gt;, &lt;, &gt;&#x3D;, &lt;&#x3D; 比较运算符，用于 ① 提供 “id{}”:”&lt;&#x3D;90000” 这种条件范围的简化写法 ② 实现子查询相关比较运算不支持 “key&#x3D;”:Object 和 “key!&#x3D;”:Object 这两种写法，直接用更简单的 “key”:Object 和 “key!”:Object 替代。
① “id&lt;&#x3D;”:90000，对应SQL是id&lt;&#x3D;90000，查询符合id&lt;&#x3D;90000的一个User数组 ② “id&gt;@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&gt;(SELECT min(userId) FROM Comment)


逻辑运算
&amp;, |, ! 逻辑运算符，对应数据库 SQL 中的 AND, OR, NOT。 横或纵与：同一键值对的值内条件默认 | 或连接，可以在 key 后加逻辑运算符来具体指定；不同键值对的条件默认 &amp; 与连接，可以用下面说明的对象关键词 @combine 来具体指定。 ① &amp; 可用于”key&amp;{}”:”条件”等② | 可用于”key|{}”:”条件”, “key|{}”:[]等，一般可省略③ ! 可单独使用，如”key!”:Object，也可像&amp;,|一样配合其他功能符使用  “key!”:null 无效，null 值会导致整个键值对被忽略解析，可以用 “key{}”:”!&#x3D;null” 替代，“key”:null 同理，用 “key{}”:”&#x3D;null” 替代。
① “id&amp;{}”:”&gt;80000,&lt;&#x3D;90000”，对应SQL是id&gt;80000 AND id&lt;&#x3D;90000，即id满足id&gt;80000 &amp; id&lt;&#x3D;90000 ② “id|{}”:”&gt;90000,&lt;&#x3D;80000”，同”id{}”:”&gt;90000,&lt;&#x3D;80000”，对应SQL是id&gt;80000 OR id&lt;&#x3D;90000，即id满足id&gt;90000 | id&lt;&#x3D;80000 ③ “id!{}”:[82001,38710]，对应SQL是id NOT IN(82001,38710)，即id满足 ! (id&#x3D;82001 | id&#x3D;38710)，可过滤黑名单的消息


数组关键词，可自定义
“key”:Object，key为 “[]”:{} 中{}内的关键词，Object的类型由key指定① “count”:Integer，查询数量，0 表示最大值，默认最大值为100 ② “page”:Integer，查询页码，从0开始，默认最大值为100，一般和count一起用③ “query”:Integer，查询内容0-对象，1-总数和分页详情，2-数据、总数和分页详情总数关键词为 total，分页详情关键词为 info， 它们都和 query 同级，通过引用赋值得到，例如  “total@”:”&#x2F;[]&#x2F;total”, “info@”:”&#x2F;[]&#x2F;info” 这里query及total仅为GET类型的请求提供方便， 一般可直接用HEAD类型的请求获取总数④ “join”:”&amp;&#x2F;Table0,&lt;&#x2F;Table1&#x2F;key1@” 或 “join”:{    “&amp;&#x2F;Table0”:{},  &#x2F;&#x2F; 支持 ON 多个字段关联,    “&lt;&#x2F;Table1&#x2F;key1@”:{  &#x2F;&#x2F; ON 只允许指定的 key1 关联      “key0”:value0,  &#x2F;&#x2F; 其它ON条件       “key2”:value2,      …       “@combine”:”…”,  &#x2F;&#x2F; 其它ON条件的组合方式       “@column”:”…”,  &#x2F;&#x2F; 外层 SELECT       “@group”:”…”,  &#x2F;&#x2F; 外层 GROUP BY       “@having”:”…”  &#x2F;&#x2F; 外层 HAVING     }}多表连接方式：  “@” - APP JOIN  “&lt;“ - LEFT JOIN  “&gt;” - RIGHT JOIN  “&amp;” - INNER JOIN  “|” - FULL JOIN   “!” - OUTER JOIN   “*” - CROSS JOIN   “^” - SIDE JOIN   “(“ - ANTI JOIN   “)” - FOREIGN JOIN 其中 @ APP JOIN 为应用层连表，会从已查出的主表里取得所有副表 key@ 关联的主表内的 refKey 作为一个数组 refKeys: [value0, value1…]，然后把原来副表 count 次查询 key&#x3D;$refKey 的 SQL 用 key IN($refKeys) 的方式合并为一条 SQL 来优化性能； 其它 JOIN 都是 SQL JOIN，具体功能和 MySQL,PostgreSQL 等数据库的 JOIN 一一对应 &quot;join&quot;:&quot;&lt;&#x2F;ViceTable&#x2F;key@&quot;,&quot;MainTable&quot;:{},&quot;ViceTable&quot;:{&quot;key@&quot;:&quot;&#x2F;MainTable&#x2F;refKey&quot;}会对应生成 MainTable LEFT JOIN ViceTable ON ViceTable.key&#x3D;MainTable.refKey AND 其它ON条件  除了 &#x3D; 等价关联，也支持 ! 不等关联、&gt; &lt; &gt;&#x3D; &lt;&#x3D; 等比较关联和 $ ~ {} &lt;&gt; 等其它复杂关联方式 ⑤ “otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 查询User数组，最多5个：“count”:5对应SQL是LIMIT 5  ② 查询第3页的User数组，每页5个：“count”:5,“page”:3对应SQL是LIMIT 5 OFFSET 15  ③ 查询User数组和对应的User总数：“[]”:{    “query”:2,    “User”:{}},“total@”:”&#x2F;[]&#x2F;total”,“info@”:”&#x2F;[]&#x2F;info” 返回的数据中，总数及分页详情结构为：   “total”:139,  &#x2F;&#x2F;总数  “info”:{  &#x2F;&#x2F;分页详情     “total”:139,  &#x2F;&#x2F;总数     “count”:5,  &#x2F;&#x2F;每页数量     “page”:0,  &#x2F;&#x2F;当前页码     “max”:27,  &#x2F;&#x2F;最大页码     “more”:true,  &#x2F;&#x2F;是否还有更多     “first”:true,  &#x2F;&#x2F;是否为首页     “last”:false  &#x2F;&#x2F;是否为尾页 }  ④ Moment INNER JOIN User LEFT JOIN Comment：“[]”:{    “join”:”&amp;&#x2F;User&#x2F;id@,&lt;&#x2F;Comment”,    “Moment”:{     “@group”:”id”  &#x2F;&#x2F;主副表不是一对一，要去除重复数据   },    “User”:{      “name~”:”t”,      “id@”:”&#x2F;Moment&#x2F;userId”    },    “Comment”:{      “momentId@”:”&#x2F;Moment&#x2F;id”    }} ⑤ 每一层都加当前用户名：“User”:{},“[]”:{    “name@”:”User&#x2F;name”, &#x2F;&#x2F;自定义关键词    “Moment”:{}}


对象关键词，可自定义
“@key”:Object，@key为 Table:{} 中{}内的关键词，Object的类型由@key指定① “@combine”:”key0 | (key1 &amp; (key2 | !key3))…”，条件组合方式，最终按  (其它key条件 AND 连接) AND (key0条件 OR (key1条件 AND (key2条件 OR (NOT key3条件)))) 这种方式连接，其中 “其它key” 是指与 @combine 在同一对象，且未被它声明的条件 key，默认都是 &amp; 连接。注意不要缺少或多余任何一个空格。 ② “@column”:”column;function(arg)…”，返回字段③ “@order”:”column0+,column1-…”，排序方式④ “@group”:”column0,column1…”，分组方式。如果@column里声明了Table的id，则id也必须在@group中声明；其它情况下必须满足至少一个条件:1.分组的key在@column里声明2.Table主键在@group中声明 ⑤ “@having”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…” &#x2F;&#x2F; OR 连接，或 “@having&amp;”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…”  &#x2F;&#x2F; AND 连接，或 “@having”:{   “h0”:”function0(…)?value0”,   “h1”:function1(…)?value1”,   “h2”:function2(…)?value2…”,   “@combine”:”h0 &amp; (h1 | !h2)”  &#x2F;&#x2F; 任意组合，非必传}SQL函数条件，一般和@group一起用，函数一般在@column里声明⑥ “@schema”:”sys”，集合空间(数据库名&#x2F;模式)，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑦ “@database”:”POSTGRESQL”，数据库类型，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑧ “@datasource”:”DRUID”，跨数据源，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑨ “@json”:”key0,key1…”，转为 JSON 格式返回，符合 JSONObject 则转为 {…}，符合 JSONArray 则转为 […] ⑩ “@role”:”OWNER”，来访角色，包括UNKNOWN,LOGIN,CONTACT,CIRCLE,OWNER,ADMIN，可以在最外层作为全局默认配置，可自定义其它角色并重写 Verifier.verify 等相关方法来自定义校验 ⑪ “@explain”:true，性能分析，可以在最外层作为全局默认配置 ⑫ “@raw”:”key0,key1…”，其中 key0, key1 都对应有键值对 “key0”:”SQL片段或SQL片段的别名”,  “key1”:”SQL片段或SQL片段的别名”  自定义原始SQL片段，可扩展嵌套SQL函数等复杂语句，必须是后端已配置的，只有其它功能符都做不到才考虑，谨慎使用，注意防SQL注入⑬ “@otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 搜索name或tag任何一个字段包含字符a的User列表： “name“:”a”,“tag“:”a”,“@combine”:”name~ | tag~” 对应SQL是name REGEXP &#39;a&#39; OR tag REGEXP &#39;a&#39;  ② 只查询id,sex,name这几列并且请求结果也按照这个顺序：“@column”:”id,sex,name”对应SQL是SELECT id,sex,name  ③ 查询按 name降序、id默认顺序 排序的User数组：“@order”:”name-,id”对应SQL是ORDER BY name DESC,id  ④ 查询按userId分组的Moment数组：“@group”:”userId,id”对应SQL是GROUP BY userId,id  ⑤ 查询 按userId分组、id最大值&gt;&#x3D;100 的Moment数组：“@column”:”userId;max(id)”,“@group”:”userId”,“@having”:”max(id)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) ... GROUP BY userId HAVING max(id)&gt;&#x3D;100 还可以指定函数返回名：“@column”:”userId;max(id):maxId”,“@group”:”userId”,“@having”:”(maxId)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) AS maxId ... GROUP BY userId HAVING (maxId)&gt;&#x3D;100  ⑥ 查询 sys 内的 User 表：“@schema”:”sys”对应SQL是FROM sys.User  ⑦ 查询 PostgreSQL 数据库的 User 表：“@database”:”POSTGRESQL” ⑧ 使用 Druid 连接池查询 User 表：“@datasource”:”DRUID” ⑨ 将 VARCHAR 字符串字段 get 转为 JSONArray 返回：“@json”:”get” ⑩ 查询当前用户的动态：“@role”:”OWNER” ⑪ 开启性能分析：“@explain”:true对应SQL是EXPLAIN  ⑫ 统计最近一周偶数userId的数量“@column”:”date;left(date,10):day;sum(if(userId%2&#x3D;0,1,0))”,“@group”:”day”,“@having”:”to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7”,“@raw”:”@column,@having”对应SQL是SELECT date, left(date,10) AS day, sum(if(userId%2&#x3D;0,1,0)) ... GROUP BY day HAVING to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7  ⑬ 从pictureList获取第0张图片：“@position”:0, &#x2F;&#x2F;自定义关键词“firstPicture()”:”getFromArray(pictureList,@position)”


全局关键词
为最外层对象 {} 内的关键词。其中 @database，@schema, @datasource, @role, @explain 基本同对象关键词，见上方说明，区别是全局关键词会每个表对象中没有时自动放入，作为默认值。 ① “tag”:String，后面的 tag 是非 GET、HEAD 请求中匹配请求的 JSON 结构的标识，一般是要查询的 Table 的名称或该名称对应的数组 Table[] 或 Table:[]，由后端 Request 表中指定。 ② “version”:Integer，接口版本，version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本，由后端 Request 表中指定。③ “format”:Boolean，格式化返回 Response JSON 的 key，一般是将 TableName 转为 tableName, TableName[] 转为 tableNameList, Table:alias 转为 alias, TableName-key[] 转为 tableNameKeyList 等小驼峰格式。
①  查隐私信息：[{“tag”:”Privacy”,”Privacy”:{“id”:82001}}](http:&#x2F;&#x2F;apijson.cn&#x2F;api?url&#x3D;http%3A%2F%2Fapijson.cn%3A8080%2Fgets&amp;type&#x3D;JSON&amp;json&#x3D;


</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3"><span class="toc-number">1.9.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.1.</span> <span class="toc-text">3.1 操作方法


方法及说明
URL
Request
Response



GET:  普通获取数据， 可用浏览器调试
base_url&#x2F;get&#x2F;
{    TableName:{      …     }}  {…}内为限制条件 例如获取一个 id &#x3D; 235 的 Moment： {    “Moment”:{      “id”:235    }}  后端校验通过后自动解析为 SQL 并执行：SELECT * FROM Moment WHERE id&#x3D;235 LIMIT 1
{    TableName:{      …    },    “code”:200,    “msg”:”success”}例如{    “Moment”:{      “id”:235,      “userId”:38710,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “code”:200,    “msg”:”success” }


HEAD:  普通获取数量， 可用浏览器调试
base_url&#x2F;head&#x2F;
{    TableName:{      …    } }  {…}内为限制条件  例如获取一个 id &#x3D; 38710 的 User 所发布的 Moment 总数： {    “Moment”:{      “userId”:38710    }}  后端校验通过后自动解析为 SQL 并执行：SELECT count(*) FROM Moment WHERE userId&#x3D;38710 LIMIT 1
{    TableName:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,    “msg”:”success”}  例如{    “Moment”:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,     “msg”:”success”}


GETS:  安全&#x2F;私密获取数据， 用于获取钱包等对安全性要求高的数据
base_url&#x2F;gets&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Privacy”，其它同GET
同GET


HEADS:  安全&#x2F;私密获取数量， 用于获取银行卡数量等对安全性要求高的数据总数
base_url&#x2F;heads&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Verify”，其它同HEAD
同HEAD


POST:  新增数据
base_url&#x2F;post&#x2F;
单个：  {    TableName:{      …    },    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 38710 发布一个新 Comment：{    “Comment”:{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”     },    “tag”:”Comment”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(38710,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;)    批量：  {    TableName[]:[{        …      }, {        …      }      …    ],    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 82001 发布 2 个 Comment：{    “Comment[]”:[{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”      }, {      “momentId”:15,      “content”:”APIJSON is a JSON transmision protocol.”    }],    “tag”:”Comment:[]”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(82001,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;);INSERT INTO Comment(userId,momentId,content) VALUES(82001,15,&#39;APIJSON is a JSON transmision protocol.&#39;);
单个：  {    TableName:{      “code”:200,      “msg”:”success”,      “id”:38710    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “id”:120    },    “code”:200,    “msg”:”success”}   批量：  {    TableName:{      “code”:200,      “msg”:”success”,      “count”:5,      “id[]”:[1, 2, 3, 4, 5]    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “count”:2,      “id[]”:[1, 2]    },    “code”:200,    “msg”:”success”}


PUT:  修改数据， 只修改所传的字段
base_url&#x2F;put&#x2F;
{    TableName:{      “id”:id,      …    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个 例如当前登录用户 82001 修改 id &#x3D; 235 的 Moment 的 content：{    “Moment”:{      “id”:235,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “tag”:”Moment”}  后端校验通过后自动解析为 SQL 并执行：UPDATE Moment SET content&#x3D;&#39;APIJSON,let interfaces and documents go to hell !&#39; WHERE id&#x3D;235 AND userId&#x3D;82001 LIMIT 1  批量除了 id{}:[] 也可类似批量 POST，只是每个 {…} 里面都必须有 id。“tag”:”Comment[]” 对应对象 “Comment”:{“id{}”:[1,2,3]}，表示指定记录全部统一设置；“tag”:”Comment:[]” 多了冒号，对应数组 “Comment[]”:[{“id”:1},{“id”:2},{“id”:3}]，表示每项单独设置
同POST


DELETE:  删除数据
base_url&#x2F;delete&#x2F;
{    TableName:{      “id”:id    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个，一般只传 id 或 id{} 例如当前登录用户 82001 批量删除 id &#x3D; 100,110,120 的 Comment：{    “Comment”:{      “id{}”:[100,110,120]    },    “tag”:”Comment[]”}  后端校验通过后自动解析为 SQL 并执行：DELETE FROM Comment WHERE id IN(100,110,120) AND userId&#x3D;82001 LIMIT 3
{    TableName:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120]      “count”:3    },    “code”:200,    “msg”:”success”}例如{   “Comment”:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120],      “count”:3   },   “code”:200,   “msg”:”success”}


以上接口的简单形式:  base_url&#x2F;{method}&#x2F;{tag}
GET: 普通获取数据  base_url&#x2F;get&#x2F;{tag}  HEAD: 普通获取数量  base_url&#x2F;head&#x2F;{tag}  GETS: 安全&#x2F;私密获取数据   base_url&#x2F;gets&#x2F;{tag}  HEADS: 安全&#x2F;私密获取数量  base_url&#x2F;heads&#x2F;{tag}  POST: 新增数据   base_url&#x2F;post&#x2F;{tag}  PUT: 修改数据  base_url&#x2F;put&#x2F;{tag}  DELETE: 删除数据  base_url&#x2F;delete&#x2F;{tag}
例如安全&#x2F;私密获取一个 id &#x3D; 82001 的 Privacy： base_url&#x2F;gets&#x2F;Privacy&#x2F;  {“id”:82001}  相当于  base_url&#x2F;gets&#x2F; {“tag”:”Privacy”, “Privacy”:{“id”:82001}}   例如批量修改 id &#x3D; 114, 124 的 Comment 的 content：base_url&#x2F;put&#x2F;Comemnt[]&#x2F;  {    “id{}”:[114,124],    “content”:”test multi put”}  相当于  base_url&#x2F;put&#x2F;  {    “tag”:”Comment[]”,     “Comment”:{      “id{}”:[114,124],      “content”:”test multi put”    }}
同以上对应的方法


1.TableName指要查询的数据库表Table的名称字符串。第一个字符为大写字母，剩下的字符要符合英语字母、数字、下划线中的任何一种。对应的值的类型为JSONObject，结构是 {…}，里面放的是Table的字段(列名)。下同。2.”tag”:tag 后面的tag是非GET、HEAD请求中匹配请求的JSON结构的标识，一般是要查询的Table的名称，由后端Request表中指定。下同。3.GET、HEAD请求是开放请求，可任意组合任意嵌套。其它请求为受限制的安全&#x2F;私密请求，对应的 方法（method）, 标识（tag）, 版本（version）, 结构（structure） 都必须和 后端Request表中所指定的 一一对应，否则请求将不被通过。version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本。下同。4.GETS与GET、HEADS与HEAD分别为同一类型的操作方法，请求稍有不同但返回结果相同。下同。5.在HTTP通信中，自动化接口(get,gets,head,heads,post,put,delete) 全用HTTP POST请求。下同。6.所有JSONObject都视为容器(或者文件夹)，结构为 {…} ，里面可以放普通对象或子容器。下同。7.每个对象都有一个唯一的路径(或者叫地址)，假设对象名为refKey，则用 key0&#x2F;key1&#x2F;…&#x2F;refKey 表示。下同。


3.2 功能符


功能
键值对格式
使用示例



查询数组
“key[]”:{}，后面是JSONObject，key可省略。当key和里面的Table名相同时，Table会被提取出来，即 {Table:{Content}} 会被转化为 {Content}
{“User[]”:{“User”:{}}}，查询一个User数组。这里key和Table名都是User，User会被提取出来，即 {“User”:{“id”, …}} 会被转化为 {“id”, …}，如果要进一步提取User中的id，可以把User[]改为User-id[]


匹配选项范围
“key{}”:[]，后面是JSONArray，作为key可取的值的选项
“id{}”:[38710,82001,70793]，对应SQL是id IN(38710,82001,70793)，查询id符合38710,82001,70793中任意一个的一个User数组


匹配条件范围
“key{}”:”条件0,条件1…”，条件为SQL表达式字符串，可进行数字比较运算等
“id{}”:”&lt;&#x3D;80000,&gt;90000”，对应SQL是id&lt;&#x3D;80000 OR id&gt;90000，查询id符合id&lt;&#x3D;80000 | id&gt;90000的一个User数组


包含选项范围
“key&lt;&gt;“:Object  &#x3D;&gt;  “key&lt;&gt;“:[Object]，key对应值的类型必须为JSONArray，Object类型不能为JSON
“contactIdList&lt;&gt;“:38710，对应SQL是json_contains(contactIdList,38710)，查询contactIdList包含38710的一个User数组


判断是否存在
“key}{@”:{    “from”:”Table”,    “Table”:{ … }}其中：}{ 表示 EXISTS； key 用来标识是哪个判断； @ 后面是 子查询 对象，具体见下方 子查询 的说明。
“id}{@”:{    “from”:”Comment”,    “Comment”:{        “momentId”:15     }} WHERE EXISTS(SELECT * FROM Comment WHERE momentId&#x3D;15)


远程调用函数
“key()”:”函数表达式”，函数表达式为 function(key0,key1…)，会调用后端对应的函数 function(JSONObject request, String key0, String key1…)，实现 参数校验、数值计算、数据同步、消息推送、字段拼接、结构变换 等特定的业务逻辑处理，可使用 - 和 + 表示优先级，解析 key-() &gt; 解析当前对象 &gt; 解析 key() &gt; 解析子对象 &gt; 解析 key+()
“isPraised()”:”isContain(praiseUserIdList,userId)”，会调用远程函数 boolean isContain(JSONObject request, String array, String value) ，然后变为 “isPraised”:true 这种（假设点赞用户id列表包含了userId，即这个User点了赞）


存储过程
“@key()”:”SQL函数表达式”，函数表达式为   function(key0,key1…)  会调用后端数据库对应的存储过程 SQL函数  function(String key0, String key1…)  除了参数会提前赋值，其它和 远程函数 一致
“@limit”:10,  “@offset”:0,  “@procedure()”:”getCommentByUserId(id,@limit,@offset)”  会转为  getCommentByUserId(38710,10,0)  来调用存储过程 SQL 函数  getCommentByUserId(IN id bigint, IN limit int, IN offset int)  然后变为 “procedure”:{    “count”:-1,     “update”:false,     “list”:[]  }  其中 count 是指写操作影响记录行数，-1 表示不是写操作；update 是指是否为写操作（增删改）；list 为返回结果集


引用赋值
“key@”:”key0&#x2F;key1&#x2F;…&#x2F;refKey”，引用路径为用&#x2F;分隔的字符串。以&#x2F;开头的是缺省引用路径，从声明key所处容器的父容器路径开始；其它是完整引用路径，从最外层开始。 被引用的refKey必须在声明key的上面。如果对refKey的容器指定了返回字段，则被引用的refKey必须写在@column对应的值内，例如 “@column”:”refKey,key1,…”
“Moment”:{    “userId”:38710},“User”:{    “id@”:”&#x2F;Moment&#x2F;userId”} User内的id引用了与User同级的Moment内的userId，即User.id &#x3D; Moment.userId，请求完成后 “id@”:”&#x2F;Moment&#x2F;userId” 会变成 “id”:38710


子查询
“key@”:{    “range”:”ALL”,     “from”:”Table”,    “Table”:{ … }}其中：range 可为 ALL,ANY；from 为目标表 Table 的名称；@ 后面的对象类似数组对象，可使用 count 和 join 等功能。
“id@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&#x3D;(SELECT min(userId) FROM Comment)


模糊搜索
&quot;key$&quot;:&quot;SQL搜索表达式&quot;  &#x3D;&gt;  &quot;key$&quot;:[&quot;SQL搜索表达式&quot;]，任意SQL搜索表达式字符串，如 %key%(包含key), key%(以key开始), %k%e%y%(包含字母k,e,y) 等，%表示任意字符
“name$”:”%m%”，对应SQL是name LIKE &#39;%m%&#39;，查询name包含”m”的一个User数组


正则匹配
“key“:”正则表达式”  &#x3D;&gt;  “key“:[“正则表达式”]，任意正则表达式字符串，如 ^[0-9]+$ ，*~ 忽略大小写，可用于高级搜索
“name~”:”^[0-9]+$”，对应SQL是name REGEXP &#39;^[0-9]+$&#39;，查询name中字符全为数字的一个User数组


连续范围
“key%”:”start,end”  &#x3D;&gt;  “key%”:[“start,end”]，其中 start 和 end 都只能为 Boolean, Number, String 中的一种，如 “2017-01-01,2019-01-01” ，[“1,90000”, “82001,100000”] ，可用于连续范围内的筛选
“date%”:”2017-10-01,2018-10-01”，对应SQL是date BETWEEN &#39;2017-10-01&#39; AND &#39;2018-10-01&#39;，查询在2017-10-01和2018-10-01期间注册的用户的一个User数组


新建别名
“name:alias”，name映射为alias，用alias替代name。可用于 column,Table,SQL函数 等。只用于GET类型、HEAD类型的请求
“@column”:”toId:parentId”，对应SQL是toId AS parentId，将查询的字段toId变为parentId返回


增加 或 扩展
“key+”:Object，Object的类型由key指定，且类型为Number,String,JSONArray中的一种。如 82001,”apijson”,[“url0”,”url1”] 等。只用于PUT请求
“praiseUserIdList+”:[82001]，对应SQL是json_insert(praiseUserIdList,82001)，添加一个点赞用户id，即这个用户点了赞


减少 或 去除
“key-“:Object，与”key+”相反
“balance-“:100.00，对应SQL是balance &#x3D; balance - 100.00，余额减少100.00，即花费了100元


比较运算
&gt;, &lt;, &gt;&#x3D;, &lt;&#x3D; 比较运算符，用于 ① 提供 “id{}”:”&lt;&#x3D;90000” 这种条件范围的简化写法 ② 实现子查询相关比较运算不支持 “key&#x3D;”:Object 和 “key!&#x3D;”:Object 这两种写法，直接用更简单的 “key”:Object 和 “key!”:Object 替代。
① “id&lt;&#x3D;”:90000，对应SQL是id&lt;&#x3D;90000，查询符合id&lt;&#x3D;90000的一个User数组 ② “id&gt;@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&gt;(SELECT min(userId) FROM Comment)


逻辑运算
&amp;, |, ! 逻辑运算符，对应数据库 SQL 中的 AND, OR, NOT。 横或纵与：同一键值对的值内条件默认 | 或连接，可以在 key 后加逻辑运算符来具体指定；不同键值对的条件默认 &amp; 与连接，可以用下面说明的对象关键词 @combine 来具体指定。 ① &amp; 可用于”key&amp;{}”:”条件”等② | 可用于”key|{}”:”条件”, “key|{}”:[]等，一般可省略③ ! 可单独使用，如”key!”:Object，也可像&amp;,|一样配合其他功能符使用  “key!”:null 无效，null 值会导致整个键值对被忽略解析，可以用 “key{}”:”!&#x3D;null” 替代，“key”:null 同理，用 “key{}”:”&#x3D;null” 替代。
① “id&amp;{}”:”&gt;80000,&lt;&#x3D;90000”，对应SQL是id&gt;80000 AND id&lt;&#x3D;90000，即id满足id&gt;80000 &amp; id&lt;&#x3D;90000 ② “id|{}”:”&gt;90000,&lt;&#x3D;80000”，同”id{}”:”&gt;90000,&lt;&#x3D;80000”，对应SQL是id&gt;80000 OR id&lt;&#x3D;90000，即id满足id&gt;90000 | id&lt;&#x3D;80000 ③ “id!{}”:[82001,38710]，对应SQL是id NOT IN(82001,38710)，即id满足 ! (id&#x3D;82001 | id&#x3D;38710)，可过滤黑名单的消息


数组关键词，可自定义
“key”:Object，key为 “[]”:{} 中{}内的关键词，Object的类型由key指定① “count”:Integer，查询数量，0 表示最大值，默认最大值为100 ② “page”:Integer，查询页码，从0开始，默认最大值为100，一般和count一起用③ “query”:Integer，查询内容0-对象，1-总数和分页详情，2-数据、总数和分页详情总数关键词为 total，分页详情关键词为 info， 它们都和 query 同级，通过引用赋值得到，例如  “total@”:”&#x2F;[]&#x2F;total”, “info@”:”&#x2F;[]&#x2F;info” 这里query及total仅为GET类型的请求提供方便， 一般可直接用HEAD类型的请求获取总数④ “join”:”&amp;&#x2F;Table0,&lt;&#x2F;Table1&#x2F;key1@” 或 “join”:{    “&amp;&#x2F;Table0”:{},  &#x2F;&#x2F; 支持 ON 多个字段关联,    “&lt;&#x2F;Table1&#x2F;key1@”:{  &#x2F;&#x2F; ON 只允许指定的 key1 关联      “key0”:value0,  &#x2F;&#x2F; 其它ON条件       “key2”:value2,      …       “@combine”:”…”,  &#x2F;&#x2F; 其它ON条件的组合方式       “@column”:”…”,  &#x2F;&#x2F; 外层 SELECT       “@group”:”…”,  &#x2F;&#x2F; 外层 GROUP BY       “@having”:”…”  &#x2F;&#x2F; 外层 HAVING     }}多表连接方式：  “@” - APP JOIN  “&lt;“ - LEFT JOIN  “&gt;” - RIGHT JOIN  “&amp;” - INNER JOIN  “|” - FULL JOIN   “!” - OUTER JOIN   “*” - CROSS JOIN   “^” - SIDE JOIN   “(“ - ANTI JOIN   “)” - FOREIGN JOIN 其中 @ APP JOIN 为应用层连表，会从已查出的主表里取得所有副表 key@ 关联的主表内的 refKey 作为一个数组 refKeys: [value0, value1…]，然后把原来副表 count 次查询 key&#x3D;$refKey 的 SQL 用 key IN($refKeys) 的方式合并为一条 SQL 来优化性能； 其它 JOIN 都是 SQL JOIN，具体功能和 MySQL,PostgreSQL 等数据库的 JOIN 一一对应 &quot;join&quot;:&quot;&lt;&#x2F;ViceTable&#x2F;key@&quot;,&quot;MainTable&quot;:{},&quot;ViceTable&quot;:{&quot;key@&quot;:&quot;&#x2F;MainTable&#x2F;refKey&quot;}会对应生成 MainTable LEFT JOIN ViceTable ON ViceTable.key&#x3D;MainTable.refKey AND 其它ON条件  除了 &#x3D; 等价关联，也支持 ! 不等关联、&gt; &lt; &gt;&#x3D; &lt;&#x3D; 等比较关联和 $ ~ {} &lt;&gt; 等其它复杂关联方式 ⑤ “otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 查询User数组，最多5个：“count”:5对应SQL是LIMIT 5  ② 查询第3页的User数组，每页5个：“count”:5,“page”:3对应SQL是LIMIT 5 OFFSET 15  ③ 查询User数组和对应的User总数：“[]”:{    “query”:2,    “User”:{}},“total@”:”&#x2F;[]&#x2F;total”,“info@”:”&#x2F;[]&#x2F;info” 返回的数据中，总数及分页详情结构为：   “total”:139,  &#x2F;&#x2F;总数  “info”:{  &#x2F;&#x2F;分页详情     “total”:139,  &#x2F;&#x2F;总数     “count”:5,  &#x2F;&#x2F;每页数量     “page”:0,  &#x2F;&#x2F;当前页码     “max”:27,  &#x2F;&#x2F;最大页码     “more”:true,  &#x2F;&#x2F;是否还有更多     “first”:true,  &#x2F;&#x2F;是否为首页     “last”:false  &#x2F;&#x2F;是否为尾页 }  ④ Moment INNER JOIN User LEFT JOIN Comment：“[]”:{    “join”:”&amp;&#x2F;User&#x2F;id@,&lt;&#x2F;Comment”,    “Moment”:{     “@group”:”id”  &#x2F;&#x2F;主副表不是一对一，要去除重复数据   },    “User”:{      “name~”:”t”,      “id@”:”&#x2F;Moment&#x2F;userId”    },    “Comment”:{      “momentId@”:”&#x2F;Moment&#x2F;id”    }} ⑤ 每一层都加当前用户名：“User”:{},“[]”:{    “name@”:”User&#x2F;name”, &#x2F;&#x2F;自定义关键词    “Moment”:{}}


对象关键词，可自定义
“@key”:Object，@key为 Table:{} 中{}内的关键词，Object的类型由@key指定① “@combine”:”key0 | (key1 &amp; (key2 | !key3))…”，条件组合方式，最终按  (其它key条件 AND 连接) AND (key0条件 OR (key1条件 AND (key2条件 OR (NOT key3条件)))) 这种方式连接，其中 “其它key” 是指与 @combine 在同一对象，且未被它声明的条件 key，默认都是 &amp; 连接。注意不要缺少或多余任何一个空格。 ② “@column”:”column;function(arg)…”，返回字段③ “@order”:”column0+,column1-…”，排序方式④ “@group”:”column0,column1…”，分组方式。如果@column里声明了Table的id，则id也必须在@group中声明；其它情况下必须满足至少一个条件:1.分组的key在@column里声明2.Table主键在@group中声明 ⑤ “@having”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…” &#x2F;&#x2F; OR 连接，或 “@having&amp;”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…”  &#x2F;&#x2F; AND 连接，或 “@having”:{   “h0”:”function0(…)?value0”,   “h1”:function1(…)?value1”,   “h2”:function2(…)?value2…”,   “@combine”:”h0 &amp; (h1 | !h2)”  &#x2F;&#x2F; 任意组合，非必传}SQL函数条件，一般和@group一起用，函数一般在@column里声明⑥ “@schema”:”sys”，集合空间(数据库名&#x2F;模式)，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑦ “@database”:”POSTGRESQL”，数据库类型，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑧ “@datasource”:”DRUID”，跨数据源，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑨ “@json”:”key0,key1…”，转为 JSON 格式返回，符合 JSONObject 则转为 {…}，符合 JSONArray 则转为 […] ⑩ “@role”:”OWNER”，来访角色，包括UNKNOWN,LOGIN,CONTACT,CIRCLE,OWNER,ADMIN，可以在最外层作为全局默认配置，可自定义其它角色并重写 Verifier.verify 等相关方法来自定义校验 ⑪ “@explain”:true，性能分析，可以在最外层作为全局默认配置 ⑫ “@raw”:”key0,key1…”，其中 key0, key1 都对应有键值对 “key0”:”SQL片段或SQL片段的别名”,  “key1”:”SQL片段或SQL片段的别名”  自定义原始SQL片段，可扩展嵌套SQL函数等复杂语句，必须是后端已配置的，只有其它功能符都做不到才考虑，谨慎使用，注意防SQL注入⑬ “@otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 搜索name或tag任何一个字段包含字符a的User列表： “name“:”a”,“tag“:”a”,“@combine”:”name~ | tag~” 对应SQL是name REGEXP &#39;a&#39; OR tag REGEXP &#39;a&#39;  ② 只查询id,sex,name这几列并且请求结果也按照这个顺序：“@column”:”id,sex,name”对应SQL是SELECT id,sex,name  ③ 查询按 name降序、id默认顺序 排序的User数组：“@order”:”name-,id”对应SQL是ORDER BY name DESC,id  ④ 查询按userId分组的Moment数组：“@group”:”userId,id”对应SQL是GROUP BY userId,id  ⑤ 查询 按userId分组、id最大值&gt;&#x3D;100 的Moment数组：“@column”:”userId;max(id)”,“@group”:”userId”,“@having”:”max(id)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) ... GROUP BY userId HAVING max(id)&gt;&#x3D;100 还可以指定函数返回名：“@column”:”userId;max(id):maxId”,“@group”:”userId”,“@having”:”(maxId)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) AS maxId ... GROUP BY userId HAVING (maxId)&gt;&#x3D;100  ⑥ 查询 sys 内的 User 表：“@schema”:”sys”对应SQL是FROM sys.User  ⑦ 查询 PostgreSQL 数据库的 User 表：“@database”:”POSTGRESQL” ⑧ 使用 Druid 连接池查询 User 表：“@datasource”:”DRUID” ⑨ 将 VARCHAR 字符串字段 get 转为 JSONArray 返回：“@json”:”get” ⑩ 查询当前用户的动态：“@role”:”OWNER” ⑪ 开启性能分析：“@explain”:true对应SQL是EXPLAIN  ⑫ 统计最近一周偶数userId的数量“@column”:”date;left(date,10):day;sum(if(userId%2&#x3D;0,1,0))”,“@group”:”day”,“@having”:”to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7”,“@raw”:”@column,@having”对应SQL是SELECT date, left(date,10) AS day, sum(if(userId%2&#x3D;0,1,0)) ... GROUP BY day HAVING to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7  ⑬ 从pictureList获取第0张图片：“@position”:0, &#x2F;&#x2F;自定义关键词“firstPicture()”:”getFromArray(pictureList,@position)”


全局关键词
为最外层对象 {} 内的关键词。其中 @database，@schema, @datasource, @role, @explain 基本同对象关键词，见上方说明，区别是全局关键词会每个表对象中没有时自动放入，作为默认值。 ① “tag”:String，后面的 tag 是非 GET、HEAD 请求中匹配请求的 JSON 结构的标识，一般是要查询的 Table 的名称或该名称对应的数组 Table[] 或 Table:[]，由后端 Request 表中指定。 ② “version”:Integer，接口版本，version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本，由后端 Request 表中指定。③ “format”:Boolean，格式化返回 Response JSON 的 key，一般是将 TableName 转为 tableName, TableName[] 转为 tableNameList, Table:alias 转为 alias, TableName-key[] 转为 tableNameKeyList 等小驼峰格式。
①  查隐私信息：[{“tag”:”Privacy”,”Privacy”:{“id”:82001}}](http:&#x2F;&#x2F;apijson.cn&#x2F;api?url&#x3D;http%3A%2F%2Fapijson.cn%3A8080%2Fgets&amp;type&#x3D;JSON&amp;json&#x3D;


</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3.1"><span class="toc-number">1.9.2.</span> <span class="toc-text">3.1 操作方法


方法及说明
URL
Request
Response



GET:  普通获取数据， 可用浏览器调试
base_url&#x2F;get&#x2F;
{    TableName:{      …     }}  {…}内为限制条件 例如获取一个 id &#x3D; 235 的 Moment： {    “Moment”:{      “id”:235    }}  后端校验通过后自动解析为 SQL 并执行：SELECT * FROM Moment WHERE id&#x3D;235 LIMIT 1
{    TableName:{      …    },    “code”:200,    “msg”:”success”}例如{    “Moment”:{      “id”:235,      “userId”:38710,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “code”:200,    “msg”:”success” }


HEAD:  普通获取数量， 可用浏览器调试
base_url&#x2F;head&#x2F;
{    TableName:{      …    } }  {…}内为限制条件  例如获取一个 id &#x3D; 38710 的 User 所发布的 Moment 总数： {    “Moment”:{      “userId”:38710    }}  后端校验通过后自动解析为 SQL 并执行：SELECT count(*) FROM Moment WHERE userId&#x3D;38710 LIMIT 1
{    TableName:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,    “msg”:”success”}  例如{    “Moment”:{      “code”:200,      “msg”:”success”,      “count”:10    },    “code”:200,     “msg”:”success”}


GETS:  安全&#x2F;私密获取数据， 用于获取钱包等对安全性要求高的数据
base_url&#x2F;gets&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Privacy”，其它同GET
同GET


HEADS:  安全&#x2F;私密获取数量， 用于获取银行卡数量等对安全性要求高的数据总数
base_url&#x2F;heads&#x2F;
最外层加一个 “tag”:tag，例如 “tag”:”Verify”，其它同HEAD
同HEAD


POST:  新增数据
base_url&#x2F;post&#x2F;
单个：  {    TableName:{      …    },    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 38710 发布一个新 Comment：{    “Comment”:{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”     },    “tag”:”Comment”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(38710,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;)    批量：  {    TableName[]:[{        …      }, {        …      }      …    ],    “tag”:tag}  {…}中id由后端生成，不能传 例如当前登录用户 82001 发布 2 个 Comment：{    “Comment[]”:[{      “momentId”:12,      “content”:”APIJSON,let interfaces and documents go to hell !”      }, {      “momentId”:15,      “content”:”APIJSON is a JSON transmision protocol.”    }],    “tag”:”Comment:[]”}  后端校验通过后自动解析为 SQL 并执行：INSERT INTO Comment(userId,momentId,content) VALUES(82001,12,&#39;APIJSON,let interfaces and documents go to hell !&#39;);INSERT INTO Comment(userId,momentId,content) VALUES(82001,15,&#39;APIJSON is a JSON transmision protocol.&#39;);
单个：  {    TableName:{      “code”:200,      “msg”:”success”,      “id”:38710    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “id”:120    },    “code”:200,    “msg”:”success”}   批量：  {    TableName:{      “code”:200,      “msg”:”success”,      “count”:5,      “id[]”:[1, 2, 3, 4, 5]    },    “code”:200,    “msg”:”success”}例如{    “Comment”:{      “code”:200,      “msg”:”success”,      “count”:2,      “id[]”:[1, 2]    },    “code”:200,    “msg”:”success”}


PUT:  修改数据， 只修改所传的字段
base_url&#x2F;put&#x2F;
{    TableName:{      “id”:id,      …    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个 例如当前登录用户 82001 修改 id &#x3D; 235 的 Moment 的 content：{    “Moment”:{      “id”:235,      “content”:”APIJSON,let interfaces and documents go to hell !”    },    “tag”:”Moment”}  后端校验通过后自动解析为 SQL 并执行：UPDATE Moment SET content&#x3D;&#39;APIJSON,let interfaces and documents go to hell !&#39; WHERE id&#x3D;235 AND userId&#x3D;82001 LIMIT 1  批量除了 id{}:[] 也可类似批量 POST，只是每个 {…} 里面都必须有 id。“tag”:”Comment[]” 对应对象 “Comment”:{“id{}”:[1,2,3]}，表示指定记录全部统一设置；“tag”:”Comment:[]” 多了冒号，对应数组 “Comment[]”:[{“id”:1},{“id”:2},{“id”:3}]，表示每项单独设置
同POST


DELETE:  删除数据
base_url&#x2F;delete&#x2F;
{    TableName:{      “id”:id    },    “tag”:tag}  {…} 中 id 或 id{} 至少传一个，一般只传 id 或 id{} 例如当前登录用户 82001 批量删除 id &#x3D; 100,110,120 的 Comment：{    “Comment”:{      “id{}”:[100,110,120]    },    “tag”:”Comment[]”}  后端校验通过后自动解析为 SQL 并执行：DELETE FROM Comment WHERE id IN(100,110,120) AND userId&#x3D;82001 LIMIT 3
{    TableName:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120]      “count”:3    },    “code”:200,    “msg”:”success”}例如{   “Comment”:{      “code”:200,      “msg”:”success”,      “id[]”:[100,110,120],      “count”:3   },   “code”:200,   “msg”:”success”}


以上接口的简单形式:  base_url&#x2F;{method}&#x2F;{tag}
GET: 普通获取数据  base_url&#x2F;get&#x2F;{tag}  HEAD: 普通获取数量  base_url&#x2F;head&#x2F;{tag}  GETS: 安全&#x2F;私密获取数据   base_url&#x2F;gets&#x2F;{tag}  HEADS: 安全&#x2F;私密获取数量  base_url&#x2F;heads&#x2F;{tag}  POST: 新增数据   base_url&#x2F;post&#x2F;{tag}  PUT: 修改数据  base_url&#x2F;put&#x2F;{tag}  DELETE: 删除数据  base_url&#x2F;delete&#x2F;{tag}
例如安全&#x2F;私密获取一个 id &#x3D; 82001 的 Privacy： base_url&#x2F;gets&#x2F;Privacy&#x2F;  {“id”:82001}  相当于  base_url&#x2F;gets&#x2F; {“tag”:”Privacy”, “Privacy”:{“id”:82001}}   例如批量修改 id &#x3D; 114, 124 的 Comment 的 content：base_url&#x2F;put&#x2F;Comemnt[]&#x2F;  {    “id{}”:[114,124],    “content”:”test multi put”}  相当于  base_url&#x2F;put&#x2F;  {    “tag”:”Comment[]”,     “Comment”:{      “id{}”:[114,124],      “content”:”test multi put”    }}
同以上对应的方法


1.TableName指要查询的数据库表Table的名称字符串。第一个字符为大写字母，剩下的字符要符合英语字母、数字、下划线中的任何一种。对应的值的类型为JSONObject，结构是 {…}，里面放的是Table的字段(列名)。下同。2.”tag”:tag 后面的tag是非GET、HEAD请求中匹配请求的JSON结构的标识，一般是要查询的Table的名称，由后端Request表中指定。下同。3.GET、HEAD请求是开放请求，可任意组合任意嵌套。其它请求为受限制的安全&#x2F;私密请求，对应的 方法（method）, 标识（tag）, 版本（version）, 结构（structure） 都必须和 后端Request表中所指定的 一一对应，否则请求将不被通过。version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本。下同。4.GETS与GET、HEADS与HEAD分别为同一类型的操作方法，请求稍有不同但返回结果相同。下同。5.在HTTP通信中，自动化接口(get,gets,head,heads,post,put,delete) 全用HTTP POST请求。下同。6.所有JSONObject都视为容器(或者文件夹)，结构为 {…} ，里面可以放普通对象或子容器。下同。7.每个对象都有一个唯一的路径(或者叫地址)，假设对象名为refKey，则用 key0&#x2F;key1&#x2F;…&#x2F;refKey 表示。下同。


3.2 功能符


功能
键值对格式
使用示例



查询数组
“key[]”:{}，后面是JSONObject，key可省略。当key和里面的Table名相同时，Table会被提取出来，即 {Table:{Content}} 会被转化为 {Content}
{“User[]”:{“User”:{}}}，查询一个User数组。这里key和Table名都是User，User会被提取出来，即 {“User”:{“id”, …}} 会被转化为 {“id”, …}，如果要进一步提取User中的id，可以把User[]改为User-id[]


匹配选项范围
“key{}”:[]，后面是JSONArray，作为key可取的值的选项
“id{}”:[38710,82001,70793]，对应SQL是id IN(38710,82001,70793)，查询id符合38710,82001,70793中任意一个的一个User数组


匹配条件范围
“key{}”:”条件0,条件1…”，条件为SQL表达式字符串，可进行数字比较运算等
“id{}”:”&lt;&#x3D;80000,&gt;90000”，对应SQL是id&lt;&#x3D;80000 OR id&gt;90000，查询id符合id&lt;&#x3D;80000 | id&gt;90000的一个User数组


包含选项范围
“key&lt;&gt;“:Object  &#x3D;&gt;  “key&lt;&gt;“:[Object]，key对应值的类型必须为JSONArray，Object类型不能为JSON
“contactIdList&lt;&gt;“:38710，对应SQL是json_contains(contactIdList,38710)，查询contactIdList包含38710的一个User数组


判断是否存在
“key}{@”:{    “from”:”Table”,    “Table”:{ … }}其中：}{ 表示 EXISTS； key 用来标识是哪个判断； @ 后面是 子查询 对象，具体见下方 子查询 的说明。
“id}{@”:{    “from”:”Comment”,    “Comment”:{        “momentId”:15     }} WHERE EXISTS(SELECT * FROM Comment WHERE momentId&#x3D;15)


远程调用函数
“key()”:”函数表达式”，函数表达式为 function(key0,key1…)，会调用后端对应的函数 function(JSONObject request, String key0, String key1…)，实现 参数校验、数值计算、数据同步、消息推送、字段拼接、结构变换 等特定的业务逻辑处理，可使用 - 和 + 表示优先级，解析 key-() &gt; 解析当前对象 &gt; 解析 key() &gt; 解析子对象 &gt; 解析 key+()
“isPraised()”:”isContain(praiseUserIdList,userId)”，会调用远程函数 boolean isContain(JSONObject request, String array, String value) ，然后变为 “isPraised”:true 这种（假设点赞用户id列表包含了userId，即这个User点了赞）


存储过程
“@key()”:”SQL函数表达式”，函数表达式为   function(key0,key1…)  会调用后端数据库对应的存储过程 SQL函数  function(String key0, String key1…)  除了参数会提前赋值，其它和 远程函数 一致
“@limit”:10,  “@offset”:0,  “@procedure()”:”getCommentByUserId(id,@limit,@offset)”  会转为  getCommentByUserId(38710,10,0)  来调用存储过程 SQL 函数  getCommentByUserId(IN id bigint, IN limit int, IN offset int)  然后变为 “procedure”:{    “count”:-1,     “update”:false,     “list”:[]  }  其中 count 是指写操作影响记录行数，-1 表示不是写操作；update 是指是否为写操作（增删改）；list 为返回结果集


引用赋值
“key@”:”key0&#x2F;key1&#x2F;…&#x2F;refKey”，引用路径为用&#x2F;分隔的字符串。以&#x2F;开头的是缺省引用路径，从声明key所处容器的父容器路径开始；其它是完整引用路径，从最外层开始。 被引用的refKey必须在声明key的上面。如果对refKey的容器指定了返回字段，则被引用的refKey必须写在@column对应的值内，例如 “@column”:”refKey,key1,…”
“Moment”:{    “userId”:38710},“User”:{    “id@”:”&#x2F;Moment&#x2F;userId”} User内的id引用了与User同级的Moment内的userId，即User.id &#x3D; Moment.userId，请求完成后 “id@”:”&#x2F;Moment&#x2F;userId” 会变成 “id”:38710


子查询
“key@”:{    “range”:”ALL”,     “from”:”Table”,    “Table”:{ … }}其中：range 可为 ALL,ANY；from 为目标表 Table 的名称；@ 后面的对象类似数组对象，可使用 count 和 join 等功能。
“id@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&#x3D;(SELECT min(userId) FROM Comment)


模糊搜索
&quot;key$&quot;:&quot;SQL搜索表达式&quot;  &#x3D;&gt;  &quot;key$&quot;:[&quot;SQL搜索表达式&quot;]，任意SQL搜索表达式字符串，如 %key%(包含key), key%(以key开始), %k%e%y%(包含字母k,e,y) 等，%表示任意字符
“name$”:”%m%”，对应SQL是name LIKE &#39;%m%&#39;，查询name包含”m”的一个User数组


正则匹配
“key“:”正则表达式”  &#x3D;&gt;  “key“:[“正则表达式”]，任意正则表达式字符串，如 ^[0-9]+$ ，*~ 忽略大小写，可用于高级搜索
“name~”:”^[0-9]+$”，对应SQL是name REGEXP &#39;^[0-9]+$&#39;，查询name中字符全为数字的一个User数组


连续范围
“key%”:”start,end”  &#x3D;&gt;  “key%”:[“start,end”]，其中 start 和 end 都只能为 Boolean, Number, String 中的一种，如 “2017-01-01,2019-01-01” ，[“1,90000”, “82001,100000”] ，可用于连续范围内的筛选
“date%”:”2017-10-01,2018-10-01”，对应SQL是date BETWEEN &#39;2017-10-01&#39; AND &#39;2018-10-01&#39;，查询在2017-10-01和2018-10-01期间注册的用户的一个User数组


新建别名
“name:alias”，name映射为alias，用alias替代name。可用于 column,Table,SQL函数 等。只用于GET类型、HEAD类型的请求
“@column”:”toId:parentId”，对应SQL是toId AS parentId，将查询的字段toId变为parentId返回


增加 或 扩展
“key+”:Object，Object的类型由key指定，且类型为Number,String,JSONArray中的一种。如 82001,”apijson”,[“url0”,”url1”] 等。只用于PUT请求
“praiseUserIdList+”:[82001]，对应SQL是json_insert(praiseUserIdList,82001)，添加一个点赞用户id，即这个用户点了赞


减少 或 去除
“key-“:Object，与”key+”相反
“balance-“:100.00，对应SQL是balance &#x3D; balance - 100.00，余额减少100.00，即花费了100元


比较运算
&gt;, &lt;, &gt;&#x3D;, &lt;&#x3D; 比较运算符，用于 ① 提供 “id{}”:”&lt;&#x3D;90000” 这种条件范围的简化写法 ② 实现子查询相关比较运算不支持 “key&#x3D;”:Object 和 “key!&#x3D;”:Object 这两种写法，直接用更简单的 “key”:Object 和 “key!”:Object 替代。
① “id&lt;&#x3D;”:90000，对应SQL是id&lt;&#x3D;90000，查询符合id&lt;&#x3D;90000的一个User数组 ② “id&gt;@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&gt;(SELECT min(userId) FROM Comment)


逻辑运算
&amp;, |, ! 逻辑运算符，对应数据库 SQL 中的 AND, OR, NOT。 横或纵与：同一键值对的值内条件默认 | 或连接，可以在 key 后加逻辑运算符来具体指定；不同键值对的条件默认 &amp; 与连接，可以用下面说明的对象关键词 @combine 来具体指定。 ① &amp; 可用于”key&amp;{}”:”条件”等② | 可用于”key|{}”:”条件”, “key|{}”:[]等，一般可省略③ ! 可单独使用，如”key!”:Object，也可像&amp;,|一样配合其他功能符使用  “key!”:null 无效，null 值会导致整个键值对被忽略解析，可以用 “key{}”:”!&#x3D;null” 替代，“key”:null 同理，用 “key{}”:”&#x3D;null” 替代。
① “id&amp;{}”:”&gt;80000,&lt;&#x3D;90000”，对应SQL是id&gt;80000 AND id&lt;&#x3D;90000，即id满足id&gt;80000 &amp; id&lt;&#x3D;90000 ② “id|{}”:”&gt;90000,&lt;&#x3D;80000”，同”id{}”:”&gt;90000,&lt;&#x3D;80000”，对应SQL是id&gt;80000 OR id&lt;&#x3D;90000，即id满足id&gt;90000 | id&lt;&#x3D;80000 ③ “id!{}”:[82001,38710]，对应SQL是id NOT IN(82001,38710)，即id满足 ! (id&#x3D;82001 | id&#x3D;38710)，可过滤黑名单的消息


数组关键词，可自定义
“key”:Object，key为 “[]”:{} 中{}内的关键词，Object的类型由key指定① “count”:Integer，查询数量，0 表示最大值，默认最大值为100 ② “page”:Integer，查询页码，从0开始，默认最大值为100，一般和count一起用③ “query”:Integer，查询内容0-对象，1-总数和分页详情，2-数据、总数和分页详情总数关键词为 total，分页详情关键词为 info， 它们都和 query 同级，通过引用赋值得到，例如  “total@”:”&#x2F;[]&#x2F;total”, “info@”:”&#x2F;[]&#x2F;info” 这里query及total仅为GET类型的请求提供方便， 一般可直接用HEAD类型的请求获取总数④ “join”:”&amp;&#x2F;Table0,&lt;&#x2F;Table1&#x2F;key1@” 或 “join”:{    “&amp;&#x2F;Table0”:{},  &#x2F;&#x2F; 支持 ON 多个字段关联,    “&lt;&#x2F;Table1&#x2F;key1@”:{  &#x2F;&#x2F; ON 只允许指定的 key1 关联      “key0”:value0,  &#x2F;&#x2F; 其它ON条件       “key2”:value2,      …       “@combine”:”…”,  &#x2F;&#x2F; 其它ON条件的组合方式       “@column”:”…”,  &#x2F;&#x2F; 外层 SELECT       “@group”:”…”,  &#x2F;&#x2F; 外层 GROUP BY       “@having”:”…”  &#x2F;&#x2F; 外层 HAVING     }}多表连接方式：  “@” - APP JOIN  “&lt;“ - LEFT JOIN  “&gt;” - RIGHT JOIN  “&amp;” - INNER JOIN  “|” - FULL JOIN   “!” - OUTER JOIN   “*” - CROSS JOIN   “^” - SIDE JOIN   “(“ - ANTI JOIN   “)” - FOREIGN JOIN 其中 @ APP JOIN 为应用层连表，会从已查出的主表里取得所有副表 key@ 关联的主表内的 refKey 作为一个数组 refKeys: [value0, value1…]，然后把原来副表 count 次查询 key&#x3D;$refKey 的 SQL 用 key IN($refKeys) 的方式合并为一条 SQL 来优化性能； 其它 JOIN 都是 SQL JOIN，具体功能和 MySQL,PostgreSQL 等数据库的 JOIN 一一对应 &quot;join&quot;:&quot;&lt;&#x2F;ViceTable&#x2F;key@&quot;,&quot;MainTable&quot;:{},&quot;ViceTable&quot;:{&quot;key@&quot;:&quot;&#x2F;MainTable&#x2F;refKey&quot;}会对应生成 MainTable LEFT JOIN ViceTable ON ViceTable.key&#x3D;MainTable.refKey AND 其它ON条件  除了 &#x3D; 等价关联，也支持 ! 不等关联、&gt; &lt; &gt;&#x3D; &lt;&#x3D; 等比较关联和 $ ~ {} &lt;&gt; 等其它复杂关联方式 ⑤ “otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 查询User数组，最多5个：“count”:5对应SQL是LIMIT 5  ② 查询第3页的User数组，每页5个：“count”:5,“page”:3对应SQL是LIMIT 5 OFFSET 15  ③ 查询User数组和对应的User总数：“[]”:{    “query”:2,    “User”:{}},“total@”:”&#x2F;[]&#x2F;total”,“info@”:”&#x2F;[]&#x2F;info” 返回的数据中，总数及分页详情结构为：   “total”:139,  &#x2F;&#x2F;总数  “info”:{  &#x2F;&#x2F;分页详情     “total”:139,  &#x2F;&#x2F;总数     “count”:5,  &#x2F;&#x2F;每页数量     “page”:0,  &#x2F;&#x2F;当前页码     “max”:27,  &#x2F;&#x2F;最大页码     “more”:true,  &#x2F;&#x2F;是否还有更多     “first”:true,  &#x2F;&#x2F;是否为首页     “last”:false  &#x2F;&#x2F;是否为尾页 }  ④ Moment INNER JOIN User LEFT JOIN Comment：“[]”:{    “join”:”&amp;&#x2F;User&#x2F;id@,&lt;&#x2F;Comment”,    “Moment”:{     “@group”:”id”  &#x2F;&#x2F;主副表不是一对一，要去除重复数据   },    “User”:{      “name~”:”t”,      “id@”:”&#x2F;Moment&#x2F;userId”    },    “Comment”:{      “momentId@”:”&#x2F;Moment&#x2F;id”    }} ⑤ 每一层都加当前用户名：“User”:{},“[]”:{    “name@”:”User&#x2F;name”, &#x2F;&#x2F;自定义关键词    “Moment”:{}}


对象关键词，可自定义
“@key”:Object，@key为 Table:{} 中{}内的关键词，Object的类型由@key指定① “@combine”:”key0 | (key1 &amp; (key2 | !key3))…”，条件组合方式，最终按  (其它key条件 AND 连接) AND (key0条件 OR (key1条件 AND (key2条件 OR (NOT key3条件)))) 这种方式连接，其中 “其它key” 是指与 @combine 在同一对象，且未被它声明的条件 key，默认都是 &amp; 连接。注意不要缺少或多余任何一个空格。 ② “@column”:”column;function(arg)…”，返回字段③ “@order”:”column0+,column1-…”，排序方式④ “@group”:”column0,column1…”，分组方式。如果@column里声明了Table的id，则id也必须在@group中声明；其它情况下必须满足至少一个条件:1.分组的key在@column里声明2.Table主键在@group中声明 ⑤ “@having”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…” &#x2F;&#x2F; OR 连接，或 “@having&amp;”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…”  &#x2F;&#x2F; AND 连接，或 “@having”:{   “h0”:”function0(…)?value0”,   “h1”:function1(…)?value1”,   “h2”:function2(…)?value2…”,   “@combine”:”h0 &amp; (h1 | !h2)”  &#x2F;&#x2F; 任意组合，非必传}SQL函数条件，一般和@group一起用，函数一般在@column里声明⑥ “@schema”:”sys”，集合空间(数据库名&#x2F;模式)，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑦ “@database”:”POSTGRESQL”，数据库类型，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑧ “@datasource”:”DRUID”，跨数据源，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑨ “@json”:”key0,key1…”，转为 JSON 格式返回，符合 JSONObject 则转为 {…}，符合 JSONArray 则转为 […] ⑩ “@role”:”OWNER”，来访角色，包括UNKNOWN,LOGIN,CONTACT,CIRCLE,OWNER,ADMIN，可以在最外层作为全局默认配置，可自定义其它角色并重写 Verifier.verify 等相关方法来自定义校验 ⑪ “@explain”:true，性能分析，可以在最外层作为全局默认配置 ⑫ “@raw”:”key0,key1…”，其中 key0, key1 都对应有键值对 “key0”:”SQL片段或SQL片段的别名”,  “key1”:”SQL片段或SQL片段的别名”  自定义原始SQL片段，可扩展嵌套SQL函数等复杂语句，必须是后端已配置的，只有其它功能符都做不到才考虑，谨慎使用，注意防SQL注入⑬ “@otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 搜索name或tag任何一个字段包含字符a的User列表： “name“:”a”,“tag“:”a”,“@combine”:”name~ | tag~” 对应SQL是name REGEXP &#39;a&#39; OR tag REGEXP &#39;a&#39;  ② 只查询id,sex,name这几列并且请求结果也按照这个顺序：“@column”:”id,sex,name”对应SQL是SELECT id,sex,name  ③ 查询按 name降序、id默认顺序 排序的User数组：“@order”:”name-,id”对应SQL是ORDER BY name DESC,id  ④ 查询按userId分组的Moment数组：“@group”:”userId,id”对应SQL是GROUP BY userId,id  ⑤ 查询 按userId分组、id最大值&gt;&#x3D;100 的Moment数组：“@column”:”userId;max(id)”,“@group”:”userId”,“@having”:”max(id)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) ... GROUP BY userId HAVING max(id)&gt;&#x3D;100 还可以指定函数返回名：“@column”:”userId;max(id):maxId”,“@group”:”userId”,“@having”:”(maxId)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) AS maxId ... GROUP BY userId HAVING (maxId)&gt;&#x3D;100  ⑥ 查询 sys 内的 User 表：“@schema”:”sys”对应SQL是FROM sys.User  ⑦ 查询 PostgreSQL 数据库的 User 表：“@database”:”POSTGRESQL” ⑧ 使用 Druid 连接池查询 User 表：“@datasource”:”DRUID” ⑨ 将 VARCHAR 字符串字段 get 转为 JSONArray 返回：“@json”:”get” ⑩ 查询当前用户的动态：“@role”:”OWNER” ⑪ 开启性能分析：“@explain”:true对应SQL是EXPLAIN  ⑫ 统计最近一周偶数userId的数量“@column”:”date;left(date,10):day;sum(if(userId%2&#x3D;0,1,0))”,“@group”:”day”,“@having”:”to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7”,“@raw”:”@column,@having”对应SQL是SELECT date, left(date,10) AS day, sum(if(userId%2&#x3D;0,1,0)) ... GROUP BY day HAVING to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7  ⑬ 从pictureList获取第0张图片：“@position”:0, &#x2F;&#x2F;自定义关键词“firstPicture()”:”getFromArray(pictureList,@position)”


全局关键词
为最外层对象 {} 内的关键词。其中 @database，@schema, @datasource, @role, @explain 基本同对象关键词，见上方说明，区别是全局关键词会每个表对象中没有时自动放入，作为默认值。 ① “tag”:String，后面的 tag 是非 GET、HEAD 请求中匹配请求的 JSON 结构的标识，一般是要查询的 Table 的名称或该名称对应的数组 Table[] 或 Table:[]，由后端 Request 表中指定。 ② “version”:Integer，接口版本，version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本，由后端 Request 表中指定。③ “format”:Boolean，格式化返回 Response JSON 的 key，一般是将 TableName 转为 tableName, TableName[] 转为 tableNameList, Table:alias 转为 alias, TableName-key[] 转为 tableNameKeyList 等小驼峰格式。
①  查隐私信息：[{“tag”:”Privacy”,”Privacy”:{“id”:82001}}](http:&#x2F;&#x2F;apijson.cn&#x2F;api?url&#x3D;http%3A%2F%2Fapijson.cn%3A8080%2Fgets&amp;type&#x3D;JSON&amp;json&#x3D;


</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3.1"><span class="toc-number">1.9.3.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%8A%9F%E8%83%BD%E7%AC%A6"><span class="toc-number">1.9.4.</span> <span class="toc-text">3.2 功能符


功能
键值对格式
使用示例



查询数组
“key[]”:{}，后面是JSONObject，key可省略。当key和里面的Table名相同时，Table会被提取出来，即 {Table:{Content}} 会被转化为 {Content}
{“User[]”:{“User”:{}}}，查询一个User数组。这里key和Table名都是User，User会被提取出来，即 {“User”:{“id”, …}} 会被转化为 {“id”, …}，如果要进一步提取User中的id，可以把User[]改为User-id[]


匹配选项范围
“key{}”:[]，后面是JSONArray，作为key可取的值的选项
“id{}”:[38710,82001,70793]，对应SQL是id IN(38710,82001,70793)，查询id符合38710,82001,70793中任意一个的一个User数组


匹配条件范围
“key{}”:”条件0,条件1…”，条件为SQL表达式字符串，可进行数字比较运算等
“id{}”:”&lt;&#x3D;80000,&gt;90000”，对应SQL是id&lt;&#x3D;80000 OR id&gt;90000，查询id符合id&lt;&#x3D;80000 | id&gt;90000的一个User数组


包含选项范围
“key&lt;&gt;“:Object  &#x3D;&gt;  “key&lt;&gt;“:[Object]，key对应值的类型必须为JSONArray，Object类型不能为JSON
“contactIdList&lt;&gt;“:38710，对应SQL是json_contains(contactIdList,38710)，查询contactIdList包含38710的一个User数组


判断是否存在
“key}{@”:{    “from”:”Table”,    “Table”:{ … }}其中：}{ 表示 EXISTS； key 用来标识是哪个判断； @ 后面是 子查询 对象，具体见下方 子查询 的说明。
“id}{@”:{    “from”:”Comment”,    “Comment”:{        “momentId”:15     }} WHERE EXISTS(SELECT * FROM Comment WHERE momentId&#x3D;15)


远程调用函数
“key()”:”函数表达式”，函数表达式为 function(key0,key1…)，会调用后端对应的函数 function(JSONObject request, String key0, String key1…)，实现 参数校验、数值计算、数据同步、消息推送、字段拼接、结构变换 等特定的业务逻辑处理，可使用 - 和 + 表示优先级，解析 key-() &gt; 解析当前对象 &gt; 解析 key() &gt; 解析子对象 &gt; 解析 key+()
“isPraised()”:”isContain(praiseUserIdList,userId)”，会调用远程函数 boolean isContain(JSONObject request, String array, String value) ，然后变为 “isPraised”:true 这种（假设点赞用户id列表包含了userId，即这个User点了赞）


存储过程
“@key()”:”SQL函数表达式”，函数表达式为   function(key0,key1…)  会调用后端数据库对应的存储过程 SQL函数  function(String key0, String key1…)  除了参数会提前赋值，其它和 远程函数 一致
“@limit”:10,  “@offset”:0,  “@procedure()”:”getCommentByUserId(id,@limit,@offset)”  会转为  getCommentByUserId(38710,10,0)  来调用存储过程 SQL 函数  getCommentByUserId(IN id bigint, IN limit int, IN offset int)  然后变为 “procedure”:{    “count”:-1,     “update”:false,     “list”:[]  }  其中 count 是指写操作影响记录行数，-1 表示不是写操作；update 是指是否为写操作（增删改）；list 为返回结果集


引用赋值
“key@”:”key0&#x2F;key1&#x2F;…&#x2F;refKey”，引用路径为用&#x2F;分隔的字符串。以&#x2F;开头的是缺省引用路径，从声明key所处容器的父容器路径开始；其它是完整引用路径，从最外层开始。 被引用的refKey必须在声明key的上面。如果对refKey的容器指定了返回字段，则被引用的refKey必须写在@column对应的值内，例如 “@column”:”refKey,key1,…”
“Moment”:{    “userId”:38710},“User”:{    “id@”:”&#x2F;Moment&#x2F;userId”} User内的id引用了与User同级的Moment内的userId，即User.id &#x3D; Moment.userId，请求完成后 “id@”:”&#x2F;Moment&#x2F;userId” 会变成 “id”:38710


子查询
“key@”:{    “range”:”ALL”,     “from”:”Table”,    “Table”:{ … }}其中：range 可为 ALL,ANY；from 为目标表 Table 的名称；@ 后面的对象类似数组对象，可使用 count 和 join 等功能。
“id@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&#x3D;(SELECT min(userId) FROM Comment)


模糊搜索
&quot;key$&quot;:&quot;SQL搜索表达式&quot;  &#x3D;&gt;  &quot;key$&quot;:[&quot;SQL搜索表达式&quot;]，任意SQL搜索表达式字符串，如 %key%(包含key), key%(以key开始), %k%e%y%(包含字母k,e,y) 等，%表示任意字符
“name$”:”%m%”，对应SQL是name LIKE &#39;%m%&#39;，查询name包含”m”的一个User数组


正则匹配
“key“:”正则表达式”  &#x3D;&gt;  “key“:[“正则表达式”]，任意正则表达式字符串，如 ^[0-9]+$ ，*~ 忽略大小写，可用于高级搜索
“name~”:”^[0-9]+$”，对应SQL是name REGEXP &#39;^[0-9]+$&#39;，查询name中字符全为数字的一个User数组


连续范围
“key%”:”start,end”  &#x3D;&gt;  “key%”:[“start,end”]，其中 start 和 end 都只能为 Boolean, Number, String 中的一种，如 “2017-01-01,2019-01-01” ，[“1,90000”, “82001,100000”] ，可用于连续范围内的筛选
“date%”:”2017-10-01,2018-10-01”，对应SQL是date BETWEEN &#39;2017-10-01&#39; AND &#39;2018-10-01&#39;，查询在2017-10-01和2018-10-01期间注册的用户的一个User数组


新建别名
“name:alias”，name映射为alias，用alias替代name。可用于 column,Table,SQL函数 等。只用于GET类型、HEAD类型的请求
“@column”:”toId:parentId”，对应SQL是toId AS parentId，将查询的字段toId变为parentId返回


增加 或 扩展
“key+”:Object，Object的类型由key指定，且类型为Number,String,JSONArray中的一种。如 82001,”apijson”,[“url0”,”url1”] 等。只用于PUT请求
“praiseUserIdList+”:[82001]，对应SQL是json_insert(praiseUserIdList,82001)，添加一个点赞用户id，即这个用户点了赞


减少 或 去除
“key-“:Object，与”key+”相反
“balance-“:100.00，对应SQL是balance &#x3D; balance - 100.00，余额减少100.00，即花费了100元


比较运算
&gt;, &lt;, &gt;&#x3D;, &lt;&#x3D; 比较运算符，用于 ① 提供 “id{}”:”&lt;&#x3D;90000” 这种条件范围的简化写法 ② 实现子查询相关比较运算不支持 “key&#x3D;”:Object 和 “key!&#x3D;”:Object 这两种写法，直接用更简单的 “key”:Object 和 “key!”:Object 替代。
① “id&lt;&#x3D;”:90000，对应SQL是id&lt;&#x3D;90000，查询符合id&lt;&#x3D;90000的一个User数组 ② “id&gt;@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&gt;(SELECT min(userId) FROM Comment)


逻辑运算
&amp;, |, ! 逻辑运算符，对应数据库 SQL 中的 AND, OR, NOT。 横或纵与：同一键值对的值内条件默认 | 或连接，可以在 key 后加逻辑运算符来具体指定；不同键值对的条件默认 &amp; 与连接，可以用下面说明的对象关键词 @combine 来具体指定。 ① &amp; 可用于”key&amp;{}”:”条件”等② | 可用于”key|{}”:”条件”, “key|{}”:[]等，一般可省略③ ! 可单独使用，如”key!”:Object，也可像&amp;,|一样配合其他功能符使用  “key!”:null 无效，null 值会导致整个键值对被忽略解析，可以用 “key{}”:”!&#x3D;null” 替代，“key”:null 同理，用 “key{}”:”&#x3D;null” 替代。
① “id&amp;{}”:”&gt;80000,&lt;&#x3D;90000”，对应SQL是id&gt;80000 AND id&lt;&#x3D;90000，即id满足id&gt;80000 &amp; id&lt;&#x3D;90000 ② “id|{}”:”&gt;90000,&lt;&#x3D;80000”，同”id{}”:”&gt;90000,&lt;&#x3D;80000”，对应SQL是id&gt;80000 OR id&lt;&#x3D;90000，即id满足id&gt;90000 | id&lt;&#x3D;80000 ③ “id!{}”:[82001,38710]，对应SQL是id NOT IN(82001,38710)，即id满足 ! (id&#x3D;82001 | id&#x3D;38710)，可过滤黑名单的消息


数组关键词，可自定义
“key”:Object，key为 “[]”:{} 中{}内的关键词，Object的类型由key指定① “count”:Integer，查询数量，0 表示最大值，默认最大值为100 ② “page”:Integer，查询页码，从0开始，默认最大值为100，一般和count一起用③ “query”:Integer，查询内容0-对象，1-总数和分页详情，2-数据、总数和分页详情总数关键词为 total，分页详情关键词为 info， 它们都和 query 同级，通过引用赋值得到，例如  “total@”:”&#x2F;[]&#x2F;total”, “info@”:”&#x2F;[]&#x2F;info” 这里query及total仅为GET类型的请求提供方便， 一般可直接用HEAD类型的请求获取总数④ “join”:”&amp;&#x2F;Table0,&lt;&#x2F;Table1&#x2F;key1@” 或 “join”:{    “&amp;&#x2F;Table0”:{},  &#x2F;&#x2F; 支持 ON 多个字段关联,    “&lt;&#x2F;Table1&#x2F;key1@”:{  &#x2F;&#x2F; ON 只允许指定的 key1 关联      “key0”:value0,  &#x2F;&#x2F; 其它ON条件       “key2”:value2,      …       “@combine”:”…”,  &#x2F;&#x2F; 其它ON条件的组合方式       “@column”:”…”,  &#x2F;&#x2F; 外层 SELECT       “@group”:”…”,  &#x2F;&#x2F; 外层 GROUP BY       “@having”:”…”  &#x2F;&#x2F; 外层 HAVING     }}多表连接方式：  “@” - APP JOIN  “&lt;“ - LEFT JOIN  “&gt;” - RIGHT JOIN  “&amp;” - INNER JOIN  “|” - FULL JOIN   “!” - OUTER JOIN   “*” - CROSS JOIN   “^” - SIDE JOIN   “(“ - ANTI JOIN   “)” - FOREIGN JOIN 其中 @ APP JOIN 为应用层连表，会从已查出的主表里取得所有副表 key@ 关联的主表内的 refKey 作为一个数组 refKeys: [value0, value1…]，然后把原来副表 count 次查询 key&#x3D;$refKey 的 SQL 用 key IN($refKeys) 的方式合并为一条 SQL 来优化性能； 其它 JOIN 都是 SQL JOIN，具体功能和 MySQL,PostgreSQL 等数据库的 JOIN 一一对应 &quot;join&quot;:&quot;&lt;&#x2F;ViceTable&#x2F;key@&quot;,&quot;MainTable&quot;:{},&quot;ViceTable&quot;:{&quot;key@&quot;:&quot;&#x2F;MainTable&#x2F;refKey&quot;}会对应生成 MainTable LEFT JOIN ViceTable ON ViceTable.key&#x3D;MainTable.refKey AND 其它ON条件  除了 &#x3D; 等价关联，也支持 ! 不等关联、&gt; &lt; &gt;&#x3D; &lt;&#x3D; 等比较关联和 $ ~ {} &lt;&gt; 等其它复杂关联方式 ⑤ “otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 查询User数组，最多5个：“count”:5对应SQL是LIMIT 5  ② 查询第3页的User数组，每页5个：“count”:5,“page”:3对应SQL是LIMIT 5 OFFSET 15  ③ 查询User数组和对应的User总数：“[]”:{    “query”:2,    “User”:{}},“total@”:”&#x2F;[]&#x2F;total”,“info@”:”&#x2F;[]&#x2F;info” 返回的数据中，总数及分页详情结构为：   “total”:139,  &#x2F;&#x2F;总数  “info”:{  &#x2F;&#x2F;分页详情     “total”:139,  &#x2F;&#x2F;总数     “count”:5,  &#x2F;&#x2F;每页数量     “page”:0,  &#x2F;&#x2F;当前页码     “max”:27,  &#x2F;&#x2F;最大页码     “more”:true,  &#x2F;&#x2F;是否还有更多     “first”:true,  &#x2F;&#x2F;是否为首页     “last”:false  &#x2F;&#x2F;是否为尾页 }  ④ Moment INNER JOIN User LEFT JOIN Comment：“[]”:{    “join”:”&amp;&#x2F;User&#x2F;id@,&lt;&#x2F;Comment”,    “Moment”:{     “@group”:”id”  &#x2F;&#x2F;主副表不是一对一，要去除重复数据   },    “User”:{      “name~”:”t”,      “id@”:”&#x2F;Moment&#x2F;userId”    },    “Comment”:{      “momentId@”:”&#x2F;Moment&#x2F;id”    }} ⑤ 每一层都加当前用户名：“User”:{},“[]”:{    “name@”:”User&#x2F;name”, &#x2F;&#x2F;自定义关键词    “Moment”:{}}


对象关键词，可自定义
“@key”:Object，@key为 Table:{} 中{}内的关键词，Object的类型由@key指定① “@combine”:”key0 | (key1 &amp; (key2 | !key3))…”，条件组合方式，最终按  (其它key条件 AND 连接) AND (key0条件 OR (key1条件 AND (key2条件 OR (NOT key3条件)))) 这种方式连接，其中 “其它key” 是指与 @combine 在同一对象，且未被它声明的条件 key，默认都是 &amp; 连接。注意不要缺少或多余任何一个空格。 ② “@column”:”column;function(arg)…”，返回字段③ “@order”:”column0+,column1-…”，排序方式④ “@group”:”column0,column1…”，分组方式。如果@column里声明了Table的id，则id也必须在@group中声明；其它情况下必须满足至少一个条件:1.分组的key在@column里声明2.Table主键在@group中声明 ⑤ “@having”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…” &#x2F;&#x2F; OR 连接，或 “@having&amp;”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…”  &#x2F;&#x2F; AND 连接，或 “@having”:{   “h0”:”function0(…)?value0”,   “h1”:function1(…)?value1”,   “h2”:function2(…)?value2…”,   “@combine”:”h0 &amp; (h1 | !h2)”  &#x2F;&#x2F; 任意组合，非必传}SQL函数条件，一般和@group一起用，函数一般在@column里声明⑥ “@schema”:”sys”，集合空间(数据库名&#x2F;模式)，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑦ “@database”:”POSTGRESQL”，数据库类型，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑧ “@datasource”:”DRUID”，跨数据源，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑨ “@json”:”key0,key1…”，转为 JSON 格式返回，符合 JSONObject 则转为 {…}，符合 JSONArray 则转为 […] ⑩ “@role”:”OWNER”，来访角色，包括UNKNOWN,LOGIN,CONTACT,CIRCLE,OWNER,ADMIN，可以在最外层作为全局默认配置，可自定义其它角色并重写 Verifier.verify 等相关方法来自定义校验 ⑪ “@explain”:true，性能分析，可以在最外层作为全局默认配置 ⑫ “@raw”:”key0,key1…”，其中 key0, key1 都对应有键值对 “key0”:”SQL片段或SQL片段的别名”,  “key1”:”SQL片段或SQL片段的别名”  自定义原始SQL片段，可扩展嵌套SQL函数等复杂语句，必须是后端已配置的，只有其它功能符都做不到才考虑，谨慎使用，注意防SQL注入⑬ “@otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 搜索name或tag任何一个字段包含字符a的User列表： “name“:”a”,“tag“:”a”,“@combine”:”name~ | tag~” 对应SQL是name REGEXP &#39;a&#39; OR tag REGEXP &#39;a&#39;  ② 只查询id,sex,name这几列并且请求结果也按照这个顺序：“@column”:”id,sex,name”对应SQL是SELECT id,sex,name  ③ 查询按 name降序、id默认顺序 排序的User数组：“@order”:”name-,id”对应SQL是ORDER BY name DESC,id  ④ 查询按userId分组的Moment数组：“@group”:”userId,id”对应SQL是GROUP BY userId,id  ⑤ 查询 按userId分组、id最大值&gt;&#x3D;100 的Moment数组：“@column”:”userId;max(id)”,“@group”:”userId”,“@having”:”max(id)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) ... GROUP BY userId HAVING max(id)&gt;&#x3D;100 还可以指定函数返回名：“@column”:”userId;max(id):maxId”,“@group”:”userId”,“@having”:”(maxId)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) AS maxId ... GROUP BY userId HAVING (maxId)&gt;&#x3D;100  ⑥ 查询 sys 内的 User 表：“@schema”:”sys”对应SQL是FROM sys.User  ⑦ 查询 PostgreSQL 数据库的 User 表：“@database”:”POSTGRESQL” ⑧ 使用 Druid 连接池查询 User 表：“@datasource”:”DRUID” ⑨ 将 VARCHAR 字符串字段 get 转为 JSONArray 返回：“@json”:”get” ⑩ 查询当前用户的动态：“@role”:”OWNER” ⑪ 开启性能分析：“@explain”:true对应SQL是EXPLAIN  ⑫ 统计最近一周偶数userId的数量“@column”:”date;left(date,10):day;sum(if(userId%2&#x3D;0,1,0))”,“@group”:”day”,“@having”:”to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7”,“@raw”:”@column,@having”对应SQL是SELECT date, left(date,10) AS day, sum(if(userId%2&#x3D;0,1,0)) ... GROUP BY day HAVING to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7  ⑬ 从pictureList获取第0张图片：“@position”:0, &#x2F;&#x2F;自定义关键词“firstPicture()”:”getFromArray(pictureList,@position)”


全局关键词
为最外层对象 {} 内的关键词。其中 @database，@schema, @datasource, @role, @explain 基本同对象关键词，见上方说明，区别是全局关键词会每个表对象中没有时自动放入，作为默认值。 ① “tag”:String，后面的 tag 是非 GET、HEAD 请求中匹配请求的 JSON 结构的标识，一般是要查询的 Table 的名称或该名称对应的数组 Table[] 或 Table:[]，由后端 Request 表中指定。 ② “version”:Integer，接口版本，version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本，由后端 Request 表中指定。③ “format”:Boolean，格式化返回 Response JSON 的 key，一般是将 TableName 转为 tableName, TableName[] 转为 tableNameList, Table:alias 转为 alias, TableName-key[] 转为 tableNameKeyList 等小驼峰格式。
①  查隐私信息：[{“tag”:”Privacy”,”Privacy”:{“id”:82001}}](http:&#x2F;&#x2F;apijson.cn&#x2F;api?url&#x3D;http%3A%2F%2Fapijson.cn%3A8080%2Fgets&amp;type&#x3D;JSON&amp;json&#x3D;


</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3.2"><span class="toc-number">1.9.5.</span> <span class="toc-text">3.2 功能符


功能
键值对格式
使用示例



查询数组
“key[]”:{}，后面是JSONObject，key可省略。当key和里面的Table名相同时，Table会被提取出来，即 {Table:{Content}} 会被转化为 {Content}
{“User[]”:{“User”:{}}}，查询一个User数组。这里key和Table名都是User，User会被提取出来，即 {“User”:{“id”, …}} 会被转化为 {“id”, …}，如果要进一步提取User中的id，可以把User[]改为User-id[]


匹配选项范围
“key{}”:[]，后面是JSONArray，作为key可取的值的选项
“id{}”:[38710,82001,70793]，对应SQL是id IN(38710,82001,70793)，查询id符合38710,82001,70793中任意一个的一个User数组


匹配条件范围
“key{}”:”条件0,条件1…”，条件为SQL表达式字符串，可进行数字比较运算等
“id{}”:”&lt;&#x3D;80000,&gt;90000”，对应SQL是id&lt;&#x3D;80000 OR id&gt;90000，查询id符合id&lt;&#x3D;80000 | id&gt;90000的一个User数组


包含选项范围
“key&lt;&gt;“:Object  &#x3D;&gt;  “key&lt;&gt;“:[Object]，key对应值的类型必须为JSONArray，Object类型不能为JSON
“contactIdList&lt;&gt;“:38710，对应SQL是json_contains(contactIdList,38710)，查询contactIdList包含38710的一个User数组


判断是否存在
“key}{@”:{    “from”:”Table”,    “Table”:{ … }}其中：}{ 表示 EXISTS； key 用来标识是哪个判断； @ 后面是 子查询 对象，具体见下方 子查询 的说明。
“id}{@”:{    “from”:”Comment”,    “Comment”:{        “momentId”:15     }} WHERE EXISTS(SELECT * FROM Comment WHERE momentId&#x3D;15)


远程调用函数
“key()”:”函数表达式”，函数表达式为 function(key0,key1…)，会调用后端对应的函数 function(JSONObject request, String key0, String key1…)，实现 参数校验、数值计算、数据同步、消息推送、字段拼接、结构变换 等特定的业务逻辑处理，可使用 - 和 + 表示优先级，解析 key-() &gt; 解析当前对象 &gt; 解析 key() &gt; 解析子对象 &gt; 解析 key+()
“isPraised()”:”isContain(praiseUserIdList,userId)”，会调用远程函数 boolean isContain(JSONObject request, String array, String value) ，然后变为 “isPraised”:true 这种（假设点赞用户id列表包含了userId，即这个User点了赞）


存储过程
“@key()”:”SQL函数表达式”，函数表达式为   function(key0,key1…)  会调用后端数据库对应的存储过程 SQL函数  function(String key0, String key1…)  除了参数会提前赋值，其它和 远程函数 一致
“@limit”:10,  “@offset”:0,  “@procedure()”:”getCommentByUserId(id,@limit,@offset)”  会转为  getCommentByUserId(38710,10,0)  来调用存储过程 SQL 函数  getCommentByUserId(IN id bigint, IN limit int, IN offset int)  然后变为 “procedure”:{    “count”:-1,     “update”:false,     “list”:[]  }  其中 count 是指写操作影响记录行数，-1 表示不是写操作；update 是指是否为写操作（增删改）；list 为返回结果集


引用赋值
“key@”:”key0&#x2F;key1&#x2F;…&#x2F;refKey”，引用路径为用&#x2F;分隔的字符串。以&#x2F;开头的是缺省引用路径，从声明key所处容器的父容器路径开始；其它是完整引用路径，从最外层开始。 被引用的refKey必须在声明key的上面。如果对refKey的容器指定了返回字段，则被引用的refKey必须写在@column对应的值内，例如 “@column”:”refKey,key1,…”
“Moment”:{    “userId”:38710},“User”:{    “id@”:”&#x2F;Moment&#x2F;userId”} User内的id引用了与User同级的Moment内的userId，即User.id &#x3D; Moment.userId，请求完成后 “id@”:”&#x2F;Moment&#x2F;userId” 会变成 “id”:38710


子查询
“key@”:{    “range”:”ALL”,     “from”:”Table”,    “Table”:{ … }}其中：range 可为 ALL,ANY；from 为目标表 Table 的名称；@ 后面的对象类似数组对象，可使用 count 和 join 等功能。
“id@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&#x3D;(SELECT min(userId) FROM Comment)


模糊搜索
&quot;key$&quot;:&quot;SQL搜索表达式&quot;  &#x3D;&gt;  &quot;key$&quot;:[&quot;SQL搜索表达式&quot;]，任意SQL搜索表达式字符串，如 %key%(包含key), key%(以key开始), %k%e%y%(包含字母k,e,y) 等，%表示任意字符
“name$”:”%m%”，对应SQL是name LIKE &#39;%m%&#39;，查询name包含”m”的一个User数组


正则匹配
“key“:”正则表达式”  &#x3D;&gt;  “key“:[“正则表达式”]，任意正则表达式字符串，如 ^[0-9]+$ ，*~ 忽略大小写，可用于高级搜索
“name~”:”^[0-9]+$”，对应SQL是name REGEXP &#39;^[0-9]+$&#39;，查询name中字符全为数字的一个User数组


连续范围
“key%”:”start,end”  &#x3D;&gt;  “key%”:[“start,end”]，其中 start 和 end 都只能为 Boolean, Number, String 中的一种，如 “2017-01-01,2019-01-01” ，[“1,90000”, “82001,100000”] ，可用于连续范围内的筛选
“date%”:”2017-10-01,2018-10-01”，对应SQL是date BETWEEN &#39;2017-10-01&#39; AND &#39;2018-10-01&#39;，查询在2017-10-01和2018-10-01期间注册的用户的一个User数组


新建别名
“name:alias”，name映射为alias，用alias替代name。可用于 column,Table,SQL函数 等。只用于GET类型、HEAD类型的请求
“@column”:”toId:parentId”，对应SQL是toId AS parentId，将查询的字段toId变为parentId返回


增加 或 扩展
“key+”:Object，Object的类型由key指定，且类型为Number,String,JSONArray中的一种。如 82001,”apijson”,[“url0”,”url1”] 等。只用于PUT请求
“praiseUserIdList+”:[82001]，对应SQL是json_insert(praiseUserIdList,82001)，添加一个点赞用户id，即这个用户点了赞


减少 或 去除
“key-“:Object，与”key+”相反
“balance-“:100.00，对应SQL是balance &#x3D; balance - 100.00，余额减少100.00，即花费了100元


比较运算
&gt;, &lt;, &gt;&#x3D;, &lt;&#x3D; 比较运算符，用于 ① 提供 “id{}”:”&lt;&#x3D;90000” 这种条件范围的简化写法 ② 实现子查询相关比较运算不支持 “key&#x3D;”:Object 和 “key!&#x3D;”:Object 这两种写法，直接用更简单的 “key”:Object 和 “key!”:Object 替代。
① “id&lt;&#x3D;”:90000，对应SQL是id&lt;&#x3D;90000，查询符合id&lt;&#x3D;90000的一个User数组 ② “id&gt;@”:{    “from”:”Comment”,    “Comment”:{        “@column”:”min(userId)”     }} WHERE id&gt;(SELECT min(userId) FROM Comment)


逻辑运算
&amp;, |, ! 逻辑运算符，对应数据库 SQL 中的 AND, OR, NOT。 横或纵与：同一键值对的值内条件默认 | 或连接，可以在 key 后加逻辑运算符来具体指定；不同键值对的条件默认 &amp; 与连接，可以用下面说明的对象关键词 @combine 来具体指定。 ① &amp; 可用于”key&amp;{}”:”条件”等② | 可用于”key|{}”:”条件”, “key|{}”:[]等，一般可省略③ ! 可单独使用，如”key!”:Object，也可像&amp;,|一样配合其他功能符使用  “key!”:null 无效，null 值会导致整个键值对被忽略解析，可以用 “key{}”:”!&#x3D;null” 替代，“key”:null 同理，用 “key{}”:”&#x3D;null” 替代。
① “id&amp;{}”:”&gt;80000,&lt;&#x3D;90000”，对应SQL是id&gt;80000 AND id&lt;&#x3D;90000，即id满足id&gt;80000 &amp; id&lt;&#x3D;90000 ② “id|{}”:”&gt;90000,&lt;&#x3D;80000”，同”id{}”:”&gt;90000,&lt;&#x3D;80000”，对应SQL是id&gt;80000 OR id&lt;&#x3D;90000，即id满足id&gt;90000 | id&lt;&#x3D;80000 ③ “id!{}”:[82001,38710]，对应SQL是id NOT IN(82001,38710)，即id满足 ! (id&#x3D;82001 | id&#x3D;38710)，可过滤黑名单的消息


数组关键词，可自定义
“key”:Object，key为 “[]”:{} 中{}内的关键词，Object的类型由key指定① “count”:Integer，查询数量，0 表示最大值，默认最大值为100 ② “page”:Integer，查询页码，从0开始，默认最大值为100，一般和count一起用③ “query”:Integer，查询内容0-对象，1-总数和分页详情，2-数据、总数和分页详情总数关键词为 total，分页详情关键词为 info， 它们都和 query 同级，通过引用赋值得到，例如  “total@”:”&#x2F;[]&#x2F;total”, “info@”:”&#x2F;[]&#x2F;info” 这里query及total仅为GET类型的请求提供方便， 一般可直接用HEAD类型的请求获取总数④ “join”:”&amp;&#x2F;Table0,&lt;&#x2F;Table1&#x2F;key1@” 或 “join”:{    “&amp;&#x2F;Table0”:{},  &#x2F;&#x2F; 支持 ON 多个字段关联,    “&lt;&#x2F;Table1&#x2F;key1@”:{  &#x2F;&#x2F; ON 只允许指定的 key1 关联      “key0”:value0,  &#x2F;&#x2F; 其它ON条件       “key2”:value2,      …       “@combine”:”…”,  &#x2F;&#x2F; 其它ON条件的组合方式       “@column”:”…”,  &#x2F;&#x2F; 外层 SELECT       “@group”:”…”,  &#x2F;&#x2F; 外层 GROUP BY       “@having”:”…”  &#x2F;&#x2F; 外层 HAVING     }}多表连接方式：  “@” - APP JOIN  “&lt;“ - LEFT JOIN  “&gt;” - RIGHT JOIN  “&amp;” - INNER JOIN  “|” - FULL JOIN   “!” - OUTER JOIN   “*” - CROSS JOIN   “^” - SIDE JOIN   “(“ - ANTI JOIN   “)” - FOREIGN JOIN 其中 @ APP JOIN 为应用层连表，会从已查出的主表里取得所有副表 key@ 关联的主表内的 refKey 作为一个数组 refKeys: [value0, value1…]，然后把原来副表 count 次查询 key&#x3D;$refKey 的 SQL 用 key IN($refKeys) 的方式合并为一条 SQL 来优化性能； 其它 JOIN 都是 SQL JOIN，具体功能和 MySQL,PostgreSQL 等数据库的 JOIN 一一对应 &quot;join&quot;:&quot;&lt;&#x2F;ViceTable&#x2F;key@&quot;,&quot;MainTable&quot;:{},&quot;ViceTable&quot;:{&quot;key@&quot;:&quot;&#x2F;MainTable&#x2F;refKey&quot;}会对应生成 MainTable LEFT JOIN ViceTable ON ViceTable.key&#x3D;MainTable.refKey AND 其它ON条件  除了 &#x3D; 等价关联，也支持 ! 不等关联、&gt; &lt; &gt;&#x3D; &lt;&#x3D; 等比较关联和 $ ~ {} &lt;&gt; 等其它复杂关联方式 ⑤ “otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 查询User数组，最多5个：“count”:5对应SQL是LIMIT 5  ② 查询第3页的User数组，每页5个：“count”:5,“page”:3对应SQL是LIMIT 5 OFFSET 15  ③ 查询User数组和对应的User总数：“[]”:{    “query”:2,    “User”:{}},“total@”:”&#x2F;[]&#x2F;total”,“info@”:”&#x2F;[]&#x2F;info” 返回的数据中，总数及分页详情结构为：   “total”:139,  &#x2F;&#x2F;总数  “info”:{  &#x2F;&#x2F;分页详情     “total”:139,  &#x2F;&#x2F;总数     “count”:5,  &#x2F;&#x2F;每页数量     “page”:0,  &#x2F;&#x2F;当前页码     “max”:27,  &#x2F;&#x2F;最大页码     “more”:true,  &#x2F;&#x2F;是否还有更多     “first”:true,  &#x2F;&#x2F;是否为首页     “last”:false  &#x2F;&#x2F;是否为尾页 }  ④ Moment INNER JOIN User LEFT JOIN Comment：“[]”:{    “join”:”&amp;&#x2F;User&#x2F;id@,&lt;&#x2F;Comment”,    “Moment”:{     “@group”:”id”  &#x2F;&#x2F;主副表不是一对一，要去除重复数据   },    “User”:{      “name~”:”t”,      “id@”:”&#x2F;Moment&#x2F;userId”    },    “Comment”:{      “momentId@”:”&#x2F;Moment&#x2F;id”    }} ⑤ 每一层都加当前用户名：“User”:{},“[]”:{    “name@”:”User&#x2F;name”, &#x2F;&#x2F;自定义关键词    “Moment”:{}}


对象关键词，可自定义
“@key”:Object，@key为 Table:{} 中{}内的关键词，Object的类型由@key指定① “@combine”:”key0 | (key1 &amp; (key2 | !key3))…”，条件组合方式，最终按  (其它key条件 AND 连接) AND (key0条件 OR (key1条件 AND (key2条件 OR (NOT key3条件)))) 这种方式连接，其中 “其它key” 是指与 @combine 在同一对象，且未被它声明的条件 key，默认都是 &amp; 连接。注意不要缺少或多余任何一个空格。 ② “@column”:”column;function(arg)…”，返回字段③ “@order”:”column0+,column1-…”，排序方式④ “@group”:”column0,column1…”，分组方式。如果@column里声明了Table的id，则id也必须在@group中声明；其它情况下必须满足至少一个条件:1.分组的key在@column里声明2.Table主键在@group中声明 ⑤ “@having”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…” &#x2F;&#x2F; OR 连接，或 “@having&amp;”:”function0(…)?value0;function1(…)?value1;function2(…)?value2…”  &#x2F;&#x2F; AND 连接，或 “@having”:{   “h0”:”function0(…)?value0”,   “h1”:function1(…)?value1”,   “h2”:function2(…)?value2…”,   “@combine”:”h0 &amp; (h1 | !h2)”  &#x2F;&#x2F; 任意组合，非必传}SQL函数条件，一般和@group一起用，函数一般在@column里声明⑥ “@schema”:”sys”，集合空间(数据库名&#x2F;模式)，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑦ “@database”:”POSTGRESQL”，数据库类型，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑧ “@datasource”:”DRUID”，跨数据源，非默认的值可通过它来指定，可以在最外层作为全局默认配置⑨ “@json”:”key0,key1…”，转为 JSON 格式返回，符合 JSONObject 则转为 {…}，符合 JSONArray 则转为 […] ⑩ “@role”:”OWNER”，来访角色，包括UNKNOWN,LOGIN,CONTACT,CIRCLE,OWNER,ADMIN，可以在最外层作为全局默认配置，可自定义其它角色并重写 Verifier.verify 等相关方法来自定义校验 ⑪ “@explain”:true，性能分析，可以在最外层作为全局默认配置 ⑫ “@raw”:”key0,key1…”，其中 key0, key1 都对应有键值对 “key0”:”SQL片段或SQL片段的别名”,  “key1”:”SQL片段或SQL片段的别名”  自定义原始SQL片段，可扩展嵌套SQL函数等复杂语句，必须是后端已配置的，只有其它功能符都做不到才考虑，谨慎使用，注意防SQL注入⑬ “@otherKey”:Object，自定义关键词，名称和以上系统关键词不一样，且原样返回上传的值
① 搜索name或tag任何一个字段包含字符a的User列表： “name“:”a”,“tag“:”a”,“@combine”:”name~ | tag~” 对应SQL是name REGEXP &#39;a&#39; OR tag REGEXP &#39;a&#39;  ② 只查询id,sex,name这几列并且请求结果也按照这个顺序：“@column”:”id,sex,name”对应SQL是SELECT id,sex,name  ③ 查询按 name降序、id默认顺序 排序的User数组：“@order”:”name-,id”对应SQL是ORDER BY name DESC,id  ④ 查询按userId分组的Moment数组：“@group”:”userId,id”对应SQL是GROUP BY userId,id  ⑤ 查询 按userId分组、id最大值&gt;&#x3D;100 的Moment数组：“@column”:”userId;max(id)”,“@group”:”userId”,“@having”:”max(id)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) ... GROUP BY userId HAVING max(id)&gt;&#x3D;100 还可以指定函数返回名：“@column”:”userId;max(id):maxId”,“@group”:”userId”,“@having”:”(maxId)&gt;&#x3D;100”对应SQL是SELECT userId,max(id) AS maxId ... GROUP BY userId HAVING (maxId)&gt;&#x3D;100  ⑥ 查询 sys 内的 User 表：“@schema”:”sys”对应SQL是FROM sys.User  ⑦ 查询 PostgreSQL 数据库的 User 表：“@database”:”POSTGRESQL” ⑧ 使用 Druid 连接池查询 User 表：“@datasource”:”DRUID” ⑨ 将 VARCHAR 字符串字段 get 转为 JSONArray 返回：“@json”:”get” ⑩ 查询当前用户的动态：“@role”:”OWNER” ⑪ 开启性能分析：“@explain”:true对应SQL是EXPLAIN  ⑫ 统计最近一周偶数userId的数量“@column”:”date;left(date,10):day;sum(if(userId%2&#x3D;0,1,0))”,“@group”:”day”,“@having”:”to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7”,“@raw”:”@column,@having”对应SQL是SELECT date, left(date,10) AS day, sum(if(userId%2&#x3D;0,1,0)) ... GROUP BY day HAVING to_days(now())-to_days(&#96;date&#96;)&lt;&#x3D;7  ⑬ 从pictureList获取第0张图片：“@position”:0, &#x2F;&#x2F;自定义关键词“firstPicture()”:”getFromArray(pictureList,@position)”


全局关键词
为最外层对象 {} 内的关键词。其中 @database，@schema, @datasource, @role, @explain 基本同对象关键词，见上方说明，区别是全局关键词会每个表对象中没有时自动放入，作为默认值。 ① “tag”:String，后面的 tag 是非 GET、HEAD 请求中匹配请求的 JSON 结构的标识，一般是要查询的 Table 的名称或该名称对应的数组 Table[] 或 Table:[]，由后端 Request 表中指定。 ② “version”:Integer，接口版本，version 不传、为 null 或 &lt;&#x3D;0 都会使用最高版本，传了其它有效值则会使用最接近它的最低版本，由后端 Request 表中指定。③ “format”:Boolean，格式化返回 Response JSON 的 key，一般是将 TableName 转为 tableName, TableName[] 转为 tableNameList, Table:alias 转为 alias, TableName-key[] 转为 tableNameKeyList 等小驼峰格式。
①  查隐私信息：[{“tag”:”Privacy”,”Privacy”:{“id”:82001}}](http:&#x2F;&#x2F;apijson.cn&#x2F;api?url&#x3D;http%3A%2F%2Fapijson.cn%3A8080%2Fgets&amp;type&#x3D;JSON&amp;json&#x3D;


</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3.2"><span class="toc-number">1.9.6.</span> <span class="toc-text"></span></a></li></ol></li></ol></li></ol>
                </div>
            </div>
            
            
        </div>
    </div>
</div>

    </div>
</div>
    <div id="back-to-top" class="animated fadeIn faster">
        <div class="flow"></div>
        <span class="percentage animated fadeIn faster">0%</span>
        <span class="iconfont icon-top02 animated fadeIn faster"></span>
    </div>
</body>
<footer>
    <p class="copyright" id="copyright">
        &copy; 2024
        <span class="gradient-text">
            Pebble
        </span>.
        Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a>
        Theme
        <span class="gradient-text">
            <a href="https://github.com/TriDiamond/hexo-theme-obsidian" title="Obsidian" target="_blank" rel="noopener">Obsidian</a>
        </span>
        <small><a href="https://github.com/TriDiamond/hexo-theme-obsidian/blob/master/CHANGELOG.md" title="v1.4.7" target="_blank" rel="noopener">v1.4.7</a></small>
        
        
        <br/>
<a href="http://beian.miit.gov.cn" target="_blank" style="border-bottom:0;color:#999;font-size:12px">备案号：闽ICP备2023004050号</a><br/>
<a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=35010202001664" style="display:inline-block;border-bottom:0;color:#999;font-size:12px"><img src="备案图标.png" style="float:left;margin-right:5px"/>闽公网安备 35010202001664号</a>
    </p>
</footer>

<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
    "HTML-CSS": {
      preferredFont: "TeX",
      availableFonts: ["STIX", "TeX"],
      linebreaks: {
        automatic: true
      },
      EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
      inlineMath: [
        ["$", "$"],
        ["\\(", "\\)"]
      ],
      processEscapes: true,
      ignoreClass: "tex2jax_ignore|dno",
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      noUndefined: {
        attributes: {
          mathcolor: "red",
          mathbackground: "#FFEEEE",
          mathsize: "90%"
        }
      },
      Macros: {
        href: "{}"
      }
    },
    messageStyle: "none"
  });
</script>
<script>
  function initialMathJax() {
    MathJax.Hub.Queue(function () {
      var all = MathJax.Hub.getAllJax(),
        i;
      // console.log(all);
      for (i = 0; i < all.length; i += 1) {
        console.log(all[i].SourceElement().parentNode)
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  }

  function reprocessMathJax() {
    if (typeof MathJax !== 'undefined') {
      MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
    }
  }
</script>


 
<link rel="stylesheet" href="//cdn.bootcss.com/gitalk/1.5.0/gitalk.min.css">
 
<script src="//cdn.bootcss.com/gitalk/1.5.0/gitalk.min.js"></script>
  
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/obsidian.js"></script>
<script src="/js/jquery.truncate.js"></script>
<script src="/js/search.js"></script>
 
<script src="//cdn.bootcss.com/typed.js/2.0.10/typed.min.js"></script>
 
<script src="//cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script>
 
<script src="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>


<script src="https://cdn.bootcss.com/codemirror/5.48.4/codemirror.min.js"></script>
 
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/javascript/javascript.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/css/css.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/xml/xml.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/htmlmixed/htmlmixed.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/clike/clike.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/php/php.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/shell/shell.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/python/python.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/java/java.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/C#/C#.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/C/C.min.js"></script>
   
<script src="/js/busuanzi.min.js"></script>

<script>
  $(document).ready(function () {
    if ($('span[id^="busuanzi_"]').length) {
      initialBusuanzi();
    }
  });
</script>
 
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/default-skin/default-skin.min.css">


<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>
 
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="//www.googletagmanager.com/gtag/js?id=UA-149874671-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag('js', new Date());

  gtag('config', 'UA-149874671-1');
</script>
 

<script>
  function initialTyped() {
    var typedTextEl = $('.typed-text');
    if (typedTextEl && typedTextEl.length > 0) {
      var typed = new Typed('.typed-text', {
        strings: ['Think like an artist, develop like an artisan', '艺术家思维去思考问题，工匠创造精神去开发'],
        typeSpeed: 90,
        loop: true,
        loopCount: Infinity,
        backSpeed: 20,
      });
    }
  }

  if ($('.article-header') && $('.article-header').length) {
    $(document).ready(function () {
      initialTyped();
    });
  }
</script>




 <!-- 例：百度统计 --> <script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?your_code"; var s = document.getElementsByTagName("script")[0];  s.parentNode.insertBefore(hm, s); })(); </script> 

</html>
